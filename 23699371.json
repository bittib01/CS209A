{
  "question": {
    "tags": [
      "java",
      "collections",
      "java-8",
      "java-stream",
      "distinct-values"
    ],
    "owner": {
      "account_id": 93245,
      "reputation": 11928,
      "user_id": 255231,
      "user_type": "registered",
      "accept_rate": 95,
      "profile_image": "https://www.gravatar.com/avatar/f65697a9dd85f1ba55c61c140d61352f?s=256&d=identicon&r=PG",
      "display_name": "RichK",
      "link": "https://stackoverflow.com/users/255231/richk"
    },
    "is_answered": true,
    "view_count": 625761,
    "protected_date": 1568810118,
    "accepted_answer_id": 27872852,
    "answer_count": 35,
    "score": 707,
    "last_activity_date": 1742574914,
    "creation_date": 1400254812,
    "last_edit_date": 1741271282,
    "question_id": 23699371,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/23699371/distinct-by-property",
    "title": "Distinct by property",
    "body": "<p>In Java 8, how can I filter a collection using the <code>Stream</code> API by checking the distinctness of a property of each object?</p>\n<p>For example, I have a list of <code>Person</code> objects and I want to remove people with the same name:</p>\n<pre><code>persons.stream().distinct();\n</code></pre>\n<p>will use the default equality check for a <code>Person</code> object, so I need something like:</p>\n<pre><code>persons.stream().distinct(p -&gt; p.getName());\n</code></pre>\n<p>Unfortunately, the <code>distinct()</code> method has no such overload. Without modifying the equality check inside the <code>Person</code> class, is it possible to do this succinctly?</p>\n"
  },
  "answers": [
    {
      "owner": {
        "account_id": 1119690,
        "reputation": 23249,
        "user_id": 1108305,
        "user_type": "registered",
        "accept_rate": 47,
        "profile_image": "https://www.gravatar.com/avatar/4c16849c5f9444a685f62cdc2a15c3ac?s=256&d=identicon&r=PG",
        "display_name": "M. Justin",
        "link": "https://stackoverflow.com/users/1108305/m-justin"
      },
      "is_accepted": false,
      "score": 3,
      "last_activity_date": 1742574914,
      "last_edit_date": 1742574914,
      "creation_date": 1703801981,
      "answer_id": 77729412,
      "question_id": 23699371,
      "content_license": "CC BY-SA 4.0",
      "body": "<p>The <a href=\"https://openjdk.org/jeps/485\" rel=\"nofollow noreferrer\">JEP 485: Stream Gatherers</a> Java 24 language feature (available as a preview language feature since Java 22) adds support for gatherer operations.  A custom gatherer could be used to filter the stream for distinct elements according to some function:</p>\n<pre class=\"lang-java prettyprint-override\"><code>void main() {\n    List&lt;Person&gt; persons = List.of(\n            new Person(&quot;A&quot;), new Person(&quot;B&quot;), new Person(&quot;C&quot;), new Person(&quot;A&quot;),\n            new Person(&quot;D&quot;), new Person(&quot;B&quot;)\n    );\n\n    List&lt;Person&gt; distinct = \n            persons.stream().gather(distinctBy(Person::getName)).toList();\n\n    // [Person[name=A], Person[name=B], Person[name=C], Person[name=D]]\n    System.out.println(distinct);\n}\n\nstatic &lt;T, R&gt; Gatherer&lt;T, ?, T&gt; distinctBy(Function&lt;T, R&gt; function) {\n    Gatherer.Integrator.Greedy&lt;Set&lt;R&gt;, T, T&gt; integrator =\n            (state, element, downstream) -&gt; {\n                R functionResult = function.apply(element);\n                if (state.contains(functionResult)) {\n                    return true;\n                } else {\n                    state.add(functionResult);\n                    return downstream.push(element);\n                }\n            };\n    return Gatherer.ofSequential(HashSet::new, integrator);\n}\n</code></pre>\n<p>The custom gatherer keeps track of the whether a given value has been encountered before based on the result of applying a function to each stream element.  If a given function value has not been encountered yet, the stream element is pushed downstream.</p>\n<p>Granted, this is a fair amount of code in isolation, but it is a reusable intermediate operation for any stream that needs to operate only on distinct elements based on a given function.</p>\n<p>Here is the same solution, with a one-off gatherer specific to the <code>Person</code> scenario:</p>\n<pre class=\"lang-java prettyprint-override\"><code>List&lt;Person&gt; distinct = persons.stream().gather(Gatherer.ofSequential(\n        HashSet::new,\n        Gatherer.Integrator.&lt;Set&lt;String&gt;, Person, Person&gt;ofGreedy(\n                (state, element, downstream) -&gt; {\n                    String name = element.getName();\n                    if (state.contains(name)) {\n                        return true;\n                    } else {\n                        state.add(name);\n                        return downstream.push(element);\n                    }\n                })\n)).toList();\n</code></pre>\n<h1>Javadocs</h1>\n<p><a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.html\" rel=\"nofollow noreferrer\"><code>Gatherer</code></a>:</p>\n<blockquote>\n<p>An intermediate operation that transforms a stream of input elements into a stream of output elements, optionally applying a final action when the end of the upstream is reached. […]</p>\n<p>[…]</p>\n<p>There are many examples of gathering operations, including but not limited to: grouping elements into batches (windowing functions); de-duplicating consecutively similar elements; incremental accumulation functions (prefix scan); incremental reordering functions, etc. The class <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherers.html\" rel=\"nofollow noreferrer\"><code>Gatherers</code></a> provides implementations of common gathering operations.</p>\n<p><strong>API Note:</strong></p>\n<p>A <code>Gatherer</code> is specified by four functions that work together to process input elements, optionally using intermediate state, and optionally perform a final action at the end of input. They are:</p>\n<ul>\n<li>creating a new, potentially mutable, state (<a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.html#initializer()\" rel=\"nofollow noreferrer\"><code>initializer()</code></a>)</li>\n<li>integrating a new input element (<a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.html#integrator()\" rel=\"nofollow noreferrer\"><code>integrator()</code></a>)</li>\n<li>combining two states into one (<a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.html#combiner()\" rel=\"nofollow noreferrer\"><code>combiner()</code></a>)</li>\n<li>performing an optional final action (<a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.html#finisher()\" rel=\"nofollow noreferrer\"><code>finisher()</code></a>)</li>\n</ul>\n</blockquote>\n<p><a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Stream.html#gather(java.util.stream.Gatherer)\" rel=\"nofollow noreferrer\"><code>Stream.gather(Gatherer&lt;? super T,?,R&gt; gatherer)</code></a>:</p>\n<blockquote>\n<p>Returns a stream consisting of the results of applying the given gatherer to the elements of this stream.</p>\n</blockquote>\n<p><a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.html#ofSequential(java.util.function.Supplier,java.util.stream.Gatherer.Integrator)\" rel=\"nofollow noreferrer\"><code>Gatherer.ofSequential(initializer, integrator)</code></a></p>\n<blockquote>\n<p>Returns a new, sequential, <code>Gatherer</code> described by the given <code>initializer</code> and <code>integrator</code>.</p>\n</blockquote>\n"
    }
  ],
  "question_comments": [],
  "answer_comments": {
    "77729412": []
  }
}