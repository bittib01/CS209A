{
  "question": {
    "tags": [
      "java",
      "postgresql",
      "tomcat",
      "jdbc",
      "memory-leaks"
    ],
    "owner": {
      "account_id": 461547,
      "reputation": 3316,
      "user_id": 863311,
      "user_type": "registered",
      "accept_rate": 62,
      "profile_image": "https://www.gravatar.com/avatar/3731c7120e30182ebf4f3fbb8609468a?s=256&d=identicon&r=PG",
      "display_name": "Simon",
      "link": "https://stackoverflow.com/users/863311/simon"
    },
    "is_answered": true,
    "view_count": 639,
    "accepted_answer_id": 78171021,
    "answer_count": 2,
    "score": 1,
    "last_activity_date": 1764754783,
    "creation_date": 1710449170,
    "question_id": 78163385,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78163385/does-postgres-jdbc-lazycleaner-cause-a-classloader-memory-leak",
    "title": "Does Postgres JDBC LazyCleaner cause a classloader memory leak?",
    "body": "<p>I have a Spring Boot web application which is deployed multiple times a day, so a clean undeploy is essential. Tomcat is reporting a memory leak, and MAT points me to</p>\n<p><a href=\"https://i.sstatic.net/gybdr.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/gybdr.png\" alt=\"Path to GC Root\" /></a></p>\n<p>I'm using postgresql-42.6.0.jar, and have placed that JAR in the Tomcat 10.1 ./lib directory (as JDBC drivers should be, afaik). It seems to me the web app present at Tomcat startup loads <code>org.postgresql.util.LazyCleaner</code>, which then starts the &quot;PostgreSQL-JDBC-Cleaner&quot; thread. As the thread inherits the AccessControlContext of the ProtectionDomain loaded by the webapp class loader, that class loader will forever have a reference which cannot be gc'ed, ergo a memory leak.</p>\n<p>I can't find anything online that others are also having this issue. Am I missing something?</p>\n"
  },
  "answers": [
    {
      "owner": {
        "account_id": 1313919,
        "reputation": 1545,
        "user_id": 1261287,
        "user_type": "registered",
        "accept_rate": 50,
        "profile_image": "https://www.gravatar.com/avatar/212115a31533862673813157bcfdd033?s=256&d=identicon&r=PG",
        "display_name": "Vladimir Sitnikov",
        "link": "https://stackoverflow.com/users/1261287/vladimir-sitnikov"
      },
      "is_accepted": false,
      "score": 1,
      "last_activity_date": 1764754783,
      "last_edit_date": 1764754783,
      "creation_date": 1764683025,
      "answer_id": 79835942,
      "question_id": 78163385,
      "content_license": "CC BY-SA 4.0",
      "body": "<p>Looks like the bug is caused by <code>Thread.inheritedAccessControlContext</code> which captures the caller's protection domain. There's no API to clear the access control context, however, there's an alternative option to spawn threads without the access control context: <code>ForkJoinPool + ManagedBlocker</code></p>\n<p>I've removed <code>new Thread</code>, so the issue should no longer be there: <a href=\"https://github.com/pgjdbc/pgjdbc/pull/3886\" rel=\"nofollow noreferrer\">https://github.com/pgjdbc/pgjdbc/pull/3886</a></p>\n<p>PS. The cleaner thread is started only when there are resources in use, and the thread should automatically exit if there is no open connections/statements</p>\n"
    },
    {
      "owner": {
        "account_id": 461547,
        "reputation": 3316,
        "user_id": 863311,
        "user_type": "registered",
        "accept_rate": 62,
        "profile_image": "https://www.gravatar.com/avatar/3731c7120e30182ebf4f3fbb8609468a?s=256&d=identicon&r=PG",
        "display_name": "Simon",
        "link": "https://stackoverflow.com/users/863311/simon"
      },
      "is_accepted": true,
      "score": 2,
      "last_activity_date": 1710576213,
      "creation_date": 1710576213,
      "answer_id": 78171021,
      "question_id": 78163385,
      "content_license": "CC BY-SA 4.0",
      "body": "<p>LazyCleaner was introduced with 42.6.0, as an attempt to deal with memory leaks (<a href=\"https://github.com/pgjdbc/pgjdbc/issues/1360\" rel=\"nofollow noreferrer\">https://github.com/pgjdbc/pgjdbc/issues/1360</a> and <a href=\"https://github.com/pgjdbc/pgjdbc/issues/1431\" rel=\"nofollow noreferrer\">https://github.com/pgjdbc/pgjdbc/issues/1431</a>). The class uses Java's PhantomReference to find when a &quot;referent&quot; object is gc'ed, and then runs an associated 'CleaningAction'. All this runs in a &quot;PostgreSQL-JDBC-Cleaner&quot; thread. If the thread doesn't have any &quot;referent&quot; objects at all within a TTL (default is 30s), the thread exits. Registering any &quot;referent&quot; object will create a new thread if necessary.</p>\n<p>What parts of postgresql-42.6.0.jar use the LazyCleaner?</p>\n<pre><code>PgConnection.java\ncleanable = LazyCleaner.getInstance().register(leakHandle, finalizeAction);\n\nStreamWrapper.java\ncleaner = LazyCleaner.getInstance().register(leakHandle, tempFileHolder);\n\nSharedTimer.java\nthis.timerCleanup = LazyCleaner.getInstance().register(refCount, new TimerCleanup(timer));\n</code></pre>\n<p>So it's:</p>\n<ul>\n<li>Every PgConnection registers itself with a PgConnectionCleaningAction</li>\n<li>Every psql StreamWrapper registers itself with a TempFileHolder (implements CleaningAction) to close streams and delete temp files</li>\n<li>Every psql SharedTimer registers itself with a TimerCleanup to cancel the timer</li>\n</ul>\n<p>The latter two are come-and-go registrations, but the PgConnection is an issue. In a setup with</p>\n<ul>\n<li>Tomcat with postgresql-42.6.0.jar in /lib for the common classloader</li>\n<li>Multiple webapps using PSQL</li>\n<li>Each webapp using a connection pool which keeps connections alive for a while</li>\n</ul>\n<p>each webapp will have PgConnection instances registered in the LazyCleaner, which is shared as common lib (by design). Thus re-deploying one webapp will not stop the LazyCleaner thread, as the other webapp(s) still have PgConnections registered.</p>\n<p>A Thread will inherit an AccessControlContext through its stacktrace on start, the effect of which is that the initial LazyCleaner thread will hold a reference to the ProtectionDomain of the webapp that initially started the thread. As described above, the LazyCleaner thread then never exits, and thus keeps that webapp classloader from gc.</p>\n<p>For now, a downgrade to postgresql-42.5.6.jar solves the problem.</p>\n"
    }
  ],
  "question_comments": [],
  "answer_comments": {
    "79835942": [
      {
        "owner": {
          "account_id": 461547,
          "reputation": 3316,
          "user_id": 863311,
          "user_type": "registered",
          "accept_rate": 62,
          "profile_image": "https://www.gravatar.com/avatar/3731c7120e30182ebf4f3fbb8609468a?s=256&d=identicon&r=PG",
          "display_name": "Simon",
          "link": "https://stackoverflow.com/users/863311/simon"
        },
        "edited": false,
        "score": 0,
        "creation_date": 1764864346,
        "post_id": 79835942,
        "comment_id": 140887591,
        "content_license": "CC BY-SA 4.0"
      }
    ],
    "78171021": []
  }
}