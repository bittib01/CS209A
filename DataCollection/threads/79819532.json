{
  "question": {
    "tags": [
      "java",
      "javafx",
      "controlsfx"
    ],
    "owner": {
      "account_id": 29993882,
      "reputation": 51,
      "user_id": 22985797,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/64e871109c0566f204530e33aeeeb319?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "fawfulsPikminArmy",
      "link": "https://stackoverflow.com/users/22985797/fawfulspikminarmy"
    },
    "is_answered": false,
    "view_count": 83,
    "answer_count": 0,
    "score": 4,
    "last_activity_date": 1763077445,
    "creation_date": 1763077445,
    "question_id": 79819532,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79819532/calling-searchablecombobox-getitems-remove-from-the-onaction-event-results-i",
    "title": "Calling SearchableComboBox.getItems().remove() from the OnAction Event results in an IndexOutOfBoundsException",
    "body": "<p>I am trying to create a JavaFX project featuring multiple instances of the SearchableComboBox control from the ControlsFX library, each having the same list of options. When an option is selected in a box, it is removed from the others using the .getItems().remove() method. I store the selected value in a variable so that when a new value is chosen, the prior value can be added back to the other boxes.</p>\n<p>While coding this I encountered two problems:</p>\n<ol>\n<li>The OnAction Event is triggered three times, setting the box to the intended value, then to null, then back to the intended value. I have coded a workaround by checking the value of the box to see if it is null or already matches the prior value and not running code if either is true.</li>\n<li>When .getItems().remove() is called, it generates an Index out of bounds for length Error.</li>\n</ol>\n<p>The code technically works in terms of the final result. However, I would assume that the error indicates that I am not using best practice, or that something is wrong with the library.</p>\n<p>I have tried using Platform.runLater(), but the error still is generated. I have also tested a version of the code with the base JavaFX ComboBox and neither issue occurs there. Is there a way to avoid the Index out of bounds for length error?</p>\n<p>I have written a demo of the issue as a means of better understanding it and providing code that recreates the error.</p>\n<pre><code>public class HelloController {\n    @FXML\n    private SearchableComboBox&lt;String&gt; cb1;\n    @FXML\n    private SearchableComboBox&lt;String&gt; cb2;\n    @FXML\n    private SearchableComboBox&lt;String&gt; cb3;\n\n    private ArrayList&lt;SearchableComboBox&lt;String&gt;&gt; comboBoxes;\n\n    String strSelected1;\n    String strSelected2;\n    String strSelected3;\n\n    public void initialize() {\n        ArrayList&lt;String&gt; strsList = new ArrayList&lt;String&gt;();\n        strsList.add(&quot;A&quot;);\n        strsList.add(&quot;B&quot;);\n        strsList.add(&quot;C&quot;);\n        strsList.add(&quot;D&quot;);\n        strsList.add(&quot;E&quot;);\n        strsList.add(&quot;F&quot;);\n        strsList.add(&quot;G&quot;);\n        strsList.add(&quot;H&quot;);\n        cb1.setItems(FXCollections.observableList((ArrayList&lt;String&gt;) strsList.clone()));\n        cb2.setItems(FXCollections.observableList((ArrayList&lt;String&gt;) strsList.clone()));\n        cb3.setItems(FXCollections.observableList((ArrayList&lt;String&gt;) strsList.clone()));\n        comboBoxes = new ArrayList&lt;SearchableComboBox&lt;String&gt;&gt;();\n        comboBoxes.add(cb1);\n        comboBoxes.add(cb2);\n        comboBoxes.add(cb3);\n    }\n\n    // get selected value from combobox, remove from other two comboboxes\n    // re-add previously selected value to combobox\n    private void readdPreviousAndRemoveSelected(SearchableComboBox&lt;String&gt; cbSelected, String priorSelection) {\n        System.out.println(&quot;Selected Value: &quot; + cbSelected.getValue());\n        for (SearchableComboBox&lt;String&gt; cb: comboBoxes) {\n            if (cb != cbSelected) {\n                System.out.println(&quot;Selected Value (Other Box): &quot; + cb.getValue());\n                if (priorSelection != null) {\n                    Platform.runLater(() -&gt; {\n                        System.out.println(&quot;Readd: &quot; + priorSelection);\n                        cb.getItems().add(priorSelection);\n                    });\n                }\n                if (cbSelected.getValue() != null)  {\n                    Platform.runLater(() -&gt; {\n                        System.out.println(&quot;Remove: &quot; + cbSelected.getValue());\n                        cb.getItems().remove(cbSelected.getValue());\n                    });\n                }\n                System.out.println(&quot;Size (Other Box): &quot; + cb.getItems().size());\n            }\n        }\n    }\n\n    @FXML\n    private void OnCB1Selected() {\n        System.out.println(&quot;CB1 OnAction: Str: &quot; + strSelected1 + &quot; Box: &quot; + cb1.getValue());\n        // if statement prevents code from running if value is null or already set\n        // thus, it prevents the additional calls to the method from doing much\n        if (cb1.getValue() != null &amp;&amp; !Objects.equals(cb1.getValue(), strSelected1)) {\n            readdPreviousAndRemoveSelected(cb1, strSelected1);\n            strSelected1 = cb1.getValue();\n        }\n        System.out.println(&quot;End CB1: STR: &quot; + strSelected1 + &quot; Box: &quot; + cb1.getValue());\n    }\n\n    @FXML\n    private void OnCB2Selected() {\n        System.out.println(&quot;CB2 OnAction: Str: &quot; + strSelected2 + &quot; Box: &quot; + cb2.getValue());\n        // if statement prevents code from running if value is null or already set\n        // thus, it prevents the additional calls to the method from doing much\n        if (cb2.getValue() != null &amp;&amp; !Objects.equals(cb2.getValue(), strSelected2)) {\n            readdPreviousAndRemoveSelected(cb2, strSelected2);\n            strSelected2 = cb2.getValue();\n        }\n        System.out.println(&quot;End CB2: STR: &quot; + strSelected2 + &quot; Box: &quot; + cb2.getValue());\n    }\n\n    @FXML\n    private void OnCB3Selected() {\n        System.out.println(&quot;CB3 OnAction: Str: &quot; + strSelected3 + &quot; Box: &quot; + cb3.getValue());\n        // if statement prevents code from running if value is null or already set\n        // thus, it prevents the additional calls to the method from doing much\n        if (cb3.getValue() != null &amp;&amp; !Objects.equals(cb3.getValue(), strSelected3)) {\n            readdPreviousAndRemoveSelected(cb3, strSelected3);\n            strSelected3 = cb3.getValue();\n        }\n        System.out.println(&quot;End CB3: STR: &quot; + strSelected3 + &quot; Box: &quot; + cb3.getValue());\n    }\n}\n</code></pre>\n<p>Here is the accompanying fxml:</p>\n<pre><code>&lt;VBox alignment=&quot;CENTER&quot; prefHeight=&quot;300.0&quot; prefWidth=&quot;300.0&quot; spacing=&quot;20.0&quot; xmlns=&quot;http://javafx.com/javafx/null&quot; xmlns:fx=&quot;http://javafx.com/fxml/1&quot; fx:controller=&quot;dvcom.demo.multicombobox.HelloController&quot;&gt;\n    &lt;padding&gt;\n        &lt;Insets bottom=&quot;20.0&quot; left=&quot;20.0&quot; right=&quot;20.0&quot; top=&quot;20.0&quot; /&gt;\n    &lt;/padding&gt;\n   &lt;children&gt;\n      &lt;SearchableComboBox fx:id=&quot;cb1&quot; onAction=&quot;#OnCB1Selected&quot; /&gt;\n      &lt;SearchableComboBox fx:id=&quot;cb2&quot; onAction=&quot;#OnCB2Selected&quot; /&gt;\n      &lt;SearchableComboBox fx:id=&quot;cb3&quot; onAction=&quot;#OnCB3Selected&quot; /&gt;\n   &lt;/children&gt;\n&lt;/VBox&gt;\n</code></pre>\n<p>Thank you for your time and attention.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}