{
  "question": {
    "tags": [
      "java",
      "integer"
    ],
    "owner": {
      "account_id": 53549,
      "reputation": 5734,
      "user_id": 160116,
      "user_type": "registered",
      "accept_rate": 86,
      "profile_image": "https://www.gravatar.com/avatar/4bd143897382f57b3f426f0f165e4fdb?s=256&d=identicon&r=PG",
      "display_name": "fnst",
      "link": "https://stackoverflow.com/users/160116/fnst"
    },
    "is_answered": true,
    "view_count": 744995,
    "protected_date": 1446370356,
    "accepted_answer_id": 1306799,
    "answer_count": 29,
    "score": 476,
    "last_activity_date": 1688392362,
    "creation_date": 1250779915,
    "last_edit_date": 1605197319,
    "question_id": 1306727,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/1306727/way-to-get-number-of-digits-in-an-int",
    "title": "Way to get number of digits in an int?",
    "body": "<p>Is there a neater way for getting the number of digits in an int than this method?</p>\n<pre><code>int numDigits = String.valueOf(1000).length();\n</code></pre>\n"
  },
  "answers": [
    {
      "owner": {
        "account_id": 52261,
        "reputation": 2677,
        "user_id": 156116,
        "user_type": "registered",
        "profile_image": "https://www.gravatar.com/avatar/096c0574e38e8ba8ed7bb0400d4fc6df?s=256&d=identicon&r=PG",
        "display_name": "Marian",
        "link": "https://stackoverflow.com/users/156116/marian"
      },
      "is_accepted": false,
      "score": 185,
      "last_activity_date": 1688392362,
      "last_edit_date": 1688392362,
      "creation_date": 1250797544,
      "answer_id": 1308407,
      "question_id": 1306727,
      "content_license": "CC BY-SA 4.0",
      "body": "<p>The fastest approach: divide and conquer.</p>\n<p>Assuming your range is 0 to MAX_INT, then you have 1 to 10 digits. You can approach this interval using divide and conquer, with up to 4 comparisons per each input. First, you divide [1..10] into [1..5] and [6..10] with one comparison, and then each length 5 interval you divide using one comparison into one length 3 and one length 2 interval. The length 2 interval requires one more comparison (total 3 comparisons), the length 3 interval can be divided into length 1 interval (solution) and a length 2 interval. So, you need 3 or 4 comparisons.</p>\n<p>No divisions, no floating point operations, no expensive logarithms, only integer comparisons.</p>\n<p>Code (long but fast):</p>\n<pre><code>if (n &lt; 100000) { // 1 to 5\n    if (n &lt; 100) { // 1 or 2\n        if (n &lt; 10) return 1;\n        return 2;\n    }\n    else { // 3, 4 or 5\n        if (n &lt; 1000) return 3;\n        if (n &lt; 10000) return 4;\n        return 5;\n    }\n}\nelse { // 6 to 7\n    if (n &lt; 10000000) { // 6 or 7\n        if (n &lt; 1000000) return 6;\n        return 7;\n    }\n    else { // 8, 9 or 10\n        if (n &lt; 100000000) return 8;\n        if (n &lt; 1000000000) return 9;\n        return 10;\n    }\n}\n</code></pre>\n<p>Benchmark (after JVM warm-up) - see code below to see how the benchmark was run:</p>\n<ol>\n<li>baseline method (with String.length):\n2145ms</li>\n<li>log10 method: 711ms = 3.02 times\nas fast as baseline</li>\n<li>repeated divide: 2797ms = 0.77 times\nas fast as baseline</li>\n<li>divide-and-conquer: 74ms = 28.99<br />\ntimes as fast as baseline</li>\n</ol>\n<p>Full code:</p>\n<pre><code>public static void main(String[] args) throws Exception {\n    \n    // validate methods:\n    for (int i = 0; i &lt; 1000; i++)\n        if (method1(i) != method2(i))\n            System.out.println(i);\n    for (int i = 0; i &lt; 1000; i++)\n        if (method1(i) != method3(i))\n            System.out.println(i + &quot; &quot; + method1(i) + &quot; &quot; + method3(i));\n    for (int i = 333; i &lt; 2000000000; i += 1000)\n        if (method1(i) != method3(i))\n            System.out.println(i + &quot; &quot; + method1(i) + &quot; &quot; + method3(i));\n    for (int i = 0; i &lt; 1000; i++)\n        if (method1(i) != method4(i))\n            System.out.println(i + &quot; &quot; + method1(i) + &quot; &quot; + method4(i));\n    for (int i = 333; i &lt; 2000000000; i += 1000)\n        if (method1(i) != method4(i))\n            System.out.println(i + &quot; &quot; + method1(i) + &quot; &quot; + method4(i));\n    \n    // work-up the JVM - make sure everything will be run in hot-spot mode\n    allMethod1();\n    allMethod2();\n    allMethod3();\n    allMethod4();\n    \n    // run benchmark\n    Chronometer c;\n    \n    c = new Chronometer(true);\n    allMethod1();\n    c.stop();\n    long baseline = c.getValue();\n    System.out.println(c);\n    \n    c = new Chronometer(true);\n    allMethod2();\n    c.stop();\n    System.out.println(c + &quot; = &quot; + StringTools.formatDouble((double)baseline / c.getValue() , &quot;0.00&quot;) + &quot; times as fast as baseline&quot;);\n    \n    c = new Chronometer(true);\n    allMethod3();\n    c.stop();\n    System.out.println(c + &quot; = &quot; + StringTools.formatDouble((double)baseline / c.getValue() , &quot;0.00&quot;) + &quot; times as fast as baseline&quot;);\n    \n    c = new Chronometer(true);\n    allMethod4();\n    c.stop();\n    System.out.println(c + &quot; = &quot; + StringTools.formatDouble((double)baseline / c.getValue() , &quot;0.00&quot;) + &quot; times as fast as baseline&quot;);\n}\n\n\nprivate static int method1(int n) {\n    return Integer.toString(n).length();\n}\n\nprivate static int method2(int n) {\n    if (n == 0)\n        return 1;\n    return (int)(Math.log10(n) + 1);\n}\n\nprivate static int method3(int n) {\n    if (n == 0)\n        return 1;\n    int l;\n    for (l = 0 ; n &gt; 0 ;++l)\n        n /= 10;\n    return l;\n}\n\nprivate static int method4(int n) {\n    if (n &lt; 100000) {\n        // 5 or less\n        if (n &lt; 100) {\n            // 1 or 2\n            if (n &lt; 10)\n                return 1;\n            else\n                return 2;\n        } else {\n            // 3 or 4 or 5\n            if (n &lt; 1000)\n                return 3;\n            else {\n                // 4 or 5\n                if (n &lt; 10000)\n                    return 4;\n                else\n                    return 5;\n            }\n        }\n    } else {\n        // 6 or more\n        if (n &lt; 10000000) {\n            // 6 or 7\n            if (n &lt; 1000000)\n                return 6;\n            else\n                return 7;\n        } else {\n            // 8 to 10\n            if (n &lt; 100000000)\n                return 8;\n            else {\n                // 9 or 10\n                if (n &lt; 1000000000)\n                    return 9;\n                else\n                    return 10;\n            }\n        }\n    }\n}\n\n\nprivate static int allMethod1() {\n    int x = 0;\n    for (int i = 0; i &lt; 1000; i++)\n        x = method1(i);\n    for (int i = 1000; i &lt; 100000; i += 10)\n        x = method1(i);\n    for (int i = 100000; i &lt; 1000000; i += 100)\n        x = method1(i);\n    for (int i = 1000000; i &lt; 2000000000; i += 200)\n        x = method1(i);\n    \n    return x;\n}\n\nprivate static int allMethod2() {\n    int x = 0;\n    for (int i = 0; i &lt; 1000; i++)\n        x = method2(i);\n    for (int i = 1000; i &lt; 100000; i += 10)\n        x = method2(i);\n    for (int i = 100000; i &lt; 1000000; i += 100)\n        x = method2(i);\n    for (int i = 1000000; i &lt; 2000000000; i += 200)\n        x = method2(i);\n    \n    return x;\n}\n\nprivate static int allMethod3() {\n    int x = 0;\n    for (int i = 0; i &lt; 1000; i++)\n        x = method3(i);\n    for (int i = 1000; i &lt; 100000; i += 10)\n        x = method3(i);\n    for (int i = 100000; i &lt; 1000000; i += 100)\n        x = method3(i);\n    for (int i = 1000000; i &lt; 2000000000; i += 200)\n        x = method3(i);\n    \n    return x;\n}\n\nprivate static int allMethod4() {\n    int x = 0;\n    for (int i = 0; i &lt; 1000; i++)\n        x = method4(i);\n    for (int i = 1000; i &lt; 100000; i += 10)\n        x = method4(i);\n    for (int i = 100000; i &lt; 1000000; i += 100)\n        x = method4(i);\n    for (int i = 1000000; i &lt; 2000000000; i += 200)\n        x = method4(i);\n    \n    return x;\n}\n</code></pre>\n<p>Again, benchmark:</p>\n<ol>\n<li>baseline method (with String.length): 2145ms</li>\n<li>log10 method: 711ms = 3.02 times as fast as baseline</li>\n<li>repeated divide: 2797ms = 0.77 times as fast as baseline</li>\n<li>divide-and-conquer: 74ms = 28.99 times as fast as baseline</li>\n</ol>\n<hr />\n<h2>Edit</h2>\n<p>After I wrote the benchmark, I took a sneak peak into Integer.toString from Java 6, and I found that it uses:</p>\n<pre><code>final static int [] sizeTable = { 9, 99, 999, 9999, 99999, 999999, 9999999,\n                                  99999999, 999999999, Integer.MAX_VALUE };\n\n// Requires positive x\nstatic int stringSize(int x) {\n    for (int i=0; ; i++)\n        if (x &lt;= sizeTable[i])\n            return i+1;\n}\n</code></pre>\n<p>I benchmarked it against my divide-and-conquer solution:</p>\n<ol start=\"4\">\n<li>divide-and-conquer: 104ms</li>\n<li>Java 6 solution - iterate and compare: 406ms</li>\n</ol>\n<p>Mine is about 4x as fast as the Java 6 solution.</p>\n"
    }
  ],
  "question_comments": [
    {
      "owner": {
        "account_id": 3693774,
        "reputation": 119,
        "user_id": 3075740,
        "user_type": "registered",
        "profile_image": "https://www.gravatar.com/avatar/888457fb77d2b664aac48971f94124c2?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name": "user3075740",
        "link": "https://stackoverflow.com/users/3075740/user3075740"
      },
      "edited": false,
      "score": 0,
      "creation_date": 1581010041,
      "post_id": 1306727,
      "comment_id": 106295857,
      "content_license": "CC BY-SA 4.0"
    }
  ],
  "answer_comments": {
    "1308407": [
      {
        "owner": {
          "account_id": 1364678,
          "reputation": 2232,
          "user_id": 1301373,
          "user_type": "registered",
          "profile_image": "https://www.gravatar.com/avatar/56eb9a131846d4447ca24b5ea9ecb600?s=256&d=identicon&r=PG",
          "display_name": "winne2",
          "link": "https://stackoverflow.com/users/1301373/winne2"
        },
        "edited": false,
        "score": 0,
        "creation_date": 1762808497,
        "post_id": 1308407,
        "comment_id": 140847547,
        "content_license": "CC BY-SA 4.0"
      },
      {
        "owner": {
          "account_id": 10042541,
          "reputation": 2981,
          "user_id": 7424948,
          "user_type": "registered",
          "profile_image": "https://www.gravatar.com/avatar/69eae52577e03b5e508185bd86894abe?s=256&d=identicon&r=PG&f=y&so-version=2",
          "display_name": "Ricola",
          "link": "https://stackoverflow.com/users/7424948/ricola"
        },
        "edited": false,
        "score": 0,
        "creation_date": 1668274780,
        "post_id": 1308407,
        "comment_id": 131367627,
        "content_license": "CC BY-SA 4.0"
      },
      {
        "owner": {
          "account_id": 436264,
          "reputation": 3595,
          "user_id": 823321,
          "user_type": "registered",
          "profile_image": "https://i.sstatic.net/lrwbB.png?s=256",
          "display_name": "sɐunıɔןɐqɐp",
          "link": "https://stackoverflow.com/users/823321/s%c9%90un%c4%b1%c9%94%d7%9f%c9%90q%c9%90p"
        },
        "reply_to_user": {
          "account_id": 32417,
          "reputation": 41439,
          "user_id": 89989,
          "user_type": "registered",
          "accept_rate": 74,
          "profile_image": "https://www.gravatar.com/avatar/8379dc25724c470e36b2f7f659b060ad?s=256&d=identicon&r=PG",
          "display_name": "Gordon Gustafson",
          "link": "https://stackoverflow.com/users/89989/gordon-gustafson"
        },
        "edited": false,
        "score": 0,
        "creation_date": 1611317063,
        "post_id": 1308407,
        "comment_id": 116418186,
        "content_license": "CC BY-SA 4.0"
      }
    ]
  }
}