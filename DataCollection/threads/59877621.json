{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "spring-security",
      "oauth-2.0",
      "backend"
    ],
    "owner": {
      "account_id": 15566700,
      "reputation": 181,
      "user_id": 11230206,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/98d18dd5160eed566e702705492c694e?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "arman",
      "link": "https://stackoverflow.com/users/11230206/arman"
    },
    "is_answered": true,
    "view_count": 20298,
    "answer_count": 5,
    "score": 11,
    "last_activity_date": 1764336923,
    "creation_date": 1579779221,
    "question_id": 59877621,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/59877621/is-it-okay-to-cache-verified-jwt-token-to-prevent-repeated-verification-process",
    "title": "Is it okay to Cache verified JWT token to prevent repeated verification process in spring-boot application",
    "body": "<p>We have a spring-boot appplication with microservice architecture.\n<br> We have a separate service for Authentication which provides a JWT token signed with RS256 algorithm.<br>This token is sent in every request from client to our main application server.\nI have the public key for verifying the signature.\n<br>Now this JWT token is being sent in every API request from client side as most of our URLs are protected.\n<br><br>Is it a good idea to cache the already verified JWT token to prevent repeated verification process of same token on every API call from same user? </p>\n"
  },
  "answers": [
    {
      "owner": {
        "account_id": 5668909,
        "reputation": 81,
        "user_id": 4484241,
        "user_type": "registered",
        "profile_image": "https://www.gravatar.com/avatar/65f5109aa01727c23a6d5c5101fbe392?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name": "Repotec",
        "link": "https://stackoverflow.com/users/4484241/repotec"
      },
      "is_accepted": false,
      "score": 0,
      "last_activity_date": 1764336923,
      "creation_date": 1764336923,
      "answer_id": 79832602,
      "question_id": 59877621,
      "content_license": "CC BY-SA 4.0",
      "body": "<p>JWTs are self-contained tokens, so building a server-side cache of the tokens themselves is unnecessary and, honestly, a pretty bad design choice. They’re meant to be validated on each request by checking the signature, exp, audience, scopes, etc., using cached JWK/public keys.</p>\n<p>In the past, what we were really caching wasn’t JWTs but opaque/reference tokens (or their introspection results), because the resource server couldn’t validate them locally and we wanted to avoid calling the auth server on every single request. With JWTs, we typically shouldn’t store tokens in Redis or a DB at all.</p>\n<p>The only thing that really makes sense to cache is the JWK set and maybe some decoded data in the scope of a single request.</p>\n<p>The <strong>Token Relay</strong> pattern (for example, via Spring Cloud Gateway in your case) is mainly about forwarding the same token downstream, not about changing its lifetime or adding extra control. <strong>Token Exchange</strong> pattern, on the other hand, does give you more control, since it lets you exchange an incoming token for another one with a different audience, scope, and lifetime (usually for server-to-server scenarios).</p>\n<p>Last, in modern setups, real control over access comes from short-lived access tokens, refresh tokens with rotation, token exchange, and, when necessary, opaque tokens plus introspection not from caching JWTs themselves.</p>\n"
    },
    {
      "owner": {
        "account_id": 12368896,
        "reputation": 30244,
        "user_id": 9019885,
        "user_type": "registered",
        "profile_image": "https://i.sstatic.net/bqpQh.jpg?s=256",
        "display_name": "Gary Archer",
        "link": "https://stackoverflow.com/users/9019885/gary-archer"
      },
      "is_accepted": false,
      "score": 12,
      "last_activity_date": 1729880729,
      "last_edit_date": 1729880729,
      "creation_date": 1579809616,
      "answer_id": 59886220,
      "question_id": 59877621,
      "content_license": "CC BY-SA 4.0",
      "body": "<p>In memory JWT access token validation is fast and you can do that on every API request. In other cases there can be good reasons to cache token-related results so that you avoid repeating expensive work on the every request with a particular access token:</p>\n<ul>\n<li><p>Sometimes, after validating the token and identifying the user, you may want to do a fairly expensive lookup of roles, business permissions etc - and you don't want to do this on every single API request.</p>\n</li>\n<li><p>API Gateway solutions often use a caching pattern, eg to cache <a href=\"https://datatracker.ietf.org/doc/html/rfc7662\" rel=\"nofollow noreferrer\">token introspection results</a>. For example, AWS API Gateway allows you to cache a policy document that is quickly looked up when the same token is next received.</p>\n</li>\n</ul>\n<p><img src=\"https://i.sstatic.net/BayC2.png\" alt=\"enter image description here\" /></p>\n<p>If you cache token results you might use a key that is a SHA256 hash of the token - and set a time to live no greater than the token's exp claim, as Ankur indicates.</p>\n"
    },
    {
      "owner": {
        "account_id": 14924293,
        "reputation": 324,
        "user_id": 10775657,
        "user_type": "registered",
        "profile_image": "https://graph.facebook.com/2209479182425061/picture?type=large",
        "display_name": "Nikolay Schamberg",
        "link": "https://stackoverflow.com/users/10775657/nikolay-schamberg"
      },
      "is_accepted": false,
      "score": 2,
      "last_activity_date": 1614502199,
      "creation_date": 1614502199,
      "answer_id": 66407339,
      "question_id": 59877621,
      "content_license": "CC BY-SA 4.0",
      "body": "<p>This wouldn’t necessarily add security issues, but you need to make sure that your cache stores verified JWT data only for as long as that token is valid. Otherwise, you are gonna have problems terminating sessions. Additionally, I’d recommend using LRU caches for this reason, so that you don’t have to store tokens that are not actively used at this point in time.</p>\n<p>@Mehrdad HosseinNejad claimed that caching tokens adds statefullness. However, I would not say it is a critical issue in this case, since other servers that have not cached JWT in memory can still verify the JWT. The issue with scaling up is that cache may grow too large and consume too much memory on each server. Once more, I don’t believe it is much of an issue either, if LRU cache is used with proper parameters. The final suggestion in his answer is to use Redis. While it could be a good advice, it might be a slight overkill, considering the additional network latency. In-memory caching is always going to be faster, no matter what. Having said that, Redis is an extremely viable solution, if you want to avoid individual servers re-doing verification, if another server has already done that.</p>\n"
    },
    {
      "owner": {
        "account_id": 8976317,
        "reputation": 1691,
        "user_id": 6693037,
        "user_type": "registered",
        "profile_image": "https://i.sstatic.net/pfdL8.jpg?s=256",
        "display_name": "Mehrdad Yami",
        "link": "https://stackoverflow.com/users/6693037/mehrdad-yami"
      },
      "is_accepted": false,
      "score": 0,
      "last_activity_date": 1579782404,
      "last_edit_date": 1579782404,
      "creation_date": 1579780533,
      "answer_id": 59877986,
      "question_id": 59877621,
      "content_license": "CC BY-SA 4.0",
      "body": "<blockquote>\n  <p>The main purpose of JWT is that of not having  <strong>server-side state</strong></p>\n  \n  <p>This means that the server will not store any information, nor will the session.</p>\n</blockquote>\n\n<hr>\n\n<ul>\n<li><p>If you cache your JWT, then your server has <strong>State</strong>. </p>\n\n<ul>\n<li>You may have trouble later when you wanna <strong>scale-up</strong> your application(have multiple instances) and you may also face some <strong>security issues</strong>.</li>\n</ul></li>\n<li><p>If you insist on the stateful server, then it's better to use cache servers like Redis, And notice that the existent time (lifetime) of each row (each JWT) must equal to its expiry date.</p></li>\n</ul>\n\n<blockquote>\n  <p>By standards, it's not a good idea to cache JWT in your server(it's\n  not a good idea to make the server stateful)</p>\n</blockquote>\n"
    },
    {
      "owner": {
        "account_id": 17370380,
        "reputation": 342,
        "user_id": 12584642,
        "user_type": "registered",
        "profile_image": "https://lh3.googleusercontent.com/a-/AAuE7mCUHStWhMrJccGsdCNOyPj9uSTyjqIE7D0I7ROz2g=k-s256",
        "display_name": "Ankur Gupta",
        "link": "https://stackoverflow.com/users/12584642/ankur-gupta"
      },
      "is_accepted": false,
      "score": 6,
      "last_activity_date": 1579780578,
      "creation_date": 1579780578,
      "answer_id": 59878002,
      "question_id": 59877621,
      "content_license": "CC BY-SA 4.0",
      "body": "<p>You can cache the JWT token but you have to set the cache timeout which should be equivalent to token timeout.</p>\n"
    }
  ],
  "question_comments": [
    {
      "owner": {
        "account_id": 15566700,
        "reputation": 181,
        "user_id": 11230206,
        "user_type": "registered",
        "profile_image": "https://www.gravatar.com/avatar/98d18dd5160eed566e702705492c694e?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name": "arman",
        "link": "https://stackoverflow.com/users/11230206/arman"
      },
      "reply_to_user": {
        "account_id": 5589309,
        "reputation": 2056,
        "user_id": 4429015,
        "user_type": "registered",
        "profile_image": "https://i.sstatic.net/XISV8.jpg?s=256",
        "display_name": "B001ᛦ",
        "link": "https://stackoverflow.com/users/4429015/b001%e1%9b%a6"
      },
      "edited": false,
      "score": 0,
      "creation_date": 1579779860,
      "post_id": 59877621,
      "comment_id": 105885125,
      "content_license": "CC BY-SA 4.0"
    },
    {
      "owner": {
        "account_id": 5589309,
        "reputation": 2056,
        "user_id": 4429015,
        "user_type": "registered",
        "profile_image": "https://i.sstatic.net/XISV8.jpg?s=256",
        "display_name": "B001ᛦ",
        "link": "https://stackoverflow.com/users/4429015/b001%e1%9b%a6"
      },
      "edited": false,
      "score": 0,
      "creation_date": 1579779327,
      "post_id": 59877621,
      "comment_id": 105884845,
      "content_license": "CC BY-SA 4.0"
    }
  ],
  "answer_comments": {
    "79832602": [],
    "59886220": [],
    "66407339": [],
    "59877986": [
      {
        "owner": {
          "account_id": 7303905,
          "reputation": 5260,
          "user_id": 5565544,
          "user_type": "registered",
          "accept_rate": 50,
          "profile_image": "https://i.sstatic.net/KYl6U.jpg?s=256",
          "display_name": "KeitelDOG",
          "link": "https://stackoverflow.com/users/5565544/keiteldog"
        },
        "edited": false,
        "score": 0,
        "creation_date": 1653511488,
        "post_id": 59877986,
        "comment_id": 127873651,
        "content_license": "CC BY-SA 4.0"
      }
    ],
    "59878002": []
  }
}