{
  "question": {
    "tags": [
      "java",
      "multithreading",
      "timing",
      "z80"
    ],
    "owner": {
      "account_id": 485936,
      "reputation": 1326,
      "user_id": 902544,
      "user_type": "registered",
      "accept_rate": 100,
      "profile_image": "https://www.gravatar.com/avatar/0b931582c0dad31cc111638b0159c1b4?s=256&d=identicon&r=PG",
      "display_name": "PhilPotter1987",
      "link": "https://stackoverflow.com/users/902544/philpotter1987"
    },
    "is_answered": true,
    "view_count": 1635,
    "accepted_answer_id": 7562385,
    "answer_count": 4,
    "score": 9,
    "last_activity_date": 1764795217,
    "creation_date": 1317057141,
    "last_edit_date": 1317061043,
    "question_id": 7558661,
    "content_license": "CC BY-SA 3.0",
    "link": "https://stackoverflow.com/questions/7558661/java-timing-accuracy-on-windows-xp-vs-windows-7",
    "title": "Java timing accuracy on Windows XP vs. Windows 7",
    "body": "<p>I have a bizarre problem - I'm hoping someone can explain to me what is happening and a possible workaround. I am implementing a Z80 core in Java, and attempting to slow it down, by using a java.util.Timer object in a separate thread.</p>\n\n<p>The basic setup is that I have one thread running an execute loop, 50 times per second. Within this execute loop, however many cycles are executed, and then wait() is invoked. The external Timer thread will invoke notifyAll() on the Z80 object every 20ms, simulating a PAL Sega Master System clock frequency of 3.54 MHz (ish).</p>\n\n<p>The method I have described above works perfectly on Windows 7 (tried two machines) but I have also tried two Windows XP machines and on both of them, the Timer object seems to be oversleeping by around 50% or so. This means that one second of emulation time is actually taking around 1.5 seconds or so on a Windows XP machine.</p>\n\n<p>I have tried using Thread.sleep() instead of a Timer object, but this has exactly the same effect. I realise granularity of time in most OSes isn't better than 1ms, but I can put up with 999ms or 1001ms instead of 1000ms. What I can't put up with is 1562ms - I just don't understand why my method works OK on newer version of Windows, but not the older one - I've investigated interrupt periods and so on, but don't seem to have developed a workaround.</p>\n\n<p>Could anyone please tell me the cause of this problem and a suggested workaround? Many thanks.</p>\n\n<p>Update: Here is the full code for a smaller app I built to show the same issue:</p>\n\n<pre><code>import java.util.Timer;\nimport java.util.TimerTask;\n\npublic class WorkThread extends Thread\n{\n   private Timer timerThread;\n   private WakeUpTask timerTask;\n\n   public WorkThread()\n   {\n      timerThread = new Timer();\n      timerTask = new WakeUpTask(this);\n   }\n\n   public void run()\n   {\n      timerThread.schedule(timerTask, 0, 20);\n      while (true)\n      {\n         long startTime = System.nanoTime();\n         for (int i = 0; i &lt; 50; i++)\n         {\n            int a = 1 + 1;\n            goToSleep();\n         }\n         long timeTaken = (System.nanoTime() - startTime) / 1000000;\n         System.out.println(\"Time taken this loop: \" + timeTaken + \" milliseconds\");\n      }\n   }\n\n   synchronized public void goToSleep()\n   {\n      try\n      {\n         wait();\n      }\n      catch (InterruptedException e)\n      {\n         System.exit(0);\n      }\n   }\n\n   synchronized public void wakeUp()\n   {\n      notifyAll();\n   }\n\n   private class WakeUpTask extends TimerTask\n   {\n       private WorkThread w;\n\n       public WakeUpTask(WorkThread t)\n       {\n          w = t;\n       }\n\n       public void run()\n       {\n          w.wakeUp();\n       }\n   }\n}\n</code></pre>\n\n<p>All the main class does is create and start one of these worker threads. On Windows 7, this code produces a time of around 999ms - 1000ms, which is totally fine. Running the same jar on Windows XP however produces a time of around 1562ms - 1566ms, and this is on two separate XP machines that I have tested this. They are all running Java 6 update 27.</p>\n\n<p>I find this problem is happening because the Timer is sleeping for 20ms (quite a small value) - if I bung all the execute loops for a single second into wait wait() - notifyAll() cycle, this produces the correct result - I'm sure people who see what I'm trying to do (emulate a Sega Master System at 50fps) will see how this is not a solution though - it won't give an interactive response time, skipping 49 of every 50. As I say, Win7 copes fine with this. Sorry if my code is too large :-(</p>\n"
  },
  "answers": [
    {
      "owner": {
        "account_id": 43360891,
        "reputation": 73,
        "user_id": 31207657,
        "user_type": "registered",
        "profile_image": "https://i.sstatic.net/AKbly48J.jpg?s=256",
        "display_name": "Michael Sapach",
        "link": "https://stackoverflow.com/users/31207657/michael-sapach"
      },
      "is_accepted": false,
      "score": 0,
      "last_activity_date": 1764795217,
      "creation_date": 1764795217,
      "answer_id": 79837322,
      "question_id": 7558661,
      "content_license": "CC BY-SA 4.0",
      "body": "<p>I saw many emulators having problems with this under Windows, so I decided to write here about my research into this issue and my solution.</p>\n<p>I encountered this behavior while developing software for Windows XP, but you can see that Windows 7 behaves similarly if you unload programs like the browser, mediaplayer, etc. As you correctly noted, Thread.sleep() in Windows does have a resolution of 15ms, which gives the thread 64 wakeups per second by default. However, this can be overridden by your program and other programs running in the background alongside your emulator.</p>\n<p>Therefore, I decided to base the application's logic on this worst-case scenario, where the thread wakes up every 15ms, but other applications can change it at any time. Every time the thread awakens, I can execute the required number of clock cycles my virtual machine should perform in 1/64 of a second and I can precisely adjust this parameter.</p>\n<p>However, calling <code>Thread.sleep(15);</code> (like your 20 or any other) isn't a good idea, since there's a high probability that the thread will miss the next window of opportunity to wake up, then the thread can wake up only after 30ms or something like that. But we need it as quickly as possible, even if itâ€™s after 15ms. That's why I use <code>Thread.sleep(1);</code> and get consistent wakeups every 15ms, at 64 times per second, if other applications did not affect the global, of course.</p>\n<p>However, background apps can change my Thread.sleep(1) to a different resolution, which will cause thread to wake up more frequently than 1/64 of a second, will speed up emulation and begin to consume the processor's computing resources more actively. Therefore, we also need to compare the current wakeup time against the previous wakeup time, and if 15ms hasn't yet elapsed, immediately send the thread back to sleep using Thread.sleep(1). The situation with &quot;frameskips&quot; (these are not frames, but you get the idea) should be handled somewhere here, in case you &quot;slept&quot; for 2*15 ms (1 &quot;frameskip&quot;) or more.</p>\n<p>I think this is the bare minimum solution that can be implemented for compatibility. You can improve this solution optionally: handle more frequent wakeups differently, obtain a more precise time, add some other thread-handling logic, such as manually reprogramming the timer, etc.</p>\n<p>I'd like to point out that this has nothing to do with the platform's virtual screen, which is supposed to refresh 50 times per second. You deliver screens at a different rate, every other number of virtual clock cycles, of course.</p>\n"
    }
  ],
  "question_comments": [],
  "answer_comments": {
    "79837322": []
  }
}