{
  "question": {
    "tags": [
      "java",
      "eclipse",
      "generics",
      "comparator"
    ],
    "owner": {
      "account_id": 184786,
      "reputation": 22234,
      "user_id": 421049,
      "user_type": "registered",
      "accept_rate": 50,
      "profile_image": "https://www.gravatar.com/avatar/4b9b843fe8e233b2f70e0f2a8e7db4e8?s=256&d=identicon&r=PG",
      "display_name": "Garret Wilson",
      "link": "https://stackoverflow.com/users/421049/garret-wilson"
    },
    "is_answered": false,
    "view_count": 277,
    "closed_date": 1494523805,
    "answer_count": 0,
    "score": 2,
    "last_activity_date": 1764631974,
    "creation_date": 1494523529,
    "last_edit_date": 1764631974,
    "question_id": 43922030,
    "link": "https://stackoverflow.com/questions/43922030/cannot-infer-arguments-for-reversed-comparator-in-java",
    "closed_reason": "Duplicate",
    "title": "Cannot infer arguments for reversed Comparator in Java",
    "body": "<p>Just when I think I am a super-expert in Java generics, a simple thing throws me for a loop. I'm using Java 8 in Eclipse 4.6.3.</p>\n<p>Let's say I make an enum of orderings for <code>FooBar</code>, and I want each enum value to give me a <code>Comparator&lt;? extends FooBar&gt;</code> appropriate for the ordering:</p>\n<pre><code>public enum FooBarOrdering {\n  BY_FOO_ASCENDING, BY_FOO_DESCENDING;\n\n  public Comparator&lt;? extends FooBar&gt; getComparator() {\n    switch (this) {\n      case BY_FOO_ASCENDING:\n        return Comparator.comparing(fooBar -&gt; fooBar.getFoo());\n      //â€¦\n    }\n  }\n}\n</code></pre>\n<p>Yay, that works for a charm, just like I thought it would! (Yes, here I could use a method reference, but ignore that for now ---that's irrelevant to the issue here.) Now to add the comparator for <code>BY_FOO_DESCENDING</code>.</p>\n<p>Hmmm... first of all, Eclipse's auto-complete doesn't seem to work on the returned comparator. Never mind --- I know how to read Javadocs, so I add this:</p>\n<pre><code>case BY_FOO_DESCENDING:\n  return Comparator.comparing(fooBar -&gt; fooBar.getFoo()).reversed();\n</code></pre>\n<p>Eclipse now tells me: <code>Cannot infer type argument(s) for &lt;T, U&gt; comparing(Function&lt;? super T,? extends U&gt;)</code></p>\n<p>And also: <code>The method getFoo() is undefined for the type Object</code></p>\n<p>Now why did <code>getFoo()</code> work just fine in the first example, but did not work when I call <em>a method from the returned Comparator value</em>? If Eclipse/Java knew that there was a <code>FooBar</code> with a <code>getFoo()</code> method in the earlier code, why did adding a <code>reversed()</code> method on the return value change anything?</p>\n<p>And here's how silly it gets: look at the source code for <code>Comparator.reversed())</code>; it simply returns <code>Collections.reverseOrder(this)</code>. So if I change the code to the following, it works fine:</p>\n<pre><code>case BY_FOO_DESCENDING:\n  return Collections.reverseOrder(Comparator.comparing(fooBar -&gt; fooBar.getFoo()));\n</code></pre>\n<p>So is this an Eclipse bug? Or is Java still just a bit dumb when it comes to generics? Or am I missing something?</p>\n<p>I would really like to use <code>Comparator.reversed()</code>, so is there some cast or <code>&lt;blah&gt;</code> I can add to the expression to make it work?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}