{
  "question": {
    "tags": [
      "java",
      "scala",
      "lucene"
    ],
    "owner": {
      "account_id": 9181967,
      "reputation": 3268,
      "user_id": 7037695,
      "user_type": "registered",
      "accept_rate": 89,
      "profile_image": "https://lh3.googleusercontent.com/-VBSyZ-n09Do/AAAAAAAAAAI/AAAAAAAAADI/zZd-wwa0QWc/s256-rj/photo.jpg",
      "display_name": "Markus Appel",
      "link": "https://stackoverflow.com/users/7037695/markus-appel"
    },
    "is_answered": false,
    "view_count": 91,
    "answer_count": 0,
    "score": 1,
    "last_activity_date": 1762367912,
    "creation_date": 1762348660,
    "last_edit_date": 1762367912,
    "question_id": 79810098,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79810098/lucene-boolean-operator-problems",
    "title": "Lucene Boolean Operator Problems",
    "body": "<p>Using Lucene, certain queries parse and execute in a completely unexpected way.</p>\n<p>Here's the code for testing it (written in Scala, but can be easily translated to Java too):</p>\n<pre class=\"lang-scala prettyprint-override\"><code>import org.apache.lucene.analysis.standard.StandardAnalyzer\nimport org.apache.lucene.document._\nimport org.apache.lucene.index._\nimport org.apache.lucene.queryparser.classic.QueryParser\nimport org.apache.lucene.search.{IndexSearcher, Query}\nimport org.apache.lucene.store._\nimport scala.jdk.CollectionConverters._\n\nobject LuceneTestUtils{\n\n  def testDocuments(\n    docs: Seq[Map[String, String]],\n    query: String,\n    expected: Seq[Map[String, String]]\n  ): Unit = {\n    withIndex(docs) { searcher =&gt;\n      val analyzer = new StandardAnalyzer()\n      val parser = new QueryParser(&quot;defaultField&quot;, analyzer)\n      val q: Query = parser.parse(query)\n      println(q)\n      val hits = searcher.search(q, 1000).scoreDocs\n      val results = hits.map { hit =&gt;\n        val doc = searcher.doc(hit.doc)\n        doc.getFields.asScala.map(f =&gt; f.name() -&gt; doc.get(f.name())).toMap\n      }\n      .toList\n\n      val notExpected = results.diff(expected)\n      assert(notExpected.isEmpty, s&quot;Got unexpected documents:\\n${notExpected.mkString(&quot;\\n&quot;)}\\nReceived documents:\\n${results.mkString(&quot;\\n&quot;)}&quot;)\n\n      val missing = expected.diff(results)\n      assert(missing.isEmpty, s&quot;Missing expected documents: \\n${missing.mkString(&quot;\\n&quot;)}\\nReceived documents:\\n${results.mkString(&quot;\\n&quot;)}&quot;)\n    }\n  }\n\n  def withIndex(\n      docs: Seq[Map[String, String]]\n  )(test: IndexSearcher =&gt; Unit): Unit = {\n    val analyzer = new StandardAnalyzer()\n    val index: Directory =\n      new org.apache.lucene.store.ByteBuffersDirectory(NoLockFactory.INSTANCE)\n    val config = new IndexWriterConfig(analyzer)\n    val writer = new IndexWriter(index, config)\n\n    docs.foreach { fields =&gt;\n      val doc = new Document()\n      fields.foreach { case (k, v) =&gt;\n        doc.add(new StringField(k, v, Field.Store.YES))\n      }\n      writer.addDocument(doc)\n    }\n    writer.close()\n\n    val reader = DirectoryReader.open(index)\n    val searcher = new IndexSearcher(reader)\n    try {\n      test(searcher)\n    } finally {\n      reader.close()\n      index.close()\n    }\n  }\n}\n</code></pre>\n<p>Dependencies used:</p>\n<pre><code>  &quot;org.apache.lucene&quot; % &quot;lucene-core&quot; % &quot;9.9.2&quot;,\n  &quot;org.apache.lucene&quot; % &quot;lucene-queryparser&quot; % &quot;9.9.2&quot;,\n</code></pre>\n<p>I generate some test data:</p>\n<pre class=\"lang-scala prettyprint-override\"><code>  private val testData =  for {\n      key1Value &lt;- Seq(Some(&quot;value1&quot;), Some(&quot;value2&quot;), None)\n      key2Value &lt;- Seq(Some(&quot;value1&quot;), Some(&quot;value2&quot;), None)\n      key3Value &lt;- Seq(Some(&quot;value1&quot;), Some(&quot;value2&quot;), None)\n      key4Value &lt;- Seq(Some(&quot;value1&quot;), Some(&quot;value2&quot;), None)\n    } yield Seq(\n      key1Value.map(&quot;key1&quot; -&gt; _),\n      key2Value.map(&quot;key2&quot; -&gt; _),\n      key3Value.map(&quot;key3&quot; -&gt; _),\n      key4Value.map(&quot;key4&quot; -&gt; _)\n    ).flatten.toMap\n</code></pre>\n<p>Most queries work exactly as expected, e.g.:</p>\n<p>1.</p>\n<pre class=\"lang-scala prettyprint-override\"><code>    val expectedDocs = testData\n      .filter(doc =&gt;\n        (doc.get(&quot;key1&quot;).contains(&quot;value2&quot;) || doc.get(&quot;key2&quot;).contains(&quot;value2&quot;)) &amp;&amp;\n        (doc.get(&quot;key3&quot;).contains(&quot;value2&quot;) || doc.get(&quot;key4&quot;).contains(&quot;value2&quot;))\n      )\n\n    LuceneTestUtils.testDocuments(testData, &quot;(key1:value2 OR key2:value2) AND (key3:value2 OR key4:value2)&quot;, expectedDocs)\n</code></pre>\n<p>The following test cases show very unexpected behaviour:</p>\n<p>2.</p>\n<pre class=\"lang-scala prettyprint-override\"><code>   val expectedDocs = testData\n      .filter(doc =&gt; \n        doc.get(&quot;key1&quot;).contains(&quot;value1&quot;) &amp;&amp;\n        // This feels very wrong, it should be ||\n        doc.get(&quot;key2&quot;).contains(&quot;value1&quot;) &amp;&amp;\n        doc.get(&quot;key3&quot;).contains(&quot;value1&quot;) &amp;&amp;\n        doc.get(&quot;key4&quot;).contains(&quot;value1&quot;)\n      )\n\n    LuceneTestUtils.testDocuments(testData, &quot;key1:value1 AND key2:value1 OR key3:value1 AND key4:value1&quot;, expectedDocs)\n</code></pre>\n<ol start=\"3\">\n<li></li>\n</ol>\n<pre class=\"lang-scala prettyprint-override\"><code>    val expectedDocs = testData\n      .filter(doc =&gt;\n        // ???\n        // doc.get(&quot;key1&quot;).contains(&quot;value2&quot;) || (\n        doc.get(&quot;key2&quot;).contains(&quot;value2&quot;) &amp;&amp;\n          doc.get(&quot;key3&quot;).contains(&quot;value2&quot;)\n        // ) || doc.get(&quot;key4&quot;).contains(&quot;value2&quot;)\n      )\n\n    LuceneTestUtils.testDocuments(testData, &quot;key1:value2 OR key2:value2 AND key3:value2 OR key4:value2&quot;, expectedDocs)\n</code></pre>\n<p>No operator precedence could explain this.</p>\n<ul>\n<li>AND before OR</li>\n<li>AND equal to OR\n<ul>\n<li>with either left-to-right or right-to-left associativity</li>\n</ul>\n</li>\n<li>AND after OR</li>\n</ul>\n<p>A hint at the problem is the output of that <code>println(q)</code>:</p>\n<p>1.</p>\n<pre class=\"lang-none prettyprint-override\"><code>+(key1:value2 key2:value2) +(key3:value2 key4:value2)\n</code></pre>\n<ol start=\"2\">\n<li></li>\n</ol>\n<pre class=\"lang-none prettyprint-override\"><code>+key1:value1 +key2:value1 +key3:value1 +key4:value1\n</code></pre>\n<ol start=\"3\">\n<li></li>\n</ol>\n<pre class=\"lang-none prettyprint-override\"><code>key1:value2 +key2:value2 +key3:value2 key4:value2\n</code></pre>\n<p>These match the observed behaviour, but don't make sense. Why does Lucene work in that way?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}