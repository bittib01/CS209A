{
  "question": {
    "tags": [
      "java",
      "generics",
      "parameters"
    ],
    "owner": {
      "account_id": 533594,
      "reputation": 3998,
      "user_id": 903998,
      "user_type": "registered",
      "accept_rate": 75,
      "profile_image": "https://i.sstatic.net/pZCd4.jpg?s=256",
      "display_name": "Victor",
      "link": "https://stackoverflow.com/users/903998/victor"
    },
    "is_answered": true,
    "view_count": 55775,
    "accepted_answer_id": 14007261,
    "answer_count": 2,
    "score": 17,
    "last_activity_date": 1764426689,
    "creation_date": 1356216313,
    "last_edit_date": 1764426689,
    "question_id": 14007210,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/14007210/implementing-abstract-generic-method-in-java-with-multiple-generics-types",
    "title": "Implementing Abstract Generic Method in Java with multiple generics types",
    "body": "<p>It is about generics methods in java with two generics types (one for return type and another for a formal parameter) and how to implement it.\nI guess i am missing something in the picture to get it work.</p>\n<p>The matter is this...</p>\n<p>This is <strong>working</strong> :</p>\n<pre><code>public enum Getter\n{\n    BillItemsSize {\n        @Override\n        public Integer get (Object entity) {\n            DesiredClass ref = (DesiredClass ) entity; // &quot;Old time&quot; cast\n            // do things...\n        }\n    };\n\n    public abstract &lt;T,K&gt; T get (K entity);        \n}\n</code></pre>\n<p>This is <strong>not working</strong> :</p>\n<pre><code>public enum Getter\n{\n    BillItemsSize {\n        @Override\n        public Integer get (DesiredClass entity) { // no cast at all\n            // do things\n        }\n    };\n\n    public abstract &lt;T,K&gt; T get (K entity);        \n}\n</code></pre>\n<p>The java compiler yells me this :</p>\n<pre><code>&lt;anonymous datasource.db.Getter$1&gt; is not abstract and does not override abstract method &lt;T,K&gt;get(K) in Getter\n</code></pre>\n<p>Well, that's the situation.</p>\n<p>P.D: It's not a problem of enums types.. it happens across classes hierarchies. So don't bother blaming the enums, I tried this and doesn't work.</p>\n<pre><code>public abstract class SuperClass\n{\n    public abstract &lt;T,E&gt; T pepe (E e);\n}\n\npublic class SubClass extends SuperClass\n{\n\n    @Override\n    public Integer pepe(DesiredClass e) // fails... \n    {\n        return null;\n    }\n    \n}\n</code></pre>\n<h2>UPDATED:</h2>\n<p><strong>For Generics parameters</strong></p>\n<p>We can make a general rule statement that for &quot;generics parameter&quot; (those whose types is generic) the type implicitly taken in the method signature is equals to upper limits of that generic, that can be Object, if nothing is specified, or a more specific subclass if upper bounds are used (in example T extends String).</p>\n<p><strong>For Generics returns types</strong></p>\n<p>There is no problem overwriting a generic method with a specific return type, as long the return type is a subtype of the overwritten return type. And what is the return type at first place? Well, it happens to be Object. By default the compiler assumes (in the method signature) the generic type as an Object type.</p>\n<p>So  we have to thing that the trick is to know that any method that have a generic return type are actually having an <strong>Object</strong> return type.\nThen if in any subclasses the method is overwritten and we alter he return type stating that return another type, there will be no problem. Because, besides that method will return an object of another class, that object returned will inevitable be subclass of the Object class and there will be no problem overwrite a method with a different return type that the original as long it be a subtype of the original. The technique called covariant return type allow us to do such thing.</p>\n<pre><code>public abstract class SuperClass\n{\n    public abstract &lt;T&gt; T operation ();\n}\n\n\npublic class SubClass extends SuperClass\n{\n\n    @Override\n    public Chair operation()\n    {\n        //bla bla \n    }\n    \n}   \n</code></pre>\n<p>meanwhile in another part of the code...</p>\n<pre><code>void main ()\n{\n        SubClass sb = new SubClass();\n        Chair chair = sb.operation ();\n        // the chair type can be easely replaced by super type (like Object)\n        Object object = sb.operation();\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}