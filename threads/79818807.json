{
  "question": {
    "tags": [
      "java",
      "multithreading",
      "exception",
      "executorservice"
    ],
    "owner": {
      "account_id": 44663395,
      "reputation": 51,
      "user_id": 31870929,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/bf3c15f6c1855c02264482fa72dbc45a?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "MaxSan",
      "link": "https://stackoverflow.com/users/31870929/maxsan"
    },
    "is_answered": true,
    "view_count": 110,
    "answer_count": 1,
    "score": 4,
    "last_activity_date": 1763075134,
    "creation_date": 1763034356,
    "question_id": 79818807,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79818807/java-executorservice-detect-asap-thread-fail",
    "title": "Java ExecutorService detect asap thread fail",
    "body": "<p>I have to run x asynchronous threads , which can last several minutes each.<br />\nThey ALL have to terminate properly without exceptions.</p>\n<p>If one fails I have to stop them all immediately and not wait minutes for them to finish a job that will be useless. How can I do it?  This is a piece of my current code:</p>\n<pre><code>ExecutorService executorService = Executors.newFixedThreadPool(iNumThread);\nList&lt;Callable&lt;String&gt;&gt; callableTasks = new ArrayList&lt;&gt;();\nfor (int i = 0; i &lt; iNumThread; i++) {\n    callableTasks.add(new ExecuteJob(...));  \n}\n\nList&lt;Future&lt;String&gt;&gt; resultList = null;\ntry {\n    resultList = executorService.invokeAll(callableTasks);\n} catch (InterruptedException ex) {\n    ex.printStackTrace();\n}\nexecutorService.shutdown();\n\n// This cycle doesn't work for me because it waits for all threads to finish even if one or more have given an exception. \nwhile (!executorService.isTerminated()) {\n    //DO SOMETHING LIKE UPDATE UI, ETC\n}\n//check result\nfor (int i = 0; i &lt; resultList.size(); i++) {\n    Future&lt;String&gt; future = resultList.get(i);\n    try {\n        String result = future.get();\n        if (!result.equals(&quot;OK&quot;)){\n            //ohi ohi\n        }        \n    } catch (InterruptedException | ExecutionException e) {\n        //ohi ohi\n        e.printStackTrace();\n    }\n}\n\n</code></pre>\n<p>What I had thought was to put the for loop inside the while loop but it seems to me that the future.get() method blocks the execution of the thread and I want to keep it faster as possible.</p>\n<p>I hope I've made myself clear. Thank you very much.</p>\n<p>Max</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}