{
  "question": {
    "tags": [
      "java",
      "predicate",
      "java-8",
      "negate"
    ],
    "owner": {
      "account_id": 440158,
      "reputation": 330040,
      "user_id": 829571,
      "user_type": "registered",
      "accept_rate": 94,
      "profile_image": "https://i.sstatic.net/zflGZ.png?s=256",
      "display_name": "assylias",
      "link": "https://stackoverflow.com/users/829571/assylias"
    },
    "is_answered": true,
    "view_count": 272715,
    "protected_date": 1541496113,
    "accepted_answer_id": 51439995,
    "answer_count": 14,
    "score": 505,
    "last_activity_date": 1724896543,
    "creation_date": 1391195048,
    "last_edit_date": 1522752899,
    "question_id": 21488056,
    "content_license": "CC BY-SA 3.0",
    "link": "https://stackoverflow.com/questions/21488056/how-to-negate-a-method-reference-predicate",
    "title": "How to negate a method reference predicate",
    "body": "<p>In Java 8, you can use a method reference to filter a stream, for example:</p>\n\n<pre><code>Stream&lt;String&gt; s = ...;\nlong emptyStrings = s.filter(String::isEmpty).count();\n</code></pre>\n\n<p>Is there a way to create a method reference that is the negation of an existing one, i.e. something like:</p>\n\n<pre><code>long nonEmptyStrings = s.filter(not(String::isEmpty)).count();\n</code></pre>\n\n<p>I could create the <code>not</code> method like below but I was wondering if the JDK offered something similar.</p>\n\n<pre><code>static &lt;T&gt; Predicate&lt;T&gt; not(Predicate&lt;T&gt; p) { return o -&gt; !p.test(o); }\n</code></pre>\n"
  },
  "answers": [
    {
      "owner": {
        "account_id": 544436,
        "reputation": 691,
        "user_id": 913887,
        "user_type": "registered",
        "accept_rate": 83,
        "profile_image": "https://www.gravatar.com/avatar/a6f6c0ae6e1d1f56c860dfa5c6802c06?s=256&d=identicon&r=PG",
        "display_name": "outofBounds",
        "link": "https://stackoverflow.com/users/913887/outofbounds"
      },
      "is_accepted": false,
      "score": 9,
      "last_activity_date": 1724896543,
      "last_edit_date": 1724896543,
      "creation_date": 1476972412,
      "answer_id": 40156795,
      "question_id": 21488056,
      "content_license": "CC BY-SA 4.0",
      "body": "<p>In this case, you could use <code>org.apache.commons.lang3.StringUtils</code> and do</p>\n<pre class=\"lang-java prettyprint-override\"><code>int nonEmptyStrings = s.filter(StringUtils::isNotEmpty).count();\n</code></pre>\n"
    },
    {
      "owner": {
        "account_id": 2243116,
        "reputation": 5563,
        "user_id": 1977151,
        "user_type": "registered",
        "accept_rate": 40,
        "profile_image": "https://www.gravatar.com/avatar/afb5648c274c70edab85608a6e9ffff7?s=256&d=identicon&r=PG",
        "display_name": "Vlasec",
        "link": "https://stackoverflow.com/users/1977151/vlasec"
      },
      "is_accepted": false,
      "score": 100,
      "last_activity_date": 1720809883,
      "last_edit_date": 1720809883,
      "creation_date": 1432816000,
      "answer_id": 30506585,
      "question_id": 21488056,
      "content_license": "CC BY-SA 4.0",
      "body": "<h2>On type inference</h2>\n<p><code>Predicate</code> has <code>default</code> methods <code>and</code>, <code>or</code> and <strong><code>negate</code></strong>.</p>\n<p>However, <code>String::isEmpty</code> is not a <code>Predicate</code>. It could also be <code>Function&lt;String, Boolean&gt;</code>. Without <strong>type inference</strong>, there is no way to know its <strong>functional interface</strong>.</p>\n<p>If Java had <code>filterNot</code> method <em>(hint: it doesn't)</em>, there could be a nice <strong>implicit inference</strong>:</p>\n<pre><code>s.filterNot(String::isEmpty).count()\n</code></pre>\n<p>Negation by instance method (as mentioned by @axtavt) involves <strong>explicit inference</strong>:</p>\n<pre><code>s.filter(((Predicate&lt;String&gt;) String::isEmpty).negate()).count()\n</code></pre>\n<p>It is rather unsightly. From code clarity point of view, implicit inference generally looks much better, even  if it makes compiler's work a little more complicated.</p>\n<p>Moreover, method reference isn't a unique identifier of a method. E.g. <code>String::substring</code> refers to both methods of the same name. Due to <strong>method overloading</strong>, it is unclear which method it refers to. This shows there is a lot of <strong>ambiguity</strong> that needs to be cleared.</p>\n<hr />\n<p>Before we continue, look at these examples and figure out what happens <em>(last two use Java 11)</em>:</p>\n<pre><code>Predicate&lt;String&gt; p1         = /*0*/ s -&gt; s.isEmpty();\nFunction&lt;String, Boolean&gt; f1 = /*1*/ String::isEmpty;\nObject o1                    = /*2*/ String::isEmpty;\nObject o2                    = /*3*/ p1;\nFunction&lt;String, Boolean&gt; f2 = /*4*/ (Function&lt;String, Boolean&gt;) o2;\nFunction&lt;String, Boolean&gt; f3 = /*5*/ p1::test;\nPredicate&lt;Integer&gt; p2        = /*6*/ s -&gt; s.isEmpty();\nPredicate&lt;Integer&gt; p3        = /*7*/ String::isEmpty;\nvar v1                       = /*8*/ Predicate.not(String::isEmpty);\nvar v2                       = /*9*/ Predicate.not(s -&gt; s.isEmpty());\n</code></pre>\n<p>Let's analyze these examples:</p>\n<ol start=\"0\">\n<li><p>The lambda infers all its type information from <code>p1</code> variable in assignment (<code>=</code>). That also infers that it's actually <code>String s</code>, and since <code>String</code> has instance method named <code>isEmpty</code> with no arguments and correct output type, it compiles.</p>\n</li>\n<li><p>The method reference also infers its type information from <code>f1</code> variable in assignment. That also infers the arguments and their types. There is only one matching method in String.</p>\n</li>\n<li><p>The method reference fails to infer a functional <code>interface</code> from <code>o1</code>, <code>Object</code> is a <code>class</code>.</p>\n</li>\n<li><p>Just a simple <em>(if perhaps silly)</em> down-casting  of a <code>Predicate</code> to <code>Object</code> <code>o2</code>.</p>\n</li>\n<li><p>The right operand of assignment is an expression that attempts to cast a <code>Predicate</code> that is stored in variable of <code>Object</code> type, as a <code>Function</code> <code>f2</code>. Exception is thrown at runtime.</p>\n</li>\n<li><p>The method reference refers to an instance method of <code>p1</code>. Functional interface and arguments of said method are inferred from <code>f3</code> variable, and there is a match.</p>\n<p>Effectively, this is a <code>Function&lt;String, Boolean&gt;</code> wrapper to a <code>Predicate&lt;String&gt;</code>.</p>\n</li>\n<li><p>The lambda infers the functional interface and arguments from <code>p3</code>. The compiler looks for an instance method called <code>isEmpty</code> with no arguments in <code>Integer</code>, but there is no such thing.</p>\n</li>\n<li><p>The method reference infers functional interface. It also infers <code>Integer</code> as input argument and <code>Boolean</code> as result type. This rules out instance methods of <code>String</code> (that would require first argument to be of type <code>String</code> rather than <code>Integer</code>). There is no static method <code>String.isEmpty(Integer)</code> either, so a compiler error occurs.</p>\n</li>\n<li><p>By using <code>var</code>, <code>v1</code> is still strongly typed at compile time, but the inference in the assignment (<code>=</code>) goes from right to left this time.</p>\n<p>The right operand calls static method <code>not</code> which has one argument, <code>Predicate&lt;T&gt;</code>. Method reference can infer input arguments count (1) and return type (<code>boolean</code>). One such method exists in <code>String</code> and its input type is <code>String</code>, so method <code>not</code> can infer <code>String</code> for <code>&lt;T&gt;</code>.</p>\n</li>\n<li><p>Similarly, <code>v2</code> is a mere consumer here. However, the lack of type information in the lambda results in compiler error as it's unclear what is the type of <code>s</code>. Perhaps <code>List&lt;BigDecimal&gt;</code>?</p>\n</li>\n</ol>\n<hr />\n<p>Now that it's clear how it works, let's revisit <code>Predicate.not</code>. As others mentioned, it was added in Java 11. If you want a cleaner look, especially if you negate multiple predicates in the same class, you  might as well go for <strong>static import</strong> and have a result like this:</p>\n<pre><code>s.filter(not(String::isEmpty))\n</code></pre>\n<p>The static import however has its own downside: Adding another <code>not</code> method that negates something vaguely similar will result in <strong>ambiguity</strong> that you will need to resolve for your code to compile. The ambiguity is further aggravated by type erasure.</p>\n<p>So, it all comes back to the fan favorite, a lambda negated by <code>!</code> operator. This allows the lambda to infer its type directly from the <code>filter</code> method and it doesn't look too bad.</p>\n<pre><code>s.filter(s -&gt; !s.isEmpty)\n</code></pre>\n<p><em>(unless you've developed in some newer language like Scala, Kotlin ...)</em></p>\n<p>Summed up, functional paradigm in Java could <em>look and feel</em> better, so pick your poison.</p>\n"
    },
    {
      "owner": {
        "account_id": 92486,
        "reputation": 46828,
        "user_id": 253468,
        "user_type": "registered",
        "accept_rate": 79,
        "profile_image": "https://i.sstatic.net/eump2.jpg?s=256",
        "display_name": "TWiStErRob",
        "link": "https://stackoverflow.com/users/253468/twisterrob"
      },
      "is_accepted": false,
      "score": -2,
      "last_activity_date": 1691083485,
      "last_edit_date": 1691083485,
      "creation_date": 1691072268,
      "answer_id": 76828982,
      "question_id": 21488056,
      "content_license": "CC BY-SA 4.0",
      "body": "<p>Since this ranks highest on Google for Kotlin too (&quot;kotlin negate function reference&quot;), I'll post an answer here:</p>\n<pre class=\"lang-kotlin prettyprint-override\"><code>import kotlin.reflect.KFunction1\n\n/**\n * Kotlin version of [java.util.function.Predicate.negate] for functional types.\n *\n * Example:\n * ```\n * val isX: X -&gt; Boolean = ...\n * val isNotX = !isX\n * val isNotX = isX.not()\n * ```\n */\noperator fun &lt;T&gt; ((T) -&gt; Boolean).not(): (T) -&gt; Boolean =\n    { !this(it) }\n\n/**\n * Kotlin version of [java.util.function.Predicate.negate] for method references.\n *\n * Example:\n * ```\n * fun isX(x: X): Boolean = ...\n * val isNotX = !::isX\n * ```\n */\noperator fun &lt;T&gt; KFunction1&lt;T, Boolean&gt;.not(): KFunction1&lt;T, Boolean&gt; =\n    { it: T -&gt; !this(it) }::invoke\n\n/**\n * Kotlin version of [java.util.function.Predicate.or] for functional types.\n */\ninfix fun &lt;T&gt; ((T) -&gt; Boolean).or(other: (T) -&gt; Boolean): (T) -&gt; Boolean =\n    { this(it) || other(it) }\n\n/**\n * Kotlin version of [java.util.function.Predicate.or] for method references.\n */\ninfix fun &lt;T&gt; KFunction1&lt;T, Boolean&gt;.or(other: KFunction1&lt;T, Boolean&gt;): KFunction1&lt;T, Boolean&gt; =\n    { it: T -&gt; this(it) || other(it) }::invoke\n\n/**\n * Kotlin version of [java.util.function.Predicate.and] for functional types.\n */\ninfix fun &lt;T&gt; ((T) -&gt; Boolean).and(other: (T) -&gt; Boolean): (T) -&gt; Boolean =\n    { this(it) &amp;&amp; other(it) }\n\n/**\n * Kotlin version of [java.util.function.Predicate.and] for method references.\n */\ninfix fun &lt;T&gt; KFunction1&lt;T, Boolean&gt;.and(other: KFunction1&lt;T, Boolean&gt;): KFunction1&lt;T, Boolean&gt; =\n    { it: T -&gt; this(it) &amp;&amp; other(it) }::invoke\n</code></pre>\n<p>I'm not aware these being in stdlib, maybe they exist in some library already. Hope this helps someone in the future as the syntax was non-trivial to come up with.</p>\n"
    }
  ],
  "question_comments": [
    {
      "owner": {
        "account_id": 294084,
        "reputation": 1046,
        "user_id": 597767,
        "user_type": "registered",
        "accept_rate": 75,
        "profile_image": "https://www.gravatar.com/avatar/0e3ddbeb8e6e2493815f1d4a2d979c7c?s=256&d=identicon&r=PG",
        "display_name": "Doradus",
        "link": "https://stackoverflow.com/users/597767/doradus"
      },
      "reply_to_user": {
        "account_id": 1410189,
        "reputation": 66,
        "user_id": 1336952,
        "user_type": "registered",
        "profile_image": "https://www.gravatar.com/avatar/738397a295bbe8dbac494d4f31cec1a7?s=256&d=identicon&r=PG",
        "display_name": "Mike Twain",
        "link": "https://stackoverflow.com/users/1336952/mike-twain"
      },
      "edited": false,
      "score": 0,
      "creation_date": 1721680992,
      "post_id": 21488056,
      "comment_id": 138897770,
      "content_license": "CC BY-SA 4.0"
    },
    {
      "owner": {
        "account_id": 1410189,
        "reputation": 66,
        "user_id": 1336952,
        "user_type": "registered",
        "profile_image": "https://www.gravatar.com/avatar/738397a295bbe8dbac494d4f31cec1a7?s=256&d=identicon&r=PG",
        "display_name": "Mike Twain",
        "link": "https://stackoverflow.com/users/1336952/mike-twain"
      },
      "edited": false,
      "score": 5,
      "creation_date": 1546901244,
      "post_id": 21488056,
      "comment_id": 94999284,
      "content_license": "CC BY-SA 4.0"
    },
    {
      "owner": {
        "account_id": 1939636,
        "reputation": 32733,
        "user_id": 1746118,
        "user_type": "registered",
        "accept_rate": 95,
        "profile_image": "https://www.gravatar.com/avatar/dea2252138dd9905af87cd6803fb5665?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name": "Naman",
        "link": "https://stackoverflow.com/users/1746118/naman"
      },
      "edited": false,
      "score": 2,
      "creation_date": 1526916378,
      "post_id": 21488056,
      "comment_id": 87917023,
      "content_license": "CC BY-SA 4.0"
    },
    {
      "owner": {
        "account_id": 1546239,
        "reputation": 3222,
        "user_id": 1439733,
        "user_type": "registered",
        "profile_image": "https://www.gravatar.com/avatar/0bb03e04f38790a0b3623e03a196542d?s=256&d=identicon&r=PG",
        "display_name": "Stefan Zobel",
        "link": "https://stackoverflow.com/users/1439733/stefan-zobel"
      },
      "edited": false,
      "score": 9,
      "creation_date": 1516031369,
      "post_id": 21488056,
      "comment_id": 83515694,
      "content_license": "CC BY-SA 3.0"
    }
  ],
  "answer_comments": {
    "40156795": [],
    "30506585": [],
    "76828982": []
  }
}