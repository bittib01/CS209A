{
  "question": {
    "tags": [
      "java",
      "spring",
      "spring-boot",
      "unit-testing",
      "jwt"
    ],
    "owner": {
      "account_id": 16962007,
      "reputation": 1719,
      "user_id": 12268910,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/bc0891ab6e6436782d5baf9740cb8369?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "java12399900",
      "link": "https://stackoverflow.com/users/12268910/java12399900"
    },
    "is_answered": true,
    "view_count": 110299,
    "accepted_answer_id": 61790559,
    "answer_count": 11,
    "score": 32,
    "last_activity_date": 1765047030,
    "creation_date": 1588159178,
    "last_edit_date": 1662445731,
    "question_id": 61500578,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/61500578/how-to-mock-jwt-authentication-in-a-spring-boot-unit-test",
    "title": "How to mock JWT authentication in a Spring Boot Unit Test?",
    "body": "<p>I have added JWT Authentication using Auth0 to my Spring Boot REST API following <a href=\"https://auth0.com/docs/quickstart/backend/java-spring-security5/02-using#calling-the-api-from-your-application\" rel=\"noreferrer\">this example</a>.</p>\n<p>Now, as expected, my previously working <code>Controller</code> unit tests give a response code of<code>401 Unauthorized</code> rather than <code>200 OK</code> as I am not passing any JWT in the tests.</p>\n<p>How can I mock the <code>JWT/Authentication</code> part of my REST Controller tests?</p>\n<h4>Unit test class</h4>\n<pre class=\"lang-java prettyprint-override\"><code>@AutoConfigureMockMvc\npublic class UserRoundsControllerTest extends AbstractUnitTests {\n\n    private static String STUB_USER_ID = &quot;user3&quot;;\n    private static String STUB_ROUND_ID = &quot;7e3b270222252b2dadd547fb&quot;;\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    private Round round;\n\n    private ObjectId objectId;\n\n    @BeforeEach\n    public void setUp() {\n        initMocks(this);\n        round = Mocks.roundOne();\n        objectId = Mocks.objectId();\n    }\n\n    @Test\n    public void shouldGetAllRoundsByUserId() throws Exception {\n\n        // setup\n        given(userRoundService.getAllRoundsByUserId(STUB_USER_ID)).willReturn(\n                Collections.singletonList(round));\n\n        // mock the rounds/userId request\n        RequestBuilder requestBuilder = Requests.getAllRoundsByUserId(STUB_USER_ID);\n\n        // perform the requests\n        MockHttpServletResponse response = mockMvc.perform(requestBuilder)\n                .andReturn()\n                .getResponse();\n\n        // asserts\n        assertNotNull(response);\n        assertEquals(HttpStatus.OK.value(), response.getStatus());\n    }\n\n    //other tests\n}\n</code></pre>\n<h4>Requests class (used above)</h4>\n<pre class=\"lang-java prettyprint-override\"><code>public class Requests {\n\n    private Requests() {}\n\n    public static RequestBuilder getAllRoundsByUserId(String userId) {\n        return MockMvcRequestBuilders\n                .get(&quot;/users/&quot; + userId + &quot;/rounds/&quot;)\n                .accept(MediaType.APPLICATION_JSON)\n                .contentType(MediaType.APPLICATION_JSON);\n    }\n}\n</code></pre>\n<h4>Spring Security Config</h4>\n<pre class=\"lang-java prettyprint-override\"><code>/**\n * Configures our application with Spring Security to restrict access to our API endpoints.\n */\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Value(&quot;${auth0.audience}&quot;)\n    private String audience;\n\n    @Value(&quot;${spring.security.oauth2.resourceserver.jwt.issuer-uri}&quot;)\n    private String issuer;\n\n    @Override\n    public void configure(HttpSecurity http) throws Exception {\n            /*\n            This is where we configure the security required for our endpoints and setup our app to serve as\n            an OAuth2 Resource Server, using JWT validation.\n            */\n\n        http.cors().and().csrf().disable().sessionManagement().\n                sessionCreationPolicy(SessionCreationPolicy.STATELESS).and().authorizeRequests()\n                .mvcMatchers(HttpMethod.GET, &quot;/users/**&quot;).authenticated()\n                .mvcMatchers(HttpMethod.POST, &quot;/users/**&quot;).authenticated()\n                .mvcMatchers(HttpMethod.DELETE, &quot;/users/**&quot;).authenticated()\n                .mvcMatchers(HttpMethod.PUT, &quot;/users/**&quot;).authenticated()\n                .and()\n                .oauth2ResourceServer().jwt();\n    }\n\n    @Bean\n    JwtDecoder jwtDecoder() {\n            /*\n            By default, Spring Security does not validate the &quot;aud&quot; claim of the token, to ensure that this token is\n            indeed intended for our app. Adding our own validator is easy to do:\n            */\n\n        NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder)\n                JwtDecoders.fromOidcIssuerLocation(issuer);\n\n        OAuth2TokenValidator&lt;Jwt&gt; audienceValidator = new AudienceValidator(audience);\n        OAuth2TokenValidator&lt;Jwt&gt; withIssuer = JwtValidators.createDefaultWithIssuer(issuer);\n        OAuth2TokenValidator&lt;Jwt&gt; withAudience = new DelegatingOAuth2TokenValidator&lt;&gt;(withIssuer,\n                audienceValidator);\n\n        jwtDecoder.setJwtValidator(withAudience);\n\n        return jwtDecoder;\n    }\n\n    @Bean\n    CorsConfigurationSource corsConfigurationSource() {\n        CorsConfiguration configuration = new CorsConfiguration();\n        configuration.setAllowedOrigins(Arrays.asList(&quot;*&quot;));\n        configuration.setAllowedMethods(Arrays.asList(&quot;*&quot;));\n        configuration.setAllowedHeaders(Arrays.asList(&quot;*&quot;));\n        configuration.setAllowCredentials(true);\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(&quot;/**&quot;, configuration);\n        return source;\n    }\n}\n</code></pre>\n<h4>Abstract Unit test class</h4>\n<pre class=\"lang-java prettyprint-override\"><code>@ExtendWith(SpringExtension.class)\n@SpringBootTest(\n        classes = PokerStatApplication.class,\n        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT\n)\npublic abstract class AbstractUnitTests {\n    // mock objects etc\n}\n</code></pre>\n"
  },
  "answers": [
    {
      "owner": {
        "account_id": 2190661,
        "reputation": 3722,
        "user_id": 1937797,
        "user_type": "registered",
        "accept_rate": 65,
        "profile_image": "https://www.gravatar.com/avatar/e97a568c98df3a7e2a72051aa09eb1a1?s=256&d=identicon&r=PG",
        "display_name": "akn",
        "link": "https://stackoverflow.com/users/1937797/akn"
      },
      "is_accepted": false,
      "score": 0,
      "last_activity_date": 1765047030,
      "last_edit_date": 1765047030,
      "creation_date": 1764539403,
      "answer_id": 79834202,
      "question_id": 61500578,
      "content_license": "CC BY-SA 4.0",
      "body": "<p>For integration tests using <code>@SpringBootTest</code>, the <code>JwtDecoder</code> bean can be mocked with <code>@MockitoBean</code>, giving you full control over JWT token validation. I find this to be a clear and explicit way to provide the security context in tests. It’s also useful when specific JWT claims are required to handle a request.</p>\n<pre><code>@SpringBootTest\nclass CommentsControllerTests {\n\n    @MockitoBean\n    private JwtDecoder jwtDecoder;\n\n    @Test\n    void shouldComment() {\n        String mockedJwtTokenValue = &quot;mocked-token&quot;;\n        Jwt jwt = new Jwt(\n                mockedJwtTokenValue,\n                Instant.now(),\n                Instant.now().plusSeconds(30),\n                Map.of(&quot;alg&quot;, &quot;none&quot;),\n                Map.of(&quot;email&quot;, &quot;test@example.com&quot;, &quot;scope&quot;, &quot;user&quot;)\n        );\n\n        when(jwtDecoder.decode(&quot;mocked-token&quot;)).thenReturn(jwt);\n\n\n        given()\n                .contentType(ContentType.JSON)\n                .accept(ContentType.JSON)\n                .header(HttpHeaders.AUTHORIZATION, &quot;Bearer &quot; + mockedJwtTokenValue)\n                .body(new CommentDTO(&quot;test comment&quot;))\n                .when()\n                .post(&quot;/comments&quot;)\n                .then()\n                .statusCode(200);\n    }\n}\n</code></pre>\n"
    },
    {
      "owner": {
        "account_id": 30624752,
        "reputation": 19,
        "user_id": 23476598,
        "user_type": "registered",
        "profile_image": "https://lh3.googleusercontent.com/a/ACg8ocLB0zhf3lKcNfslA_mjEIYb1DNMUMLg-DLlkMTQnK3E=k-s256",
        "display_name": "achraf",
        "link": "https://stackoverflow.com/users/23476598/achraf"
      },
      "is_accepted": false,
      "score": 0,
      "last_activity_date": 1734651635,
      "last_edit_date": 1734651635,
      "creation_date": 1734648278,
      "answer_id": 79295770,
      "question_id": 61500578,
      "content_license": "CC BY-SA 4.0",
      "body": "<p><strong>With Kotlin:</strong></p>\n<p>I made it very very very simple thanks to <code>mapOf()</code> because in my service class I will get for example an email from a token like this :</p>\n<pre><code>val token_email  = token.claims[&quot;email&quot;]\n</code></pre>\n<p>. Look at my example:</p>\n<pre><code>     @Mock\n     lateinit var mockDAO : UserDAO\n\n     @Mock\n      lateinit var jetonDAO : Jwt\n\n     @Test\n     fun testGivenUserByEmail(){\n    \n        //Set up thanks to a list of users\n        val user= users.find { it.email == &quot;admin@troctout.com&quot; }\n\n       //HERE IS THE SOLUTION ---------------------------------\n       val mockClaims = mapOf(\n       &quot;email&quot; to &quot;admin@troctout.com&quot;,\n       &quot;roles&quot; to listOf(&quot;Administrateur&quot;)\n      )\n      //AND ALSO HERE WITH A MOKITO       \n      Mockito.doReturn( mockClaims ).`when`( tokenDAO ).claims\n\n\n      Mockito.doReturn( user).`when`( mockDAO ).getUserByEmail( &quot;admin@troctout.com&quot; )\n      val cobaye = UserService( mockDAO )\n      val expected_result = user\n\n    //Action\n    val obtained_result = cobaye.getUserByEmail( &quot;admin@troctout.com&quot;, tokenDAO)\n\n    \n    //Verification\n    assertEquals( expected_result , obtained_result )\n}\n</code></pre>\n"
    },
    {
      "owner": {
        "account_id": 245509,
        "reputation": 4101,
        "user_id": 519035,
        "user_type": "registered",
        "profile_image": "https://i.sstatic.net/Arc3X.jpg?s=256",
        "display_name": "AbstractVoid",
        "link": "https://stackoverflow.com/users/519035/abstractvoid"
      },
      "is_accepted": false,
      "score": 0,
      "last_activity_date": 1706298829,
      "creation_date": 1706298829,
      "answer_id": 77888701,
      "question_id": 61500578,
      "content_license": "CC BY-SA 4.0",
      "body": "\n<p>For Spring WebFlux application you might also use <code>mockJwt()</code> with WebTestClient, like here (example in Kotlin):</p>\n<pre class=\"lang-kt prettyprint-override\"><code>client.mutateWith(mockJwt()).get().uri(&quot;/endpoint&quot;).exchange()\n</code></pre>\n<p>It lets you also configure authorities and claims, for example:</p>\n<pre class=\"lang-kt prettyprint-override\"><code>.mutateWith(\n    mockJwt()\n        .authorities(SimpleGrantedAuthority(&quot;my-authority&quot;))\n        .jwt {\n            it.claim(&quot;sub&quot;, &quot;my-claim&quot;)\n        }\n)\n</code></pre>\n<p>For me it worked out of the box, without the need of doing additional configuration or including some beans.</p>\n<p>More info can be found in the <a href=\"https://docs.spring.io/spring-security/reference/reactive/test/web/oauth2.html#webflux-testing-jwt\" rel=\"nofollow noreferrer\">Spring docs</a>.</p>\n"
    },
    {
      "owner": {
        "account_id": 308139,
        "reputation": 13864,
        "user_id": 619830,
        "user_type": "registered",
        "accept_rate": 75,
        "profile_image": "https://www.gravatar.com/avatar/f4d00b0a82e9307b1d68b29867fee4e5?s=256&d=identicon&r=PG",
        "display_name": "ch4mp",
        "link": "https://stackoverflow.com/users/619830/ch4mp"
      },
      "is_accepted": false,
      "score": 2,
      "last_activity_date": 1690773297,
      "last_edit_date": 1690773297,
      "creation_date": 1690772675,
      "answer_id": 76800444,
      "question_id": 61500578,
      "content_license": "CC BY-SA 4.0",
      "body": "<p>First, <code>@SpringBootTest</code> is for integration testing. Controllers should be unit tested with <code>@WebMvcTest</code> (in servlets) or <code>@WebFluxTest</code> (in reactive apps), with a <code>@MockBean</code> for each autowired dependency.</p>\n<p>Second, you should neither deactivate security (as done in one of the answers) nor try to build valid JWTs or hack the decoder (as done in the accepted answer). Instead, keep your security config as it is and manually set the test security context with an <code>Authentication</code> instance of your choice (<code>SecurityContextHolder.getContext().setAuthentication(auth);</code>) or use some existing tools to do it for you.</p>\n<p><code>spring-security-test</code> comes with <code>SecurityMockMvcRequestPostProcessors.jwt()</code> and <code>SecurityMockServerConfigurers.mockJwt()</code> since version 5.2 which was released the 30th of september 2019. Usage as follow:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Test\nvoid givenUserAuthenticated_whenGetGreet_thenOk() throws Exception {\n    api.perform(get(&quot;/greet&quot;).with(SecurityMockMvcRequestPostProcessors.jwt()\n                .authorities(new SimpleGrantedAuthority(&quot;NICE&quot;), new SimpleGrantedAuthority(&quot;AUTHOR&quot;))))\n            .andExpect(status().isOk())\n            .andExpect(jsonPath(&quot;$.body&quot;).value(&quot;Hi user! You are granted with: [NICE, AUTHOR].&quot;));\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>@Test\nvoid givenUserHasNiceMutator_whenGetRestricted_thenOk() throws Exception {\n    api.mutateWith(SecurityMockServerConfigurers.mockJwt()\n            .authorities(new SimpleGrantedAuthority(&quot;NICE&quot;), new SimpleGrantedAuthority(&quot;AUTHOR&quot;)))\n        .get().uri(&quot;/restricted&quot;).exchange()\n        .expectStatus().isOk()\n        .expectBody(MessageDto.class).isEqualTo(new MessageDto(&quot;You are so nice!&quot;));\n}\n</code></pre>\n<p>I also wrote test annotations for OAuth2 in <a href=\"https://mvnrepository.com/artifact/com.c4-soft.springaddons/spring-addons-oauth2-test\" rel=\"nofollow noreferrer\"><code>spring-addons-oauth2-test</code></a>. Two might be of most interest in the case of a resource server with JWT decoder:</p>\n<ul>\n<li><code>@WithMockAuthentication</code> to be used in cases where mocking authorities is enough (and optionally username or actual Authentication implementation type). This annotation builds an Authentication mock, pre-configured with what you provide as annotation arguments.</li>\n<li><code>@WithJwt</code> when you want full control on JWT claims and use the actual authentication converter to setup the test security context. This one is a bit more advanced: it uses the JSON file or String passed as argument to build a <code>org.springframework.security.oauth2.jwt.Jwt</code> instance (not an actual base64 encoded JWT string, but what is built after JWT decoding and validation) and then provide it as input to the <code>Converter&lt;Jwt, ? extends AbstractAuthenticationToken&gt;</code> picked from the security configuration. This means that the actual Authentication implementation (<code>JwtAuthenticationToken</code> by default), as well as username, authorities and claims will be the exact same as at runtime for the same JWT payload.</li>\n</ul>\n<p>When using <code>@WithJwt</code>, extract the claims from tokens for a few representative users and dump the content as JSON files in test resources. Using a tool like <a href=\"https://jwt.io\" rel=\"nofollow noreferrer\">https://jwt.io</a> and real tokens it is rather simple. You could also write the JSON yourself, starting with the sample below.</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Test\n@WithMockAuthentication(&quot;NICE&quot;)\nvoid givenMockAuthenticationWithNice_whenGetRestricted_thenOk() throws Exception {\n    api.perform(get(&quot;/restricted&quot;))\n            .andExpect(status().isOk())\n            .andExpect(jsonPath(&quot;$.body&quot;).value(&quot;You are so nice!&quot;));\n}\n\n@Test\n@WithJwt(&quot;tonton-pirate.json&quot;)\nvoid givenJwtWithNice_whenGetRestricted_thenOk() throws Exception {\n    api.perform(get(&quot;/restricted&quot;))\n            .andExpect(status().isOk())\n            .andExpect(jsonPath(&quot;$.body&quot;).value(&quot;You are so nice!&quot;));\n}\n</code></pre>\n<p>With <code>src/test/resources/tonton-pirate.json</code> being a plain JSON file containing the claim-set (user authorities in the private claim as expected by the authentication converter). Sample for Keycloak and realm roles:</p>\n<pre class=\"lang-json prettyprint-override\"><code>{\n  &quot;preferred_username&quot;: &quot;tonton-pirate&quot;,\n  &quot;scope&quot;: &quot;profile email&quot;,\n  &quot;email&quot;: &quot;tonton-pirate@machin.truc&quot;,\n  &quot;email_verified&quot;: true,\n  &quot;realm_access&quot;: {\n    &quot;roles&quot;: [\n      &quot;NICE&quot;,\n      &quot;AUTHOR&quot;\n    ]\n  }\n}\n</code></pre>\n<p>More samples on <a href=\"https://github.com/ch4mpy/spring-addons\" rel=\"nofollow noreferrer\">my Github repo for spring-addons</a>.</p>\n"
    },
    {
      "owner": {
        "account_id": 273476,
        "reputation": 7912,
        "user_id": 565110,
        "user_type": "registered",
        "accept_rate": 40,
        "profile_image": "https://i.sstatic.net/Ufo3L.png?s=256",
        "display_name": "David Riccitelli",
        "link": "https://stackoverflow.com/users/565110/david-riccitelli"
      },
      "is_accepted": false,
      "score": 11,
      "last_activity_date": 1674760710,
      "last_edit_date": 1674760710,
      "creation_date": 1674746854,
      "answer_id": 75248243,
      "question_id": 61500578,
      "content_license": "CC BY-SA 4.0",
      "body": "<p>I am using the <code>JwtAuthenticationToken</code> from the Security Context. The <code>@WithMockUser</code> annotation is creating a Username-based Authentication Token.</p>\n<p>I wrote my own implementation of <code>@WithMockJwt</code>:</p>\n<pre><code>@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\n@WithSecurityContext(factory = WithMockJwtSecurityContextFactory.class)\npublic @interface WithMockJwt {\n\n    long value() default 1L;\n\n    String[] roles() default {};\n\n    String email() default &quot;ex@example.org&quot;;\n\n}\n\n</code></pre>\n<p>And the related factory:</p>\n<pre><code>public class WithMockJwtSecurityContextFactory implements WithSecurityContextFactory&lt;WithMockJwt&gt; {\n    @Override\n    public SecurityContext createSecurityContext(WithMockJwt annotation) {\n        val jwt = Jwt.withTokenValue(&quot;token&quot;)\n                .header(&quot;alg&quot;, &quot;none&quot;)\n                .claim(&quot;sub&quot;, annotation.value())\n                .claim(&quot;user&quot;, Map.of(&quot;email&quot;, annotation.email()))\n                .build();\n\n        val authorities = AuthorityUtils.createAuthorityList(annotation.roles());\n        val token = new JwtAuthenticationToken(jwt, authorities);\n\n        SecurityContext context = SecurityContextHolder.createEmptyContext();\n        context.setAuthentication(token);\n        return context;\n\n    }\n}\n</code></pre>\n<p>And now I can annotate test with:</p>\n<pre><code>    @Test\n    @WithMockJwt\n    void test() {\n\n     ...omissis...\n</code></pre>\n"
    },
    {
      "owner": {
        "account_id": 12015704,
        "reputation": 824,
        "user_id": 8790942,
        "user_type": "registered",
        "profile_image": "https://lh5.googleusercontent.com/-IVq52KPjTlg/AAAAAAAAAAI/AAAAAAAAAg4/GI5eF26bFtY/s256-rj/photo.jpg",
        "display_name": "Danil Kuznetsov",
        "link": "https://stackoverflow.com/users/8790942/danil-kuznetsov"
      },
      "is_accepted": true,
      "score": 30,
      "last_activity_date": 1656170836,
      "last_edit_date": 1656170836,
      "creation_date": 1589437021,
      "answer_id": 61790559,
      "question_id": 61500578,
      "content_license": "CC BY-SA 4.0",
      "body": "<p>If I understand correctly your case there is one of the solutions.</p>\n<p>In most cases, <code>JwtDecoder</code> bean performs token parsing and validation if the token exists in the request headers.</p>\n<p>Example from your configuration:</p>\n<pre class=\"lang-java prettyprint-override\"><code>    @Bean\n    JwtDecoder jwtDecoder() {\n        /*\n        By default, Spring Security does not validate the &quot;aud&quot; claim of the token, to ensure that this token is\n        indeed intended for our app. Adding our own validator is easy to do:\n        */\n\n        NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder)\n            JwtDecoders.fromOidcIssuerLocation(issuer);\n\n        OAuth2TokenValidator&lt;Jwt&gt; audienceValidator = new AudienceValidator(audience);\n        OAuth2TokenValidator&lt;Jwt&gt; withIssuer = JwtValidators.createDefaultWithIssuer(issuer);\n        OAuth2TokenValidator&lt;Jwt&gt; withAudience = new DelegatingOAuth2TokenValidator&lt;&gt;(withIssuer, audienceValidator);\n\n        jwtDecoder.setJwtValidator(withAudience);\n\n        return jwtDecoder;\n    }\n</code></pre>\n<p>So for the tests, you need to add stub of this bean and also for replacing this bean in spring context, you need the test configuration with it.</p>\n<p>It can be some things like this:</p>\n<pre><code>@TestConfiguration\npublic class TestSecurityConfig {\n\n  static final String AUTH0_TOKEN = &quot;token&quot;;\n  static final String SUB = &quot;sub&quot;;\n  static final String AUTH0ID = &quot;sms|12345678&quot;;\n\n  @Bean\n  public JwtDecoder jwtDecoder() {\n    // This anonymous class needs for the possibility of using SpyBean in test methods\n    // Lambda cannot be a spy with spring @SpyBean annotation\n    return new JwtDecoder() {\n      @Override\n      public Jwt decode(String token) {\n        return jwt();\n      }\n    };\n  }\n\n  public Jwt jwt() {\n\n    // This is a place to add general and maybe custom claims which should be available after parsing token in the live system\n    Map&lt;String, Object&gt; claims = Map.of(\n        SUB, USER_AUTH0ID\n    );\n\n    //This is an object that represents contents of jwt token after parsing\n    return new Jwt(\n        AUTH0_TOKEN,\n        Instant.now(),\n        Instant.now().plusSeconds(30),\n        Map.of(&quot;alg&quot;, &quot;none&quot;),\n        claims\n    );\n  }\n\n}\n</code></pre>\n<p>For using this configuration in tests just pick up this test security config:</p>\n<p><code>@SpringBootTest(classes = TestSecurityConfig.class)</code></p>\n<p>Also in the test request should be authorization header with a token like <code>Bearer .. something</code>.</p>\n<p>Here is an example regarding your configuration:</p>\n<pre><code>    public static RequestBuilder getAllRoundsByUserId(String userId) {\n\n        return MockMvcRequestBuilders\n            .get(&quot;/users/&quot; + userId + &quot;/rounds/&quot;)\n            .accept(MediaType.APPLICATION_JSON)\n            .header(HttpHeaders.AUTHORIZATION, &quot;Bearer token&quot;))\n            .contentType(MediaType.APPLICATION_JSON);\n    }\n</code></pre>\n"
    }
  ],
  "question_comments": [
    {
      "owner": {
        "account_id": 308139,
        "reputation": 13864,
        "user_id": 619830,
        "user_type": "registered",
        "accept_rate": 75,
        "profile_image": "https://www.gravatar.com/avatar/f4d00b0a82e9307b1d68b29867fee4e5?s=256&d=identicon&r=PG",
        "display_name": "ch4mp",
        "link": "https://stackoverflow.com/users/619830/ch4mp"
      },
      "edited": false,
      "score": 0,
      "creation_date": 1690839595,
      "post_id": 61500578,
      "comment_id": 135406347,
      "content_license": "CC BY-SA 4.0"
    }
  ],
  "answer_comments": {
    "79834202": [],
    "79295770": [],
    "77888701": [],
    "76800444": [
      {
        "owner": {
          "account_id": 308139,
          "reputation": 13864,
          "user_id": 619830,
          "user_type": "registered",
          "accept_rate": 75,
          "profile_image": "https://www.gravatar.com/avatar/f4d00b0a82e9307b1d68b29867fee4e5?s=256&d=identicon&r=PG",
          "display_name": "ch4mp",
          "link": "https://stackoverflow.com/users/619830/ch4mp"
        },
        "reply_to_user": {
          "account_id": 1664196,
          "reputation": 1634,
          "user_id": 1531945,
          "user_type": "registered",
          "accept_rate": 50,
          "profile_image": "https://www.gravatar.com/avatar/423066350bace86d606e2050f6a871ac?s=256&d=identicon&r=PG",
          "display_name": "Konstantin Pelepelin",
          "link": "https://stackoverflow.com/users/1531945/konstantin-pelepelin"
        },
        "edited": false,
        "score": 0,
        "creation_date": 1717689397,
        "post_id": 76800444,
        "comment_id": 138549300,
        "content_license": "CC BY-SA 4.0"
      },
      {
        "owner": {
          "account_id": 1664196,
          "reputation": 1634,
          "user_id": 1531945,
          "user_type": "registered",
          "accept_rate": 50,
          "profile_image": "https://www.gravatar.com/avatar/423066350bace86d606e2050f6a871ac?s=256&d=identicon&r=PG",
          "display_name": "Konstantin Pelepelin",
          "link": "https://stackoverflow.com/users/1531945/konstantin-pelepelin"
        },
        "edited": false,
        "score": 0,
        "creation_date": 1717686285,
        "post_id": 76800444,
        "comment_id": 138548719,
        "content_license": "CC BY-SA 4.0"
      },
      {
        "owner": {
          "account_id": 308139,
          "reputation": 13864,
          "user_id": 619830,
          "user_type": "registered",
          "accept_rate": 75,
          "profile_image": "https://www.gravatar.com/avatar/f4d00b0a82e9307b1d68b29867fee4e5?s=256&d=identicon&r=PG",
          "display_name": "ch4mp",
          "link": "https://stackoverflow.com/users/619830/ch4mp"
        },
        "reply_to_user": {
          "account_id": 1664196,
          "reputation": 1634,
          "user_id": 1531945,
          "user_type": "registered",
          "accept_rate": 50,
          "profile_image": "https://www.gravatar.com/avatar/423066350bace86d606e2050f6a871ac?s=256&d=identicon&r=PG",
          "display_name": "Konstantin Pelepelin",
          "link": "https://stackoverflow.com/users/1531945/konstantin-pelepelin"
        },
        "edited": false,
        "score": 0,
        "creation_date": 1717532707,
        "post_id": 76800444,
        "comment_id": 138530513,
        "content_license": "CC BY-SA 4.0"
      },
      {
        "owner": {
          "account_id": 1664196,
          "reputation": 1634,
          "user_id": 1531945,
          "user_type": "registered",
          "accept_rate": 50,
          "profile_image": "https://www.gravatar.com/avatar/423066350bace86d606e2050f6a871ac?s=256&d=identicon&r=PG",
          "display_name": "Konstantin Pelepelin",
          "link": "https://stackoverflow.com/users/1531945/konstantin-pelepelin"
        },
        "edited": false,
        "score": 0,
        "creation_date": 1717520090,
        "post_id": 76800444,
        "comment_id": 138529011,
        "content_license": "CC BY-SA 4.0"
      }
    ],
    "75248243": [
      {
        "owner": {
          "account_id": 264385,
          "reputation": 130,
          "user_id": 550633,
          "user_type": "registered",
          "profile_image": "https://www.gravatar.com/avatar/706184f6cc71f8f1c3fde9444a1f202e?s=256&d=identicon&r=PG",
          "display_name": "Erwan Leroux",
          "link": "https://stackoverflow.com/users/550633/erwan-leroux"
        },
        "edited": false,
        "score": 2,
        "creation_date": 1727728434,
        "post_id": 75248243,
        "comment_id": 139367881,
        "content_license": "CC BY-SA 4.0"
      },
      {
        "owner": {
          "account_id": 308139,
          "reputation": 13864,
          "user_id": 619830,
          "user_type": "registered",
          "accept_rate": 75,
          "profile_image": "https://www.gravatar.com/avatar/f4d00b0a82e9307b1d68b29867fee4e5?s=256&d=identicon&r=PG",
          "display_name": "ch4mp",
          "link": "https://stackoverflow.com/users/619830/ch4mp"
        },
        "edited": false,
        "score": 0,
        "creation_date": 1690772953,
        "post_id": 75248243,
        "comment_id": 135394822,
        "content_license": "CC BY-SA 4.0"
      }
    ],
    "61790559": [
      {
        "owner": {
          "account_id": 7531034,
          "reputation": 2918,
          "user_id": 5719229,
          "user_type": "registered",
          "profile_image": "https://www.gravatar.com/avatar/6ce9838b80ca63bca34363ae64e500a1?s=256&d=identicon&r=PG",
          "display_name": "Sercan Noyan Germiyanoğlu",
          "link": "https://stackoverflow.com/users/5719229/sercan-noyan-germiyano%c4%9flu"
        },
        "edited": false,
        "score": 0,
        "creation_date": 1694379120,
        "post_id": 61790559,
        "comment_id": 135879883,
        "content_license": "CC BY-SA 4.0"
      },
      {
        "owner": {
          "account_id": 3012980,
          "reputation": 552,
          "user_id": 9533625,
          "user_type": "registered",
          "profile_image": "https://www.gravatar.com/avatar/26a468e66ba612882fe8bb95f8879a2a?s=256&d=identicon&r=PG&f=y&so-version=2",
          "display_name": "Heuriskos",
          "link": "https://stackoverflow.com/users/9533625/heuriskos"
        },
        "edited": false,
        "score": 1,
        "creation_date": 1679914677,
        "post_id": 61790559,
        "comment_id": 133800443,
        "content_license": "CC BY-SA 4.0"
      },
      {
        "owner": {
          "account_id": 308139,
          "reputation": 13864,
          "user_id": 619830,
          "user_type": "registered",
          "accept_rate": 75,
          "profile_image": "https://www.gravatar.com/avatar/f4d00b0a82e9307b1d68b29867fee4e5?s=256&d=identicon&r=PG",
          "display_name": "ch4mp",
          "link": "https://stackoverflow.com/users/619830/ch4mp"
        },
        "edited": false,
        "score": 1,
        "creation_date": 1655972341,
        "post_id": 61790559,
        "comment_id": 128460078,
        "content_license": "CC BY-SA 4.0"
      },
      {
        "owner": {
          "account_id": 7893525,
          "reputation": 316,
          "user_id": 5962966,
          "user_type": "registered",
          "profile_image": "https://graph.facebook.com/1032302920149918/picture?type=large",
          "display_name": "Milind Singh",
          "link": "https://stackoverflow.com/users/5962966/milind-singh"
        },
        "edited": false,
        "score": 0,
        "creation_date": 1639668373,
        "post_id": 61790559,
        "comment_id": 124412512,
        "content_license": "CC BY-SA 4.0"
      },
      {
        "owner": {
          "account_id": 200488,
          "reputation": 2623,
          "user_id": 446368,
          "user_type": "registered",
          "accept_rate": 49,
          "profile_image": "https://www.gravatar.com/avatar/2e4e0341513bc6ff2f23065a847f73c7?s=256&d=identicon&r=PG",
          "display_name": "Mejmo",
          "link": "https://stackoverflow.com/users/446368/mejmo"
        },
        "edited": false,
        "score": 0,
        "creation_date": 1611779802,
        "post_id": 61790559,
        "comment_id": 116563856,
        "content_license": "CC BY-SA 4.0"
      },
      {
        "owner": {
          "account_id": 1681986,
          "reputation": 4566,
          "user_id": 1546042,
          "user_type": "registered",
          "profile_image": "https://i.sstatic.net/6HW7nXGB.png?s=256",
          "display_name": "BitfulByte",
          "link": "https://stackoverflow.com/users/1546042/bitfulbyte"
        },
        "edited": false,
        "score": 2,
        "creation_date": 1605281975,
        "post_id": 61790559,
        "comment_id": 114610953,
        "content_license": "CC BY-SA 4.0"
      }
    ]
  }
}