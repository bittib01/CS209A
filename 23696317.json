{
  "question": {
    "tags": [
      "java",
      "java-8",
      "java-stream"
    ],
    "owner": {
      "account_id": 309872,
      "reputation": 9527,
      "user_id": 2163864,
      "user_type": "registered",
      "accept_rate": 79,
      "profile_image": "https://www.gravatar.com/avatar/b984d70323c04c111401a27e0c4c3aba?s=256&d=identicon&r=PG",
      "display_name": "siki",
      "link": "https://stackoverflow.com/users/2163864/siki"
    },
    "is_answered": true,
    "view_count": 682364,
    "protected_date": 1607008395,
    "accepted_answer_id": 23696571,
    "answer_count": 9,
    "score": 724,
    "last_activity_date": 1722178350,
    "creation_date": 1400246899,
    "last_edit_date": 1504727097,
    "question_id": 23696317,
    "content_license": "CC BY-SA 3.0",
    "link": "https://stackoverflow.com/questions/23696317/find-first-element-by-predicate",
    "title": "Find first element by predicate",
    "body": "<p>I've just started playing with Java 8 lambdas and I'm trying to implement some of the things that I'm used to in functional languages.</p>\n\n<p>For example, most functional languages have some kind of find function that operates on sequences, or lists that returns the first element, for which the predicate is <code>true</code>. The only way I can see to achieve this in Java 8 is:</p>\n\n<pre><code>lst.stream()\n    .filter(x -&gt; x &gt; 5)\n    .findFirst()\n</code></pre>\n\n<p>However this seems inefficient to me, as the filter will scan the whole list, at least to my understanding (which could be wrong). Is there a better way?  </p>\n"
  },
  "answers": [
    {
      "owner": {
        "account_id": 16917,
        "reputation": 57,
        "user_id": 37358,
        "user_type": "registered",
        "profile_image": "https://www.gravatar.com/avatar/af7528ca9bd833667932c697126e18ad?s=256&d=identicon&r=PG",
        "display_name": "piero B",
        "link": "https://stackoverflow.com/users/37358/piero-b"
      },
      "is_accepted": false,
      "score": 0,
      "last_activity_date": 1722178350,
      "last_edit_date": 1722178350,
      "creation_date": 1722109115,
      "answer_id": 78802308,
      "question_id": 23696317,
      "content_license": "CC BY-SA 4.0",
      "body": "<p>@BeJay is right, it's a bad practice to use null values in that context. NPE should only appear in the context of a code error like any forgotten or failed instantiation, null cannot be use to hold a meaningful value ( data not found ). It's a bit like the benefits of banning the use of magic numbers.</p>\n<pre><code>public static void main(String[] args)\n{\n    List&lt;Integer&gt; List1 = List.of( 3, 14, 15, 9, 26);\n    List&lt;Integer&gt; List2 = List.of( 5, 16, 3, 2, 1);\n    // intend to be use as a stack of &quot;to scan&quot; Lists\n    ArrayList&lt;List&lt;Integer&gt;&gt; parentList = new ArrayList&lt;&gt;( List.of(List1,List2));\n    Optional&lt;Integer&gt; multipleOfFour = Optional.empty();\n    //looping while parentList still contains sub-list(s) and no multiple of 4 was found\n    while ( ! parentList.isEmpty() &amp;&amp; multipleOfFour.isEmpty())\n    {\n        //popping out first element of parentList\n        List&lt;Integer&gt; currentList = parentList.remove(0);\n        multipleOfFour = currentList.stream().filter(num-&gt;num%4 == 0).findFirst();\n    }\n    if ( ! multipleOfFour.isPresent())\n    {\n        //cheating in case no multiple of 4 was found in any of the 2 lists\n        multipleOfFour = Optional.of(Integer.valueOf(4));\n    }\n    // never use get() unless absolutely sure isPresent()\n    // would return true or an exception could be thrown\n    System.out.println(&quot;first multiple of 4 found: &quot; + multipleOfFour.get());\n}\n</code></pre>\n<p>Now if I didn't instantiate multipleOfFour with Optional.empty() when declared, a NPE will occur when attempting to call isEmpty() in the while loop condition, and I'll know for sure the error comes from the code itself.</p>\n<p>On the other hand if multipleOfFour.isPresent() doesn't return true when I expect, I'll know for sure the error comes either from the data provided or from the stream lambda that doesn't operate properly.</p>\n<p>Easier to debug when you know where to look...</p>\n<p>That Opened my eyes, I rewrote the method of recursive search I was working on, using Optional.empty() instead of null. Thank you @BeJay</p>\n"
    }
  ],
  "question_comments": [],
  "answer_comments": {
    "78802308": []
  }
}