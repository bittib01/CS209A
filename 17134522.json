{
  "question": {
    "tags": [
      "c#",
      "java",
      "android",
      "xamarin",
      "dot42"
    ],
    "owner": {
      "account_id": 1594926,
      "reputation": 5842,
      "user_id": 1477347,
      "user_type": "registered",
      "accept_rate": 69,
      "profile_image": "https://www.gravatar.com/avatar/77dff9da199c3c15a84cb3e9d367d2bf?s=256&d=identicon&r=PG",
      "display_name": "gregko",
      "link": "https://stackoverflow.com/users/1477347/gregko"
    },
    "is_answered": true,
    "view_count": 57300,
    "closed_date": 1516573301,
    "answer_count": 6,
    "community_owned_date": 1373642932,
    "score": 572,
    "last_activity_date": 1723474935,
    "creation_date": 1371394356,
    "last_edit_date": 1644299256,
    "question_id": 17134522,
    "link": "https://stackoverflow.com/questions/17134522/how-to-compare-the-performance-of-android-apps-written-in-java-and-xamarin-c-a",
    "closed_reason": "Not suitable for this site",
    "title": "How to compare the performance of Android Apps written in Java and Xamarin C#? Anyway to check quantitative data (code &amp; results)",
    "body": "<p>I came across Xamarin claims that their Mono implementation on Android and their C# compiled apps are faster than Java code. Did anyone perform actual benchmarks on very similar Java and C# code on different Android platforms to verify such claims, could post the code and results?</p>\n\n<h3>Added June 18, 2013</h3>\n\n<p>Since there was no answer and could not find such benchmarks done by others, decided to do my own tests. Unfortunately, my question remains \"locked\" so I cannot post this as the answer, only edit the question. Please vote to re-open this question. For C#, I used Xamarin.Android Ver. 4.7.09001 (beta). The source code, all the data I used for testing and compiled APK packages are on GitHub:</p>\n\n<p>Java: <a href=\"https://github.com/gregko/TtsSetup_Java\" rel=\"noreferrer\">https://github.com/gregko/TtsSetup_Java</a></p>\n\n<p>C#: <a href=\"https://github.com/gregko/TtsSetup_C_sharp\" rel=\"noreferrer\">https://github.com/gregko/TtsSetup_C_sharp</a></p>\n\n<p>If someone would like to repeat my tests on other devices or emulators, I'd be interested to learn the results as well.</p>\n\n<h1>Results from my testing</h1>\n\n<p>I ported my sentence extractor class to C# (from my @Voice Aloud Reader app) and run some tests on 10 HTML files in English, Russian, French, Polish and Czech languages. Each run was performed 5 times on all 10 files, and the total time for 3 different devices and one emulator are posted below. I tested \"Release\" builds only, without debugging enabled.</p>\n\n<h3>HTC Nexus One Android 2.3.7 (API 10) - CyanogenMod ROM</h3>\n\n<p>Java: Grand total time (5 runs): 12361 ms, with file reading total: 13304 ms</p>\n\n<p>C#: Grand total time (5 runs): 17504 ms, with file reading total: 17956 ms</p>\n\n<h3>Samsung Galaxy S2 SGH-I777 (Android 4.0.4, API 15) - CyanogenMod ROM</h3>\n\n<p>Java: Grand total time (5 runs): 8947 ms, with file reading total: 9186 ms</p>\n\n<p>C#: Grand total time (5 runs): 9884 ms, with file reading total: 10247 ms</p>\n\n<h3>Samsung GT-N7100 (Android 4.1.1 JellyBean, API 16) - Samsung ROM</h3>\n\n<p>Java: Grand total time (5 runs): 9742 ms, with file reading total: 10111 ms</p>\n\n<p>C#: Grand total time (5 runs): 10459 ms, with file reading total: 10696 ms</p>\n\n<h3>Emulator - Intel (Android 4.2, API 17)</h3>\n\n<p>Java: Grand total time (5 runs): 2699 ms, with file reading total: 3127 ms</p>\n\n<p>C#: Grand total time (5 runs): 2049 ms, with file reading total: 2182 ms</p>\n\n<h3>Emulator - Intel (Android 2.3.7, API 10)</h3>\n\n<p>Java: Grand total time (5 runs): 2992 ms, with file reading total: 3591 ms</p>\n\n<p>C#: Grand total time (5 runs): 2049 ms, with file reading total: 2257 ms</p>\n\n<h3>Emulator - Arm (Android 4.0.4, API 15)</h3>\n\n<p>Java: Grand total time (5 runs): 41751 ms, with file reading total: 43866 ms</p>\n\n<p>C#: Grand total time (5 runs): 44136 ms, with file reading total: 45109 ms</p>\n\n<h1>Brief discussion</h1>\n\n<p>My test code contains mainly text parsing, replacing and Regex searches, perhaps for other code (e.g. more numeric operations) the results would be different. On all devices with ARM processors, Java performed better than Xamarin C# code. The largest difference was under Android 2.3, where C# code run at approx. 70% of Java speed.</p>\n\n<p>On Intel emulator (with Intel HAX technology, emulator runs in fast virt mode), Xamarin C# code runs my sample code much faster than Java - about 1.35 time faster. Maybe Mono virtual machine code and libraries are much better optimized on Intel than on ARM?</p>\n\n<h1>Edit July 8, 2013</h1>\n\n<p>I just installed Genymotion Android emulator, which runs in Oracle VirtualBox, and again this one uses native Intel processor, not emulating ARM processor. As with Intel HAX emulator, again C# runs here much faster. Here are my results:</p>\n\n<h3>Genymotion emulator - Intel (Android 4.1.1, API 16)</h3>\n\n<blockquote>\n  <p>Java:\n  Grand total time (5 runs): 2069 ms, with file reading total: 2248 ms</p>\n  \n  <p>C#:\n  Grand total time (5 runs): 1543 ms, with file reading total: 1642 ms</p>\n</blockquote>\n\n<p>I then noticed that there was an update to Xamarin.Android beta, version 4.7.11, with release notes mentioning some changes in Mono runtime as well. Decided to quickly test some ARM devices, and big surprise - C# numbers improved:</p>\n\n<h3>BN Nook XD+, ARM (Android 4.0)</h3>\n\n<blockquote>\n  <p>Java: Grand total time (5 runs): 8103 ms, with file reading total: 8569 ms</p>\n  \n  <p>C#: Grand total time (5 runs): 7951 ms, with file reading total: 8161 ms</p>\n</blockquote>\n\n<p>Wow! C# is now better than Java? Decided to repeat the test on my Galaxy Note 2:</p>\n\n<h3>Samsung Galaxy Note 2 - ARM (Android 4.1.1)</h3>\n\n<blockquote>\n  <p>Java: Grand total time (5 runs): 9675 ms, with file reading total: 10028 ms</p>\n  \n  <p>C#: Grand total time (5 runs): 9911 ms, with file reading total: 10104 ms</p>\n</blockquote>\n\n<p>Here C# seems to be only slightly slower, but these numbers gave me a pause: Why the time is longer than on Nook HD+, even though Note 2 has a faster processor? The answer: power saving mode. On Nook, it was disabled, on Note 2 - enabled. Decided to test with power saving mode disabled (as with enabled, it also limits the processor speed):</p>\n\n<h3>Samsung Galaxy Note 2 - ARM (Android 4.1.1), power saving disabled</h3>\n\n<blockquote>\n  <p>Java: Grand total time (5 runs): 7153 ms, with file reading total: 7459 ms</p>\n  \n  <p>C#: Grand total time (5 runs): 6906 ms, with file reading total: 7070 ms</p>\n</blockquote>\n\n<p>Now, surprisingly, C# is slightly faster than Java on ARM processor as well. Big improvement!</p>\n\n<h1>Edit July 12, 2013</h1>\n\n<p>We all know, that nothing beats native code for speed, and I was not satisfied with the performance of my sentence splitter in Java or C#, particularly that I need to improve it (and thus make it even slower). Decided to re-write it in C++. Here is a small (i.e. a smaller set of files than previous tests, for other reasons) comparison of the speed of native vs. Java on my Galaxy Note 2, with power saving mode disabled:</p>\n\n<p>Java:\nGrand total time (5 runs): 3292 ms, with file reading total: 3454 ms</p>\n\n<p>Native thumb:\nGrand total time (5 runs): 537 ms, with file reading total: 657 ms</p>\n\n<p>Native arm:\nGrand total time (5 runs): 458 ms, with file reading total: 587 ms</p>\n\n<p>Looks like for my particular test, the native code is 6 to 7 times faster than Java. Caveat: could not use std::regex class on Android, so had to write my own specialized routines searching for paragraphs breaks or html tags. My initial tests of the same code on a PC using regex, were about 4 to 5 times faster than Java.</p>\n\n<p>Phew! Waking raw memory with char* or wchar* pointers again, I instantly felt 20 years younger! :)</p>\n\n<h1>Edit July 15, 2013</h1>\n\n<p><strong><em>(Please see below, with edits of 7/30/2013, for much better results with Dot42)</em></strong></p>\n\n<p>With some difficulty, I managed to port my C# tests to Dot42 (version 1.0.1.71 beta), another C# platform for Android. Preliminary results show that Dot42 code is about 3x (3 times) slower than Xamarin C# (v. 4.7.11), on an Intel Android emulator. One problem is that System.Text.RegularExpressions class in Dot42 does not have the Split() function that I used in Xamarin tests, so I used Java.Util.Regex class instead, and Java.Util.Regex.Pattern.Split(), so in this particular place in the code, there is this small difference. Should not be a big problem though. Dot42 compiles to Dalvik (DEX) code, so it cooperates with Java on Android natively, does not need expensive interop from C# to Java like Xamarin.</p>\n\n<p>Just for comparison, I also run the test on ARM devices - here the Dot42 code is \"only\" 2x slower than Xamarin C#. Here are my results:</p>\n\n<h3>HTC Nexus One Android 2.3.7 (ARM)</h3>\n\n<blockquote>\n  <p>Java: Grand total time (5 runs): 12187 ms, with file reading total: 13200 ms</p>\n  \n  <p>Xamarin C#: Grand total time (5 runs): 13935 ms, with file reading total: 14465 ms</p>\n  \n  <p>Dot42 C#: Grand total time (5 runs): 26000 ms, with file reading total: 27168 ms</p>\n</blockquote>\n\n<h3>Samsung Galaxy Note 2, Android 4.1.1 (ARM)</h3>\n\n<blockquote>\n  <p>Java: Grand total time (5 runs): 6895 ms, with file reading total: 7275 ms</p>\n  \n  <p>Xamarin C#: Grand total time (5 runs): 6466 ms, with file reading total: 6720 ms</p>\n  \n  <p>Dot42 C#: Grand total time (5 runs): 11185 ms, with file reading total: 11843 ms</p>\n</blockquote>\n\n<h3>Intel emulator, Android 4.2 (x86)</h3>\n\n<blockquote>\n  <p>Java: Grand total time (5 runs): 2389 ms, with file reading total: 2770 ms</p>\n  \n  <p>Xamarin C#: Grand total time (5 runs): 1748 ms, with file reading total: 1933 ms</p>\n  \n  <p>Dot42 C#: Grand total time (5 runs): 5150 ms, with file reading total: 5459 ms</p>\n</blockquote>\n\n<p>To me, it was also interesting to note that Xamarin C# is slightly faster than Java on a newer ARM device and slightly slower on the old Nexus One. If anyone would like to run these tests as well, please let me know and I'll update the sources on GitHub. It would be particularly interesting to see results from a real Android device with Intel processor.</p>\n\n<h2>Update 7/26/2013</h2>\n\n<p>Just a quick update, re-compiled by benchmark apps with the latest Xamarin.Android 4.8, and also with dot42 1.0.1.72 update released today - no significant changes from the results reported before.</p>\n\n<h2>Update 7/30/2013 - better results for dot42</h2>\n\n<p>Re-tested Dot42 with Robert's (from dot42 makers) port of my Java code to C#. In my C# port done initially for Xamarin, I replaced some native Java classes, like ListArray, with List class native to C#, etc. Robert did not have my Dot42 source code, so he ported it again from Java and used original Java classes in such places, which benefits Dot42, I guess because it runs in Dalvik VM, like Java, and not in Mono, like Xamarin. Now Dot42 results are much better. Here is a log from my testing:</p>\n\n<blockquote>\n  <h2>7/30/2013 - Dot42 tests with more Java classes in Dot42 C#</h2>\n  \n  <h2>Intel emulator, Android 4.2</h2>\n  \n  <p>Dot42, Greg's Code using StringBuilder.Replace() (as in Xamarin):<br>\n  Grand total time (5 runs): 3646 ms, with file reading total: 3830 ms </p>\n  \n  <p>Dot42, Greg's Code using String.Replace() (as in Java and Robert's code):<br>\n  Grand total time (5 runs): 3027 ms, with file reading total: 3206 ms</p>\n  \n  <p>Dot42, Robert's Code:<br>\n  Grand total time (5 runs): 1781 ms, with file reading total: 1999 ms</p>\n  \n  <p>Xamarin:<br>\n  Grand total time (5 runs): 1373 ms, with file reading total: 1505 ms</p>\n  \n  <p>Java:<br>\n  Grand total time (5 runs): 1841 ms, with file reading total: 2044 ms</p>\n  \n  <h2>ARM, Samsung Galaxy Note 2, power saving off, Android 4.1.1</h2>\n  \n  <p>Dot42, Greg's Code using StringBuilder.Replace() (as in Xamarin):<br>\n  Grand total time (5 runs): 10875 ms, with file reading total: 11280 ms</p>\n  \n  <p>Dot42, Greg's Code using String.Replace() (as in Java and Robert's code):<br>\n  Grand total time (5 runs): 9710 ms, with file reading total: 10097 ms</p>\n  \n  <p>Dot42, Robert's Code:<br>\n  Grand total time (5 runs): 6279 ms, with file reading total: 6622 ms</p>\n  \n  <p>Xamarin:<br>\n  Grand total time (5 runs): 6201 ms, with file reading total: 6476 ms</p>\n  \n  <p>Java:<br>\n  Grand total time (5 runs): 7141 ms, with file reading total: 7479 ms</p>\n</blockquote>\n\n<p>I still think that Dot42 has a long way to go. Having Java-like classes (e.g. ArrayList) and a good performance with them would make porting code from Java to C# slightly easier. However, this is something I would not be likely to do a lot. I would rather want to use existing C# code (libraries etc.), which will use native C# classes (e.g. List), and that would perform slowly with the current dot42 code, and very well with Xamarin.</p>\n\n<p>Greg</p>\n"
  },
  "answers": [
    {
      "owner": {
        "account_id": 1048126,
        "reputation": 8821,
        "user_id": 1052697,
        "user_type": "registered",
        "accept_rate": 84,
        "profile_image": "https://i.sstatic.net/w37j0.png?s=256",
        "display_name": "Rolf ツ",
        "link": "https://stackoverflow.com/users/1052697/rolf-%e3%83%84"
      },
      "is_accepted": false,
      "community_owned_date": 1509103094,
      "score": 8,
      "last_activity_date": 1723474935,
      "last_edit_date": 1723474935,
      "creation_date": 1509103094,
      "answer_id": 46973819,
      "question_id": 17134522,
      "content_license": "CC BY-SA 4.0",
      "body": "<h2>Performance</h2>\n<p>Performance is a vague word if you don't define what you mean by performance, if it's plain computation performance Xamarin can be faster than Java depending on the nature of the computation.</p>\n<p>Android natively comes with multiple forms to execute code in:</p>\n<ul>\n<li>RenderScript (CPU and GPU)</li>\n<li>Java (SDK)</li>\n<li>C++ (NDK)</li>\n<li>OpenGL (GPU)</li>\n</ul>\n<p>It is quite obvious that when executing code, the more native the solution the faster it will be. A run-time-based language will never beat a language that directly runs on the CPU.</p>\n<p>But on the other hand, if you want to measure real-life usage performance Java is probably going to be faster than Xamarin.</p>\n<h2>Xamarin and why it can be slower</h2>\n<p>When comparing Xamarin with plain old Java applications, performance can very well be faster for Xamarin as it can be slower.</p>\n<p>In a real-world example Xamarin applications are very likely to be slower than Java applications because many Android/Java (system) calls need to be delegated to and from the Xamarin run-time using so called bindings.</p>\n<p>There are a few different types of bindings that are important to know:</p>\n<ul>\n<li><strong>JNI (Java Native Interface):</strong> The binding used in many android applications to interface between Java code (SDK) and native C++ code (NDK).</li>\n<li><strong>MCW (Managed Callable Wrappers):</strong> A binding that is available in Xamarin to interface from managed C# code to Java code (Android run-time).</li>\n<li><strong>ACW (Android Callable Wrappers):</strong> A binding that is available in Xamarin to interface from Java code (Android run-time) to managed C# code.</li>\n</ul>\n<blockquote>\n<p>More on MCW and ACW here: <a href=\"https://developer.xamarin.com/guides/cross-platform/application_fundamentals/building_cross_platform_applications/part_1_-_understanding_the_xamarin_mobile_platform/\" rel=\"nofollow noreferrer\">https://developer.xamarin.com/guides/cross-platform/application_fundamentals/building_cross_platform_applications/part_1_-_understanding_the_xamarin_mobile_platform/</a></p>\n</blockquote>\n<p>Bindings are in terms of performance very costly. Invoking a C++ method from Java adds a huge overhead in calling time, calling a C++ method from within C++ is many times faster.</p>\n<blockquote>\n<p>Someone did a performance test to calculate how many Java operations on average a JNI call costs: <a href=\"https://stackoverflow.com/questions/13973035/what-is-the-quantitative-overhead-of-making-a-jni-call\">What is the quantitative overhead of making a JNI call?</a></p>\n</blockquote>\n<p>But not only JNI calls are costly so are calls to and from MCW and ACW. Real world Xamarin applications make many calls using bindings and because of this real-world usage of Xamarin, application can be (and will be in general) slower than a plain old Java application. However, depending on how the Xamarin application was designed it is very likely that the user won't even notice the difference.</p>\n<p><strong>TLDR/Conclusion:</strong> Xamarin needs to use all sorts of bindings, which are time costly.</p>\n<blockquote>\n<p>Besides bindings, there are many other factors involved when talking about real-world performance, for example: size of the binary, loading the app in memory, I/O operations and many more. A blog post that investigates some of these things can be found here: <a href=\"https://magenic.com/thinking/mobile-development-platform-performance-part-2-native-cordova-classic-xamarin-xamarin-forms\" rel=\"nofollow noreferrer\">https://magenic.com/thinking/mobile-development-platform-performance-part-2-native-cordova-classic-xamarin-xamarin-forms</a></p>\n</blockquote>\n"
    },
    {
      "owner": {
        "account_id": 11754096,
        "reputation": 86,
        "user_id": 8602318,
        "user_type": "registered",
        "profile_image": "https://i.sstatic.net/cmfwD.jpg?s=256",
        "display_name": "Burgito",
        "link": "https://stackoverflow.com/users/8602318/burgito"
      },
      "is_accepted": false,
      "community_owned_date": 1509616194,
      "score": 12,
      "last_activity_date": 1723474438,
      "last_edit_date": 1723474438,
      "creation_date": 1509616194,
      "answer_id": 47072187,
      "question_id": 17134522,
      "content_license": "CC BY-SA 4.0",
      "body": "<p>Here is a few information I found in another test between native, Xamarin and Xamarin.Forms solutions (the tests also include iOS performances) on the two following devices:</p>\n<p><strong>Samsung Galaxy A7</strong>:\nAndroid OS version: 6.0\nCentral-processing unit: Octa-core 1.9 GHz Cortex-A53\nRAM: 3GB\nDisplay resolution: 1920×1080</p>\n<p><strong>iPhone 6s</strong>:\niOS version: 10.3.3\nCentral-processing unit: Dual-core 1.84 GHz Twister\nRAM: 2 GB\nDisplay resolution: 1334×750</p>\n<p>Comparison is made on a few common features, each one with its own application:</p>\n<pre><code>- Basic “Hello World”\n- REST API\n- JSON Serialization/Deserialization\n- Photo Loading\n- SQL Database Insert and Get All\n</code></pre>\n<p>Each test is repeated several times, the graphs show the average results.</p>\n<hr />\n<p><strong>Hello World</strong></p>\n<p><a href=\"https://i.sstatic.net/wPjsA.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/wPjsA.png\" alt=\"Basic Hello World performance comparison\" /></a></p>\n<hr />\n<p><strong>Rest API</strong></p>\n<p>Set of tests aimed at measuring the time it takes for the app to send a request through REST API and receive the response back without further data processing, using OpenWeatherMap API.</p>\n<p><a href=\"https://i.sstatic.net/Q84Vu.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/Q84Vu.png\" alt=\"Rest API performance comparison\" /></a></p>\n<hr />\n<p><strong>JSON Operations</strong>\nTests made using Newtonsoft Json.net framework to serialize and deserialize JSON objects in all Xamarin apps.\nNative Android serialization and deserialization tested using two Java libraries: Jackson and GSON.</p>\n<p>Two runs are made, one first from scratch and a second one with cached info and operations</p>\n<p>First run:</p>\n<p><a href=\"https://i.sstatic.net/IQbfe.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/IQbfe.png\" alt=\"JSON serialization first run\" /></a></p>\n<p><a href=\"https://i.sstatic.net/xjg0k.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/xjg0k.png\" alt=\"JSON deserialization first run\" /></a></p>\n<p>(Native iOS JSON Operations is killing this test btw, and Xamarin joins it in the second)</p>\n<p><a href=\"https://i.sstatic.net/91KWy.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/91KWy.png\" alt=\"JSON Serialization second run\" /></a></p>\n<p><a href=\"https://i.sstatic.net/6mw1u.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/6mw1u.png\" alt=\"JSON Deserialization second run\" /></a></p>\n<hr />\n<p><strong>Photo Operations</strong></p>\n<p>First load on images with three different resolutions:</p>\n<pre><code>Resolution – 858×569, Size – 868Kb\nResolution – 2575×1709, Size – 8Mb\nResolution – 4291×2848, Size – 28.9Mb\n</code></pre>\n<p><a href=\"https://i.sstatic.net/sbQiK.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/sbQiK.png\" alt=\"Image First Load Android\" /></a></p>\n<p><a href=\"https://i.sstatic.net/oB8jO.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/oB8jO.png\" alt=\"Image First Load iOS\" /></a></p>\n<p>Something seemed unsure about the Xamarin.Forms results for this test, so it is not included in the graph.</p>\n<hr />\n<p><strong>SQLite Operations</strong></p>\n<p>Two operations tested:</p>\n<pre><code>BulkInsert: Loading rows of data into a database table.\nGetAll: Retrieving all data from the database.\n</code></pre>\n<p>With databases having 10,000 records. All operations were processed internally on devices.</p>\n<p><a href=\"https://i.sstatic.net/yy3NR.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/yy3NR.png\" alt=\"SQLite Android performances\" /></a></p>\n<p><a href=\"https://i.sstatic.net/aAIFu.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/aAIFu.png\" alt=\"SQLite iOS performances\" /></a></p>\n<hr />\n<p>Xamarin Native (Xamarin.iOS/Xamarin.Android) show themselves as rather good alternatives to the native code, whereas Xamarin.Forms seems slow in a lot of cases, but it can be a really good solution to develop really simple applications fastly.</p>\n<p>Complete test comes from this source:</p>\n<p><a href=\"https://www.altexsoft.com/blog/engineering/performance-comparison-xamarin-forms-xamarin-ios-xamarin-android-vs-android-and-ios-native-applications/\" rel=\"nofollow noreferrer\">https://www.altexsoft.com/blog/engineering/performance-comparison-xamarin-forms-xamarin-ios-xamarin-android-vs-android-and-ios-native-applications/</a></p>\n<p>Thank you for giving me the explanations to enhance my answer, hope this helps a little :)</p>\n"
    }
  ],
  "question_comments": [],
  "answer_comments": {
    "46973819": [],
    "47072187": []
  }
}