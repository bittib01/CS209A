{
  "question": {
    "tags": [
      "java",
      "oop"
    ],
    "owner": {
      "account_id": 1526270,
      "reputation": 1935,
      "user_id": 1424638,
      "user_type": "registered",
      "accept_rate": 68,
      "profile_image": "https://www.gravatar.com/avatar/e4d060e6edad13e51c3494b6c337c39d?s=256&d=identicon&r=PG",
      "display_name": "joshft91",
      "link": "https://stackoverflow.com/users/1424638/joshft91"
    },
    "is_answered": true,
    "view_count": 13409,
    "answer_count": 6,
    "score": 4,
    "last_activity_date": 1765092339,
    "creation_date": 1357792582,
    "question_id": 14250897,
    "content_license": "CC BY-SA 3.0",
    "link": "https://stackoverflow.com/questions/14250897/read-only-classes-methods",
    "title": "Read only classes/methods",
    "body": "<p>In preparing for an interview, someone mentioned knowing how to make a class/method in java read-only.  I've been doing a bit of searching, but haven't found anything really concrete.</p>\n\n<p>Maybe this question is simpler to answer than I'm making it out to be, but what would be a way to make a class or method read-only in java?</p>\n"
  },
  "answers": [
    {
      "owner": {
        "account_id": 322981,
        "reputation": 346871,
        "user_id": 642706,
        "user_type": "registered",
        "accept_rate": 58,
        "profile_image": "https://i.sstatic.net/ZWEI3.jpg?s=256",
        "display_name": "Basil Bourque",
        "link": "https://stackoverflow.com/users/642706/basil-bourque"
      },
      "is_accepted": false,
      "score": 0,
      "last_activity_date": 1765092339,
      "last_edit_date": 1765092339,
      "creation_date": 1765082647,
      "answer_id": 79840077,
      "question_id": 14250897,
      "content_license": "CC BY-SA 4.0",
      "body": "<h2><code>final</code> var</h2>\n<p>If you mark a primitive variable as <code>final</code>, its content cannot be changed.</p>\n<pre><code>final int x = 7 ;\nx = 42 ;  // Error. Final primitive cannot be assigned another value. \n</code></pre>\n<p>If you mark a reference (object) variable as <code>final</code>, its reference cannot be assigned to another object.</p>\n<pre><code>final Person x = new Person( &quot;Alice&quot; ) ;\nx = new Person( &quot;Bob&quot; ) ;  // Error. Final reference cannot be reassigned to another object. \n</code></pre>\n<h2><code>final</code> fields</h2>\n<p>A field on a class is just a variable, a member variable.  So the same rules above apply, with one difference: The value or reference can be assigned within a constructor rather than on declaration.</p>\n<p>Here is an example of both: assignment on declaration, and assignment within constructor.</p>\n<pre class=\"lang-java prettyprint-override\"><code>class Event \n{\n    final String title ;\n    final LocalDate date ;\n    final Instant created = Instant.now() ;  // Reference assigned only once, on declaration. \n\n    // Constructor\n    Event( final String theTitle, final LocalDate theDate )\n    {\n        this.title = theTitle ;  // Reference assigned only once, in constructor.\n        this.date = theDate ;    // Reference assigned only once, in constructor.\n    }\n}\n</code></pre>\n<h2>Immutable object</h2>\n<p>If the state of a class cannot be modified, such as all the fields of a class being <code>final</code>, then we refer to instances of that class as being <a href=\"https://en.m.wikipedia.org/wiki/Immutable_object\" rel=\"nofollow noreferrer\">immutable objects</a>.</p>\n<h2><code>final</code> parameters</h2>\n<p>Notice also how parameters in code above can be marked <code>final</code>. Doing so prevents assigning a different value/reference than was passed in to a call on this method. Marking parameters <code>final</code> is nearly always a smart move.</p>\n<h2>Getters</h2>\n<p>Some programmers chose to provide access to fields indirectly, via accessor “getter” methods. Fields are set to <code>private</code> to block direct access.</p>\n<p>If such a class has only getters but no setters, and there is no other means of altering state, then this class would be considered immutable.</p>\n<pre><code>public class Point \n{\n    private int x, y ;\n\n    Point( final int theX , final int theY)\n    {\n        this.x = theX ;\n        this.y = theY ;\n    }\n\n    public int getX() { return this.x ; }\n    public int gets() { return this.y ; }\n}\n</code></pre>\n<p>While this simplistic example shows no benefits to this approach, you might choose this approach for more complicated reasons. The getter methods may be expanded to perform a security check for authorization, or to perform access logging, and so on.</p>\n<h2><code>record</code></h2>\n<p>If the main purpose to your class is to transparently communicate shallowly-immutable data, define your class as a <a href=\"https://openjdk.org/jeps/395\" rel=\"nofollow noreferrer\">record</a>.</p>\n<pre><code>record Employee ( String name , UUID id ) {}\n</code></pre>\n<p>Every field of a record is <code>final</code>, by definition. With regard to <code>final</code> fields, the record above is equivalent to this conventional class.</p>\n<pre class=\"lang-java prettyprint-override\"><code>class Employee\n{\n    final String name ;\n    final UUID id ;\n    \n    // Constructor\n    Event( final String theName , final UUID theId )\n    {\n        this.name = theName ;  // Reference assigned only once, in constructor.\n        this.id = theId ;      // Reference assigned only once, in constructor.\n    }\n\n}\n</code></pre>\n<h2>Caveat: <code>final</code> not always final</h2>\n<p>There are back-door pathways to changing what should be unchangeable in Java. By way of the Reflection facility in Java, <code>final</code> variables can be re-assigned.</p>\n<p>Work is underway in Java 26 to close this back-door manipulation. See <a href=\"https://openjdk.org/jeps/500\" rel=\"nofollow noreferrer\"><em>JEP 500: Prepare to Make Final Mean Final</em></a>.</p>\n<h2>Read-only methods</h2>\n<p>There is no such thing as a read-only method.  A method executes some behavior, and optionally returns a value/reference.</p>\n<p>A method can be marked as <code>final</code> but that has nothing to do with reading data. A <code>final</code> method cannot be overridden in a subclass.</p>\n<p>Similarly, a <code>final</code> class cannot have any subclasses, cannot be extended.</p>\n"
    },
    {
      "owner": {
        "account_id": 8546,
        "reputation": 18030,
        "user_id": 15472,
        "user_type": "registered",
        "accept_rate": 87,
        "profile_image": "https://www.gravatar.com/avatar/9b4128da626e5b0049cd4fb88033e3b3?s=256&d=identicon&r=PG",
        "display_name": "tucuxi",
        "link": "https://stackoverflow.com/users/15472/tucuxi"
      },
      "is_accepted": false,
      "score": 1,
      "last_activity_date": 1699539851,
      "last_edit_date": 1699539851,
      "creation_date": 1686213991,
      "answer_id": 76430112,
      "question_id": 14250897,
      "content_license": "CC BY-SA 4.0",
      "body": "<p>Something is read-only if it cannot be modified (or, in a weaker sense, cannot be observed to have been modified). This is a really useful property that goes with a lot of different names: read-only, immutable, finality, const-ness, observer, purity, and probably others.</p>\n<p><strong>Why it is useful</strong></p>\n<ul>\n<li><p>If you know that there is no possibility of others changing something, there are a lot less downsides to giving access or sharing it.</p>\n</li>\n<li><p>If a whole object is immutable, there is no longer that much of a difference between sharing the original and sharing copies. This may save a lot of space by avoiding copies.</p>\n</li>\n<li><p>Immutable things never break when several threads are accessing them at once, because all threads will see the same values.</p>\n</li>\n<li><p>It is a lot easier to reason about how things change when there is a very small set of places in which they <em>can</em> change. Immutability helps you keep that set small.</p>\n</li>\n</ul>\n<p><strong>How to get immutability in classes and methods in Java</strong></p>\n<p>First, let us assume that your class can only be modified via access to its methods (= no public attributes, and no use of reflection to gain access to privates)</p>\n<ul>\n<li><p>A class is immutable if no methods can modify its state; that is, no setters, and all other methods can only read state and/or copy state to a <em>new</em> object. For example, the JDK's <a href=\"https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html\" rel=\"nofollow noreferrer\">BigDecimal</a> are immutable: <code>a.add(b)</code> returns a new <code>BigDecimal</code>, but does not modify either <code>a</code> or <code>b</code>.</p>\n</li>\n<li><p>A method can be said to be <code>read only</code>, or <code>const</code> (especially in the C++ world), or <code>observer</code>, when it is guaranteed not to change the state of an object. Some languages, most notably C++, have a keyword for this (<code>const</code>). In others (Java) it is up to the documentation to clarify whether or not the internal state will change.</p>\n</li>\n</ul>\n<p><strong>Other types of immutability in Java</strong></p>\n<ul>\n<li><p><code>static</code> methods have no underlying object, and cannot modify what they do not have. It does not make much sense to call them immutable, though.</p>\n</li>\n<li><p><code>final</code> next to a <code>class</code> declaration prevents subclassing of classes. It does not make them immutable, but it does make it harder to (by subclassing) break the immutability of a class.</p>\n</li>\n<li><p><code>final</code> next to an <em>attribute</em> declaration ensures that the attribute's value cannot be changed once initialized. This allows you to make those attributes <code>public</code> without compromising immutability, for example. A better use would be to make it abundantly clear, in an immutable class, that there will be no modifications to those attributes.</p>\n</li>\n<li><p><code>enum</code> in Java builds special classes that have only a given set of members, a set which cannot be modified at run-time. It is a sort of generalization of the concept of singletons.</p>\n</li>\n</ul>\n"
    }
  ],
  "question_comments": [
    {
      "owner": {
        "account_id": 322981,
        "reputation": 346871,
        "user_id": 642706,
        "user_type": "registered",
        "accept_rate": 58,
        "profile_image": "https://i.sstatic.net/ZWEI3.jpg?s=256",
        "display_name": "Basil Bourque",
        "link": "https://stackoverflow.com/users/642706/basil-bourque"
      },
      "edited": false,
      "score": 1,
      "creation_date": 1733383260,
      "post_id": 14250897,
      "comment_id": 139753971,
      "content_license": "CC BY-SA 4.0"
    }
  ],
  "answer_comments": {
    "79840077": [],
    "76430112": []
  }
}