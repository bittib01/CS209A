{
  "question": {
    "tags": [
      "java",
      "spring",
      "spring-boot",
      "spring-cache"
    ],
    "owner": {
      "account_id": 54813,
      "reputation": 598,
      "user_id": 164090,
      "user_type": "registered",
      "accept_rate": 75,
      "profile_image": "https://i.sstatic.net/uDZ5A.jpg?s=256",
      "display_name": "Mitch Kent",
      "link": "https://stackoverflow.com/users/164090/mitch-kent"
    },
    "is_answered": true,
    "view_count": 210,
    "accepted_answer_id": 79472464,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1742746169,
    "creation_date": 1740645976,
    "last_edit_date": 1742327089,
    "question_id": 79472058,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79472058/spring-idiomatic-way-to-register-cacheresolver-in-configuration-class",
    "title": "Spring idiomatic way to register CacheResolver in @Configuration class",
    "body": "<p>I'm working with a Spring Boot application that needs to use a cache and using Spring caching framework, and I'm importing a library (that I have little control over) that also has a cache. I'm getting errors that there are multiple <code>CacheManager</code> implementations so I need to use a <code>CacheResolver</code>. So far makes perfect sense. Looked at <code>CacheResolver</code> interface, looks reasonable.</p>\n<p>So I have created my own simple <code>CacheResolver</code> and created it as a bean, but it isn't being picked up automatically - ok, I'm used to spring magic but never mind, so how do I register it?</p>\n<p>The only way I have managed to get a custom <code>CacheResolver</code> recognised by the framework so far is by making my <code>@Configuration</code> class implement <code>CachingConfigurator</code> interface and overriding the <strong>no method</strong> argument <code>cacheResolver()</code> - however that's frustratingly useless as I need to pass that method my 2x <code>CacheManager</code> implementations to add it to constructor of my custom <code>CacheResolver</code> - as soon as I add those beans as method arguments it stops working because, whilst the bean is registered normally, that particular interface method is no longer an override and so it doesn't get called as part of the <code>CachingConfigurator</code> lifecycle. It just doesn't feel like the intended/idiomatic way of doing things either but I've found no better documentation.</p>\n<p>Importantly, I don't want to be putting <code>cacheManager = xyz</code> or <code>cacheResolver = zyx</code> in all my Cacheable annotations because, as I say, some of those annotations are in a library I don't own.</p>\n<p>Anyone had to handle this situation? Feels like I'm missing something obvious.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}