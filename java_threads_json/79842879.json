{
  "question": {
    "tags": [
      "java",
      "spring",
      "spring-boot",
      "spring-security"
    ],
    "owner": {
      "account_id": 31367400,
      "reputation": 1,
      "user_id": 24185487,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/ced53b186518de58be0ab613a3ee9311?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Andrey Antonov",
      "link": "https://stackoverflow.com/users/24185487/andrey-antonov"
    },
    "is_answered": false,
    "view_count": 129,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1765483140,
    "creation_date": 1765366095,
    "last_edit_date": 1765366432,
    "question_id": 79842879,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79842879/spring-boot-creates-2-security-filter-chains-instead-of-1-in-spring-boot-3-5-8",
    "title": "Spring boot creates 2 security filter chains instead of 1 in spring boot 3.5.8",
    "body": "<p>I'm migrating code from spring boot 2.7.5 to 3.5.8. Before the migration everything worked fine</p>\n<p>Here is my internal security configuration in my library</p>\n<pre><code>@Configuration\n@EnableWebSecurity\n@RequiredArgsConstructor\npublic class SecurityConfig {\n\n    @Bean\n    @Order(Ordered.HIGHEST_PRECEDENCE)\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http\n            .sessionManagement(sessionManagement -&gt;\n                sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n            .csrf(AbstractHttpConfigurer::disable)\n            .authorizeHttpRequests(request -&gt; request\n                .requestMatchers(&quot;/app&quot;).hasAuthority(&quot;APP&quot;)\n                .requestMatchers(&quot;/**&quot;).permitAll()\n            )\n            .httpBasic(Customizer.withDefaults())\n            .exceptionHandling(exceptionHandling -&gt;\n                exceptionHandling.authenticationEntryPoint(new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED)))\n            .headers(headersConfigurer -&gt; headersConfigurer\n                .contentSecurityPolicy(securityPolicyConfigurer -&gt; securityPolicyConfigurer.policyDirectives(&quot;*&quot;))\n                .referrerPolicy(referrerPolicyConfigurer -&gt; referrerPolicyConfigurer\n                    .policy(ReferrerPolicyHeaderWriter.ReferrerPolicy.NO_REFERRER))\n                .permissionsPolicyHeader(permissionsPolicyConfig -&gt; permissionsPolicyConfig.policy(&quot;self&quot;))\n                .httpStrictTransportSecurity(hstsConfig -&gt; hstsConfig\n                    .includeSubDomains(true)\n                    .maxAgeInSeconds(SECONDS_IN_YEAR))\n                .frameOptions(HeadersConfigurer.FrameOptionsConfig::deny))\n            .headers(headersConfigurer -&gt; headersConfigurer.contentTypeOptions(Customizer.withDefaults()));\n\n        return http.build();\n    }\n</code></pre>\n<p>the class gets into the context like this</p>\n<pre><code>@ComponentScan\npublic class AppConfiguration {\n}\n</code></pre>\n<p>Next, I include this library in my project and when I run it I get</p>\n<pre><code>Caused by: org.springframework.security.web.UnreachableFilterChainException: A filter chain that matches any request [DefaultSecurityFilterChain defined as 'managementSecurityFilterChain' in [class path resource [org/springframework/boot/actuate/autoconfigure/security/servlet/ManagementWebSecurityAutoConfiguration.class]] matching [any request] and having filters [DisableEncodeUrl, WebAsyncManagerIntegration, SecurityContextHolder, HeaderWriter, Cors, Csrf, Logout, UsernamePasswordAuthentication, DefaultResources, DefaultLoginPageGenerating, DefaultLogoutPageGenerating, BasicAuthentication, RequestCacheAware, SecurityContextHolderAwareRequest, AnonymousAuthentication, ExceptionTranslation, Authorization]] has already been configured, which means that this filter chain [DefaultSecurityFilterChain defined as 'securityFilterChain' in [class path resource [/app/config/SecurityConfig.class]] matching [any request] and having filters [DisableEncodeUrl, WebAsyncManagerIntegration, SecurityContextHolder, HeaderWriter, Logout, BasicAuthentication, RequestCacheAware, SecurityContextHolderAwareRequest, AnonymousAuthentication, SessionManagement, ExceptionTranslation, Authorization]] will never get invoked. Please use `HttpSecurity#securityMatcher` to ensure that there is only one filter chain configured for 'any request' and that the 'any request' filter chain is published last.\n    at app//org.springframework.security.config.annotation.web.builders.WebSecurityFilterChainValidator.checkForAnyRequestRequestMatcher(WebSecurityFilterChainValidator.java:59)\n    at app//org.springframework.security.config.annotation.web.builders.WebSecurityFilterChainValidator.validate(WebSecurityFilterChainValidator.java:47)\n    at app//org.springframework.security.web.FilterChainProxy.afterPropertiesSet(FilterChainProxy.java:178)\n    at app//org.springframework.security.config.annotation.web.builders.WebSecurity.performBuild(WebSecurity.java:351)\n    at app//org.springframework.security.config.annotation.web.builders.WebSecurity.performBuild(WebSecurity.java:98)\n    at app//org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.doBuild(AbstractConfiguredSecurityBuilder.java:355)\n    at app//org.springframework.security.config.annotation.AbstractSecurityBuilder.build(AbstractSecurityBuilder.java:38)\n    at app//org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.springSecurityFilterChain(WebSecurityConfiguration.java:132)\n    at app//org.springframework.beans.factory.support.SimpleInstantiationStrategy.lambda$instantiate$0(SimpleInstantiationStrategy.java:172)\n    ... 44 more\n</code></pre>\n<p>This happens because the next bin gets into the context earlier</p>\n<pre><code>@AutoConfiguration(before = SecurityAutoConfiguration.class,\n       after = { HealthEndpointAutoConfiguration.class, InfoEndpointAutoConfiguration.class,\n             WebEndpointAutoConfiguration.class, OAuth2ClientWebSecurityAutoConfiguration.class,\n             OAuth2ResourceServerAutoConfiguration.class, Saml2RelyingPartyAutoConfiguration.class })\n@ConditionalOnWebApplication(type = Type.SERVLET)\n@ConditionalOnDefaultWebSecurity\npublic class ManagementWebSecurityAutoConfiguration {\n\n    @Bean\n    @Order(SecurityProperties.BASIC_AUTH_ORDER)\n    SecurityFilterChain managementSecurityFilterChain(Environment environment, HttpSecurity http) throws Exception {\n       http.authorizeHttpRequests((requests) -&gt; {\n          requests.requestMatchers(healthMatcher(), additionalHealthPathsMatcher()).permitAll();\n          requests.anyRequest().authenticated();\n       });\n       if (ClassUtils.isPresent(&quot;org.springframework.web.servlet.DispatcherServlet&quot;, null)) {\n          http.cors(withDefaults());\n       }\n       http.formLogin(withDefaults());\n       http.httpBasic(withDefaults());\n       return http.build();\n    }\n</code></pre>\n<p>The error was fixed by adding the following settings to application.yaml</p>\n<pre><code>spring:\n    autoconfigure:\n        exclude: &gt;\n            org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\n            org.springframework.boot.actuate.autoconfigure.security.servlet.ManagementWebSecurityAutoConfiguration\n</code></pre>\n<p>or</p>\n<pre><code>@Bean(&quot;managementSecurityFilterChain&quot;)\n@Primary\n@Order(Ordered.HIGHEST_PRECEDENCE)\npublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n</code></pre>\n<p>with</p>\n<pre><code>spring:\n    main:\n        allow-bean-definition-overriding: true\n</code></pre>\n<p>but it seems to me that this is not entirely correct and may lead to negative consequences. <strong>How can only managementSecurityFilterChain be excluded from the context</strong>?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}