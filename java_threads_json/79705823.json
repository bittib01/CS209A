{
  "question": {
    "tags": [
      "java",
      "graphics",
      "3d",
      "geometry"
    ],
    "owner": {
      "account_id": 18244328,
      "reputation": 1,
      "user_id": 13917968,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/2e44c41bd67de198261eacaace91ab7e?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "randomuser12345",
      "link": "https://stackoverflow.com/users/13917968/randomuser12345"
    },
    "is_answered": false,
    "view_count": 188,
    "answer_count": 1,
    "score": -1,
    "last_activity_date": 1754524379,
    "creation_date": 1752822862,
    "last_edit_date": 1754524379,
    "question_id": 79705823,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79705823/3d-projection-without-matrices-breaks-on-negative-distance",
    "title": "3D projection without matrices breaks on negative distance",
    "body": "<p>I am drawing edges of triangles and quads with rotation and changing camera position, without projection matrices but multiplication and division, however I can not figure out what happens to the coordinates when the vertices go behind the camera.</p>\n<p>After I pass a vertex it breaks and changes its position (looks like it mirrors to the side). I assume due to the negative distance of being behind the camera. Although I ignore triangles behind the camera I must find their position so I can draw the edges.</p>\n<p><code>Main</code> class:</p>\n<pre><code>package def_pack;\nimport java.io.IOException;\nimport javax.swing.JFrame;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n            JFrame f = new JFrame(&quot;3D Test&quot;);\n            f.setSize(1920, 1080);\n            f.setResizable(false);\n            f.setLocationRelativeTo(null);\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            GamePanel gamePanel = new GamePanel();\n            f.add(gamePanel);\n            gamePanel.setSize(1920,1080);\n            gamePanel.startThread();\n            f.setVisible(true);\n    }\n}\n</code></pre>\n<p><code>GamePanel</code> class:</p>\n<pre><code>package def_pack;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.io.IOException;\nimport javax.swing.JPanel;\n\npublic class GamePanel extends JPanel implements Runnable{\n    public Thread thr;\n    public scene s;\n    GamePanel() throws IOException{\n            s = new scene();\n    }\n    @Override\n    public void run() {\n\n        while (true) {\n             try {\n                Thread.sleep(1);\n            } catch (InterruptedException e) {e.printStackTrace();}\n              try {\n                update();\n                repaint();\n              } catch (IOException e) {e.printStackTrace();}\n        }\n    }\n\n    public void update() throws IOException {\n        s.update();\n    }\n    public void paintComponent(Graphics g) {\n            Graphics2D g2d= (Graphics2D)g;\n            g2d.clearRect(0, 0, 1920, 1080);\n            try {\n                s.draw(g2d);\n            } catch (InterruptedException e) {e.printStackTrace();}\n    }\n    public void startThread() {\n            thr = new Thread(this);\n            thr.start();\n    }\n}\n</code></pre>\n<p><code>vertex3D</code> class:</p>\n<pre><code>package def_pack;\n\npublic class vertex3D {\n    public double x,y,z;\n    public double[] transformedCoords= {0,0,0};\n       vertex3D(double x, double y, double z){\n           this.x=x;\n           this.y=-y;\n           this.z=z;\n       }\n\n    public void update(double camX, double camY, double camZ) {\n// get relative coordinates\n            this.transformedCoords[0]=this.x-camX;\n            this.transformedCoords[1]=this.y-camY;\n            this.transformedCoords[2]=this.z-camZ;\n    }\n}\n</code></pre>\n<p><code>scene</code> class:</p>\n<pre><code>package def_pack;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Rectangle;\nimport java.awt.geom.Area;\nimport java.io.IOException;\nimport java.util.ArrayList;\n\npublic class scene {\n    public double camX=0;\n    public double camY=0;\n    public double camZ=0;\n    public vertex3D[] testQuad = {new vertex3D(-3,-2,2),new vertex3D(-3,-2,4),new vertex3D(-3,3,4),new vertex3D(-3,3,2)};\n    public int meshesAmount;\n    public ArrayList&lt;vertex3D[]&gt; meshes = new ArrayList&lt;&gt;();\n    public Rectangle screen = new Rectangle(0,0,1920,1080);\n    public int scrW=1920;\n    public int scrH=1080;\n    public int sizer=300;\n    scene() throws IOException {\n        meshes.add(testQuad);\n        meshesAmount=meshes.size();\n        }\n    public void update(){\n        camZ+=0.001;\n        for (int i=0;i&lt;meshesAmount;i++) {\n            for (int j=0;j&lt;meshes.get(i).length;j++) {\n                meshes.get(i)[j].update(camX,camY,camZ);\n            }\n        }\n    }\n    public void draw(Graphics2D g2d) throws InterruptedException {\n        for (int i=0;i&lt;meshesAmount;i++) {\n            boolean drawable=false;\n                for (int j=0;j&lt;meshes.get(i).length;j++) {\n                    if (meshes.get(i)[j].transformedCoords[2]&gt;0) {\n                    drawable=true;\n                }\n        }\n            if (drawable) {\n                int nPoints=meshes.get(i).length;\n                int xPoints[] = new int[nPoints];\n                int yPoints[]=new int[nPoints];\n                for (int j=0;j&lt;meshes.get(i).length;j++) {\n                    double newX=meshes.get(i)[j].transformedCoords[0]/(meshes.get(i)[j].transformedCoords[2]);\n                    double newY=meshes.get(i)[j].transformedCoords[1]/(meshes.get(i)[j].transformedCoords[2]);\n                    newX*=sizer;\n                    newX/=scrW/scrH;\n                    newY*=sizer;\n                    newX+=scrW/2;\n                    newY+=scrH/2;\n                    xPoints[j]=(int)(newX);\n                    yPoints[j]=(int)(newY);\n                }\n                g2d.setColor(Color.cyan);\n                Polygon p = new Polygon(xPoints, yPoints, xPoints.length);\n                Area polyArea = new Area(p);\n                Area screenArea = new Area(screen);\n                polyArea.intersect(screenArea);\n                g2d.fill(polyArea);\n            }\n        }\n   }\n}\n</code></pre>\n<p>I tried:</p>\n<pre><code>if (behindCam[j]) {\n    meshes.get(i)[j].transformedCoords[2]=-1/meshes.get(i)[j].transformedCoords[0];\n}\n</code></pre>\n<p>and:</p>\n<pre><code>newX*=-1;\nnewY*=-1;\n</code></pre>\n<p>and:</p>\n<pre><code>meshes.get(i)[j].transformedCoords[2]=-meshes.get(i)[j].transformedCoords[2];\n</code></pre>\n<p>However, I can not figure it out. It seems that when <code>meshes.get(i)[j].transformedCoords[2]</code> (z coordinate) makes distance blow up when using the first approach and it's between 0 and -1, however after that it seems to work. I tried limiting <code>transformedCoords[2]</code> to 0.0001 so that it never becomes negative, however the perspective looks fake after that.</p>\n<p>Image of quad from beginning:</p>\n<p><a href=\"https://i.sstatic.net/53YoUf1H.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/53YoUf1H.png\" alt=\"quad begin\" /></a></p>\n<p>Nearing distance 0 for vertices closest to cam:</p>\n<p><a href=\"https://i.sstatic.net/KPV2aZbG.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/KPV2aZbG.png\" alt=\"quad middle\" /></a></p>\n<p>Half of quad behind cam:</p>\n<p><a href=\"https://i.sstatic.net/fUpWRi6t.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/fUpWRi6t.png\" alt=\"quad half behind\" /></a></p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}