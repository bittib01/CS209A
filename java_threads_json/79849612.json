{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "rest"
    ],
    "owner": {
      "account_id": 10854266,
      "reputation": 1,
      "user_id": 7981122,
      "user_type": "registered",
      "profile_image": "https://i.sstatic.net/4azbv.jpg?s=256",
      "display_name": "Ankti Rai",
      "link": "https://stackoverflow.com/users/7981122/ankti-rai"
    },
    "is_answered": false,
    "view_count": 69,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1766070422,
    "creation_date": 1765987917,
    "last_edit_date": 1765990407,
    "question_id": 79849612,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79849612/spring-boot-3-x-401-response-body-is-empty-when-received-by-another-service",
    "title": "Spring Boot 3.x – 401 response body is empty when received by another service",
    "body": "<p>We are upgrading Spring Boot from <strong>2.7.0 to 3.5.6</strong> and are facing an issue with error responses between two services.</p>\n<h4>Setup</h4>\n<ul>\n<li><p><strong>Service A</strong> → sends a <code>POST</code> request to <strong>Service B</strong></p>\n</li>\n<li><p><strong>Service B</strong> → handles authentication</p>\n</li>\n<li><p>On authentication failure, <strong>Service B</strong> invokes a custom <code>RestAuthFailureHandler</code> which creates a meaningful JSON response (e.g. <code>errorId</code>, <code>message</code>, etc.)</p>\n</li>\n</ul>\n<p>Example response from <strong>Service B</strong>:</p>\n<pre><code>POST /serviceB/login HTTP/1.1 401 165\n</code></pre>\n<p>So:</p>\n<ul>\n<li><p>HTTP status code is <strong>401</strong></p>\n</li>\n<li><p>Response body exists (165 bytes)</p>\n</li>\n<li><p>JSON is correctly written in the failure handler</p>\n</li>\n</ul>\n<h4>Problem</h4>\n<p>When <strong>Service A</strong> receives the response:</p>\n<ul>\n<li><p>The HTTP status is correctly <strong>401</strong></p>\n</li>\n<li><p><strong>Response body is empty</strong></p>\n</li>\n</ul>\n<p>Because of this, Service A cannot display the specific error message and instead shows a generic error.</p>\n<p>This setup worked correctly before the upgrade (Spring Boot <strong>2.7.x</strong>).</p>\n<h4>Question</h4>\n<p>After upgrading to Spring Boot 3.x:</p>\n<ul>\n<li><p>Why is the response body of a <code>401 Unauthorized</code> response not available to the calling service?</p>\n</li>\n<li><p>Is this related to changes in <strong>Spring Security 6</strong>, filters, or response handling?</p>\n</li>\n<li><p>Are there any additional configurations required to ensure the response body is propagated for authentication failures?</p>\n</li>\n</ul>\n<p>Any pointers or examples would be greatly appreciated.</p>\n<h2>ServiceB</h2>\n<pre><code>@Component\npublic class RestAuthFailureHandler implements AuthenticationFailureHandler {\n\n    private static final Logger log = LoggerFactory.getLogger(RestAuthFailureHandler.class);\n\n    @Autowired\n    private ObjectMapper mapper;\n\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest request,\n                                        HttpServletResponse response,\n                                        AuthenticationException exception)\n            throws IOException {\n        log.info(&quot;Entered onAuthenticationFailure&quot;);\n\n        boolean committed = response.isCommitted();\n        log.info(&quot;Response committed state: {}&quot;, committed);\n\n        log.info(&quot;Exception type: {}, message: {}&quot;, exception.getClass().getName(), exception.getMessage());\n\n        if (committed) {\n            log.warn(&quot;Response already committed, unable to write error body&quot;);\n            return;\n        }\n\n        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n        response.setContentType(MediaType.APPLICATION_JSON_VALUE);\n        response.setCharacterEncoding(&quot;UTF-8&quot;);\n\n        ErrorInfo errorInfo;\n        if (exception instanceof RestAuthenticationException restAuthenticationException) {\n            errorInfo = restAuthenticationException.getErrorInfo();\n            log.info(&quot;Using ErrorInfo from RestAuthenticationException: {}&quot;, errorInfo);\n        } else {\n            errorInfo = new ErrorInfo(\n                    ErrorCategory.APPLICATION_ERROR.name(),\n                    UserAPIErrorCode.AUTHENTICATION.code(),\n                    exception.getMessage()\n            );\n            log.info(&quot;Constructed new ErrorInfo: {}&quot;, errorInfo);\n        }\n\n        try {\n            log.info(&quot;Writing ErrorInfo to response&quot;);\n            mapper.writeValue(response.getWriter(), errorInfo);\n            response.getWriter().flush();\n            log.info(&quot;Successfully wrote ErrorInfo to response&quot;);\n        } catch (IOException e) {\n            log.error(&quot;IOException while writing ErrorInfo to response&quot;, e);\n            throw e;\n        }\n    }\n}\n</code></pre>\n<h2>ServiceB - security config</h2>\n<pre><code>        // First formLogin() → /login\n        http.formLogin(form -&gt; form\n                .loginProcessingUrl(LOGIN_PATH)\n                .usernameParameter(&quot;username&quot;)\n                .passwordParameter(&quot;password&quot;)\n                .successHandler(restAuthSuccessHandler)\n                .failureHandler(restAuthFailureHandler)\n                .permitAll()\n        );\n</code></pre>\n<h2><strong>ServiceA</strong></h2>\n<pre><code>    @Bean\n    @Primary\n    public RestTemplate restTemplate() {\n        return createRestTemplate(null);\n    }\n\n    @Bean\n    public RestTemplate proxiedRestTemplate() {\n        if (StringUtils.isNotBlank(proxyHost) &amp;&amp; StringUtils.isNotBlank(proxyPort)) {\n            final Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.valueOf(proxyPort)));\n            return createRestTemplate(proxy);\n        } else {\n            return createRestTemplate(null);\n        }\n    }\n\n    private RestTemplate createRestTemplate(final Proxy proxy) {\n        RestTemplate restTemplate = new RestTemplate();\n        SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();\n        requestFactory.setProxy(proxy);\n        requestFactory.setReadTimeout(readTimeOut);\n        requestFactory.setConnectTimeout(connectionTimeOut);\n        BufferingClientHttpRequestFactory bufferingClientHttpRequestFactory = new BufferingClientHttpRequestFactory(requestFactory);\n        restTemplate.setRequestFactory(bufferingClientHttpRequestFactory);\n        return restTemplate;\n    }\n</code></pre>\n<pre><code>@Service\npublic class StatelessExchangeServiceImpl  implements StatelessExchangeService {\n\n    private final Logger logger = LogManager.getLogger(this.getClass());\n\n    @Autowired\n    private JsonUtils jsonUtils;\n\n    public &lt;T&gt; ResponseEntity&lt;T&gt; exchange(final RestTemplate restTemplate,\n                                          final HttpMethod httpMethod,\n                                          final String serviceBaseUrl,\n                                          final String restEndpointUrl,\n                                          final Optional&lt;Object&gt; body,\n                                          final Optional&lt;Map&lt;String, String&gt;&gt; requestParams,\n                                          final Class&lt;T&gt; responseType,\n                                          final Map&lt;String, String&gt; headersToOverride) {\n\n        HttpServletRequest request = null;\n\n        // This check added for the requests coming from session destroyed.\n        if (RequestContextHolder.getRequestAttributes() != null) {\n            request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();\n            logger.debug(&quot;Request uri is {}&quot;, request.getRequestURI());\n            HeaderUtils.logHeaders(request.getRequestURI() , request);\n        }\n\n        HttpHeaders httpHeaders = new HttpHeaders();\n        if (request != null) {\n            httpHeaders = HeaderUtils.mapHeaders(request);\n                      httpHeaders.remove(HttpHeaders.CONTENT_LENGTH);\n        }\n\n\n        String url =  serviceBaseUrl + restEndpointUrl;\n\n        final URI uri = addRequestParamsToUrl( url, requestParams );\n\n        logger.debug(&quot;Generated routing service URI:  {}&quot;, uri);\n\n        HttpEntity&lt;?&gt; requestEntity;\n        HeaderUtils.overrideHeaders(httpHeaders, headersToOverride);\n        if (body.isPresent()) {\n            requestEntity = new HttpEntity&lt;&gt;(body.get(), httpHeaders);\n        }\n        else{\n                    requestEntity = new HttpEntity&lt;&gt;(null, httpHeaders);\n        }\n\n        final ResponseEntity&lt;T&gt; responseEntity;\n        try {\n            logger.debug(&quot;Calling uri: {}, with method: {}, and headers: {}&quot;, uri.toString(), httpMethod.name(), requestEntity.getHeaders());\n            responseEntity = restTemplate.exchange(uri, httpMethod, requestEntity, responseType);\n            logger.debug(&quot;Response headers for uri: {}, are: &quot;, uri.toString(), responseEntity.getHeaders());\n        }\n        catch (HttpClientErrorException hcee) {\n            logger.info(&quot;Internal call to rest service {} returned with status code: {}, message: {}&quot;, uri, hcee.getStatusCode().value(), hcee.getResponseBodyAsString(), hcee);\n                        logger.info(&quot;Status={}, ResponseHeaders={}, Body='{}'&quot;,\n                            hcee.getStatusCode(),\n                            hcee.getResponseHeaders(),\n                            hcee.getResponseBodyAsString()\n                        );\n            if(!jsonUtils.isValidJson(hcee.getResponseBodyAsString())) {\n                ErrorInfo errorInfo = ErrorInfo.internalServiceError();\n                logger.info(&quot;ErrorId: {}, Internal call to rest service {} returned with status code: {}, message: {}&quot;, errorInfo.getErrorId(), uri, hcee.getStatusCode().value(), hcee.getResponseBodyAsString(), hcee);\n                throw new InternalRestCallException(HttpStatus.INTERNAL_SERVER_ERROR.value(), jsonUtils.toJson(errorInfo).get());\n            }\n            throw new InternalRestCallException(hcee.getStatusCode().value(), hcee.getResponseBodyAsString());\n        }\n        catch(HttpServerErrorException hsee){\n            ErrorInfo errorInfo = ErrorInfo.internalServiceError();\n            logger.info(&quot;ErrorId: {}, Internal call to rest service {} failed with status code: {}, message: {}&quot;, errorInfo.getErrorId(), uri, hsee.getStatusCode().value(), hsee.getResponseBodyAsString(), hsee);\n            throw new InternalRestCallException(hsee.getStatusCode().value(), jsonUtils.toJson(errorInfo).get());\n        }\n        catch (RestClientException rce) {\n            ErrorInfo errorInfo = ErrorInfo.internalServiceError();\n            logger.info(&quot;ErrorId: {}, Internal call to rest service {} failed&quot;, errorInfo.getErrorId(), uri, rce);\n            throw new InternalRestCallException(HttpStatus.INTERNAL_SERVER_ERROR.value(), jsonUtils.toJson(errorInfo).get());\n        }\n\n        logger.debug(&quot;Response status for uri: {} is {}&quot;, uri.toString(), responseEntity.getStatusCode().toString());\n\n        return responseEntity;\n\n    }\n\n    public   URI addRequestParamsToUrl( final String url, final Optional&lt;Map&lt;String,String&gt;&gt; requestParams ) {\n        final UriComponentsBuilder uriBuilder = UriComponentsBuilder.fromHttpUrl(url);\n        if (requestParams.isPresent()) {\n            final Map&lt;String,String&gt; params = requestParams.get();\n            if (!params.isEmpty()) {\n                final LinkedMultiValueMap&lt;String,String&gt; paramsMap = new LinkedMultiValueMap&lt;&gt;(params.size());\n                paramsMap.setAll(params);\n                uriBuilder.queryParams(paramsMap);\n            }\n        }\n\n        return uriBuilder.build().encode().toUri();\n    }\n}\n</code></pre>\n<pre><code>// Logs from service B where we are setting the response message in case of auth failure \n{\n    &quot;instant&quot;: {\n        &quot;epochSecond&quot;: 1765986931,\n        &quot;nanoOfSecond&quot;: 110147101\n    },\n    &quot;thread&quot;: &quot;https-jsse-nio-8443-exec-7&quot;,\n    &quot;level&quot;: &quot;INFO&quot;,\n    &quot;loggerName&quot;: &quot;com.zzz.sso.authentication.handler.RestAuthFailureHandler&quot;,\n    &quot;message&quot;: &quot;Using ErrorInfo from RestAuthenticationException: zzz.da.common.utils.error.ErrorInfo@2b5da880[category=APPLICATION_ERROR,code=not.authenticated,errorId=95bb4498-acac-411f-a574-7603b352da13,message=Your email address or password is incorrect.]&quot;,\n    &quot;endOfBatch&quot;: false,\n    &quot;loggerFqcn&quot;: &quot;org.apache.logging.slf4j.Log4jLogger&quot;,\n    &quot;threadId&quot;: 49,\n    &quot;threadPriority&quot;: 5,\n    &quot;source&quot;: {\n        &quot;class&quot;: &quot;com.zzz.sso.authentication.handler.RestAuthFailureHandler&quot;,\n        &quot;method&quot;: &quot;onAuthenticationFailure&quot;,\n        &quot;file&quot;: &quot;RestAuthFailureHandler.java&quot;,\n        &quot;line&quot;: 52\n    }\n}\n</code></pre>\n<pre><code>//below are logs from serviceA where no body came through from serviceB. \n&quot;thread&quot;: &quot;https-jsse-nio-8443-exec-3&quot;,\n    &quot;level&quot;: &quot;INFO&quot;,\n    &quot;loggerName&quot;: &quot;com.zzz.myaccount.service.impl.StatelessExchangeServiceImpl&quot;,\n    &quot;message&quot;: &quot;Internal call to rest service https://das-sso-api.qa.zzzdigitalapi.com/zzz-okta-authentication/login returned with status code: 401, message: &quot;,\n    &quot;thrown&quot;: {\n        &quot;message&quot;: &quot;401  on POST request for \\&quot;https://das-sso-api.qa.zzzdigitalapi.com/zzz-okta-authentication/login\\&quot;: [no body]&quot;,\n        &quot;name&quot;: &quot;org.springframework.web.client.HttpClientErrorException.Unauthorized&quot;,\n        &quot;extendedStackTrace&quot;: [\n            {\n                &quot;class&quot;: &quot;org.springframework.web.client.HttpClientErrorException&quot;,\n                &quot;method&quot;: &quot;create&quot;,\n                &quot;file&quot;: &quot;HttpClientErrorException.java&quot;,\n                &quot;line&quot;: 106\n            },\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}