{
  "question": {
    "tags": [
      "java",
      "http",
      "multipart",
      "server-sent-events",
      "java-http-client"
    ],
    "owner": {
      "account_id": 1418937,
      "reputation": 5470,
      "user_id": 1343979,
      "user_type": "registered",
      "accept_rate": 80,
      "profile_image": "https://www.gravatar.com/avatar/1cde802f2b3fae0e23f43a65b507bd05?s=256&d=identicon&r=PG",
      "display_name": "Андрей Щеглов",
      "link": "https://stackoverflow.com/users/1343979/%d0%90%d0%bd%d0%b4%d1%80%d0%b5%d0%b9-%d0%a9%d0%b5%d0%b3%d0%bb%d0%be%d0%b2"
    },
    "is_answered": false,
    "view_count": 183,
    "answer_count": 0,
    "score": 1,
    "last_activity_date": 1724870324,
    "creation_date": 1712232180,
    "question_id": 78273708,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78273708/using-java-http-client-process-individual-parts-of-an-http-multipart-response-a",
    "title": "Using Java HTTP client, process individual parts of an HTTP multipart response as they arrive",
    "body": "<p>I'm creating a client-server application where an HTTP 1.1 server sends an arbitrary number of binary packets to the client in a single HTTP response. The size of a response body may be as large as hundreds of megabytes and is not known in advance, because the server uses streaming serialization (either binary via <code>java.io.Serializable</code> or JSON via <a href=\"https://github.com/Kotlin/kotlinx.serialization\" rel=\"nofollow noreferrer\"><code>kotlinx.serialization</code></a>). For the above reason, the server uses <a href=\"https://en.wikipedia.org/wiki/Chunked_transfer_encoding\" rel=\"nofollow noreferrer\">chunked transfer encoding</a>.</p>\n<p>The client, in turn, needs to process each binary packet as it arrives, <em>before</em> the response body is fully read out. In other words, the client needs to transform the body into a <em>cold stream</em> of data, so that for the downstream code the API is visible as either</p>\n<ul>\n<li><code>Stream&lt;InputStream&gt;</code>, or</li>\n<li><code>Flux&lt;InputStream&gt;</code>,</li>\n</ul>\n<p>where each <code>InputStream</code> instance is confined to the content of a single binary packet.</p>\n<p>Since the server is sending binary data, and since the client is requesting data via <code>HTTP POST</code>, <a href=\"https://stackoverflow.com/questions/63500818\"><em>Server-Sent Events</em></a> don't seem like a good solution, despite <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.net.http/java/net/http/HttpResponse.BodyHandlers.html#ofLines()\" rel=\"nofollow noreferrer\"><code>BodyHandlers.ofLines()</code></a> API is quite handy on its own.</p>\n<p>Yet, conceptually, the client-server communication scenario is quite similar to what SSE offers, so my original intention was to use the <code>multipart/mixed</code> content type, e.g.:</p>\n<pre class=\"lang-http prettyprint-override\"><code>Content-Type: multipart/mixed; boundary=boundary-a8e06cda-7763-4416-b6fd-4ca033d5c57d-61522nk5is\nTransfer-Encoding: chunked\n\n--boundary-a8e06cda-7763-4416-b6fd-4ca033d5c57d-61522nk5is\nContent-Type: application/octet-stream\nContent-Disposition: &lt;metadata of the 1st binary packet&gt;\n\n&lt;The content of the 1st binary packet&gt;\n--boundary-a8e06cda-7763-4416-b6fd-4ca033d5c57d-61522nk5is\nContent-Type: application/octet-stream\nContent-Disposition: &lt;metadata of the 2nd binary packet&gt;\n\n&lt;The content of the 2nd binary packet&gt;\n--boundary-a8e06cda-7763-4416-b6fd-4ca033d5c57d-61522nk5is--\n</code></pre>\n<p>Two questions:</p>\n<ol>\n<li><p>I may be having an XY problem, so which alternative approaches can you suggest? Anything that runs on top of HTTP 1.1 and can pass through an HTTP proxy is fine (WebSockets or HTTP/2 are a no-go).</p>\n</li>\n<li><p>Which JVM HTTP client implementations (<code>java.net.http.HttpClient</code>, <a href=\"https://hc.apache.org\" rel=\"nofollow noreferrer\"><em>Apache HttpClient</em></a>, <a href=\"https://square.github.io/okhttp/\" rel=\"nofollow noreferrer\"><em>OkHttpClient</em></a>, <a href=\"https://github.com/AsyncHttpClient/async-http-client\" rel=\"nofollow noreferrer\"><em>AsyncHttpClient</em></a>, <a href=\"https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/client/HttpClient.html\" rel=\"nofollow noreferrer\"><em>Jetty HttpClient</em></a>, <a href=\"https://ktor.io/docs/create-client.html\" rel=\"nofollow noreferrer\"><em>Ktor</em></a>, <a href=\"https://www.http4k.org/guide/howto/client_as_a_function/\" rel=\"nofollow noreferrer\"><em>http4k</em></a>, etc.) contain</p>\n<ul>\n<li><em>multipart response parsers</em> and/or</li>\n<li><em>reactive publishers</em></li>\n</ul>\n<p>that can reduce the amount of boilerplate code on the client side?</p>\n</li>\n</ol>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}