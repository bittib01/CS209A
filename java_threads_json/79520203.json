{
  "question": {
    "tags": [
      "java",
      "apache-httpclient-5.x"
    ],
    "owner": {
      "account_id": 1373762,
      "reputation": 43,
      "user_id": 1308193,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/ae5153b3dd6d8edd20b05ff54932279d?s=256&d=identicon&r=PG",
      "display_name": "Venkat",
      "link": "https://stackoverflow.com/users/1308193/venkat"
    },
    "is_answered": true,
    "view_count": 352,
    "accepted_answer_id": 79520508,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1742394994,
    "creation_date": 1742387555,
    "question_id": 79520203,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79520203/configure-custom-socket-factories-for-both-tls-and-non-tls-with-apache-httpclien",
    "title": "Configure custom socket factories for both TLS and non-TLS with apache HttpClient 5.4.2",
    "body": "<p>Looking for the possibility to configure the custom socket factories to set traffic class or type-of-service octet in the IP header for packets sent from this Socket.</p>\n<p>The below setup worked so far with below apache HttpClient versions</p>\n<p>org.apache.httpcomponents.client5  5.3.1</p>\n<p>org.apache.httpcomponents.core5    5.2.4</p>\n<p>DSCP marking for HTTP</p>\n<pre><code>import java.io.IOException;\nimport java.net.Proxy;\nimport java.net.Socket;\nimport java.net.SocketException;\n\nimport org.apache.hc.client5.http.socket.PlainConnectionSocketFactory;\nimport org.apache.hc.core5.http.protocol.HttpContext;\n\n\nclass CustomDscpPlainConnectionSocketFactory extends PlainConnectionSocketFactory {\n\n    private int dscpValue;\n\n    CustomDscpPlainConnectionSocketFactory(int dscpValue) {\n        this.dscpValue = dscpValue;\n    }\n\n    @Override\n    public Socket createSocket(final HttpContext context) throws IOException {\n        Socket socket = super.createSocket(context);\n        socket.setTrafficClass(dscpValue &lt;&lt; 2);\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket(final Proxy proxy, final HttpContext context) throws IOException {\n        Socket socket = super.createSocket(proxy, context);\n        socket.setTrafficClass(dscpValue &lt;&lt; 2);\n        return socket;\n    }\n}\n</code></pre>\n<p>DSCP marking for HTTPS</p>\n<pre><code>import java.io.IOException;\nimport java.net.Proxy;\nimport java.net.Socket;\nimport java.net.SocketException;\n\nimport javax.net.ssl.SSLContext;\n\nimport org.apache.hc.client5.http.ssl.HttpsSupport;\nimport org.apache.hc.client5.http.ssl.SSLConnectionSocketFactory;\nimport org.apache.hc.core5.http.protocol.HttpContext;\n\nclass CustomDscpSSLConnectionSocketFactory extends SSLConnectionSocketFactory {\n\n    private int dscpValue;\n\n    public CustomDscpSSLConnectionSocketFactory(final int dscpValue,\n            final SSLContext sslContext,\n            final String[] supportedProtocols) {\n        super(sslContext.getSocketFactory(), supportedProtocols,\n                getCipherSuites().toArray(String[]::new),\n                HttpsSupport.getDefaultHostnameVerifier());\n        this.dscpValue = dscpValue;\n    }\n\n    public CustomDscpSSLConnectionSocketFactory(SSLContext sslContext) {\n        super(sslContext);\n    }\n\n    @Override\n    public Socket createSocket(HttpContext context) throws IOException {\n        Socket socket = super.createSocket(context);\n        socket.setTrafficClass(dscpValue &lt;&lt; 2);\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket(final Proxy proxy, final HttpContext context) throws IOException {\n        Socket socket = super.createSocket(proxy, context);\n        socket.setTrafficClass(dscpValue &lt;&lt; 2);\n        return socket;\n    }\n}\n</code></pre>\n<p>HttpClient</p>\n<pre><code>import org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager;\nimport org.apache.hc.client5.http.socket.ConnectionSocketFactory;\nimport org.apache.hc.client5.http.ssl.SSLConnectionSocketFactory;\n\nvar plainSocketFactory = new CustomDscpPlainConnectionSocketFactory(20);\nvar sslConnSocketFactory =  new CustomDscpSSLConnectionSocketFactory(20, sslContext, getProtocols())\nPoolingHttpClientConnectionManager poolingmgr = new PoolingHttpClientConnectionManager(\n                RegistryBuilder.&lt;ConnectionSocketFactory&gt;create()\n                        .register(URIScheme.HTTP.id, plainSocketFactory)\n                        .register(URIScheme.HTTPS.id, sslConnSocketFactory)\n                        .build());\nHttpClientBuilder httpClientBuilder = HttpClientBuilder.create()\n                .setRedirectStrategy(DefaultRedirectStrategy.INSTANCE)\n                .setConnectionManager(poolingmgr);\nCloseableHttpClient httpClient = httpClientBuilder.build();\n</code></pre>\n<p>Would like to achieve the similar setup with latest apache HTTP client update versions where PlainConnectionSocketFactory and SSLConnectionSocketFactory are deprecated.</p>\n<p>org.apache.httpcomponents.client5  5.4.2</p>\n<p>org.apache.httpcomponents.core5    5.3.3</p>\n<p>DSCP marking for HTTPS which works</p>\n<pre><code>import java.net.Socket;\nimport java.net.SocketException;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\n\nimport org.apache.hc.client5.http.ssl.DefaultClientTlsStrategy;\nimport org.apache.hc.client5.http.ssl.HttpsSupport;\nimport org.apache.hc.core5.reactor.ssl.SSLBufferMode;\n\n\n    public class CustomClientTlsStrategy extends DefaultClientTlsStrategy {\n    \n        private int dscpValue;\n    \n        public CustomClientTlsStrategy(final int dscpValue,\n                final SSLContext sslContext,\n                final String[] supportedProtocols) {\n            super(sslContext, supportedProtocols,\n                   getCipherSuites().toArray(String[]::new),\n                    SSLBufferMode.STATIC, HttpsSupport.getDefaultHostnameVerifier());\n            this.dscpValue = dscpValue;\n        }\n    \n        protected void initializeSocket(final SSLSocket socket) {\n          socket.setTrafficClass(dscpValue &lt;&lt; 2);\n        }\n    }\n</code></pre>\n<p>DSCP marking for HTTP doesn't work and may be the below setup is not valid for HTTP.</p>\n<pre><code>import java.io.IOException;\nimport java.net.Socket;\nimport java.net.SocketException;\n\nimport org.apache.hc.client5.http.impl.io.ManagedHttpClientConnectionFactory;\nimport org.apache.hc.client5.http.io.ManagedHttpClientConnection;\n\n    public class CustomManagedHttpClientConnectionFactory extends ManagedHttpClientConnectionFactory {\n    \n        private int dscpValue;\n        public CustomManagedHttpClientConnectionFactory(int dscpValue) {\n            super();\n            this.dscpValue = dscpValue;\n        }\n        @Override\n        public ManagedHttpClientConnection createConnection(final Socket socket) throws IOException {\n            ManagedHttpClientConnection connection = super.createConnection(socket);\n            if (connection.getSocket() != null ) { // Socket here is always null and thus DSCP is never marked.\n                connection.getSocket().setTrafficClass(dscpValue &lt;&lt; 2);\n            }\n            return connection;\n        }\n    }\n</code></pre>\n<p>HttpClient</p>\n<pre><code>CustomManagedHttpClientConnectionFactory customManagedHttpClientConnectionFactory = new CustomManagedHttpClientConnectionFactory(20));\nvar poolingmgrBuilder = PoolingHttpClientConnectionManagerBuilder.create();\npoolingmgrBuilder.setTlsSocketStrategy(buildCustomTlsStrategy());\npoolingmgrBuilder.setConnectionFactory(customManagedHttpClientConnectionFactory);\n\nvar poolingmgr = poolingmgrBuilder.build();\n\nHttpClientBuilder httpClientBuilder = HttpClientBuilder.create()\n                .setRedirectStrategy(DefaultRedirectStrategy.INSTANCE)\n                .setConnectionManager(poolingmgr);\nCloseableHttpClient httpClient = httpClientBuilder.build();\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}