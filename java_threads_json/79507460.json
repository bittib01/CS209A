{
  "question": {
    "tags": [
      "java",
      "algorithm"
    ],
    "owner": {
      "account_id": 31187804,
      "reputation": 794,
      "user_id": 23993901,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/7417aaad0c8ece3fac44f06d05a8ba8b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "CodeCrusader",
      "link": "https://stackoverflow.com/users/23993901/codecrusader"
    },
    "is_answered": true,
    "view_count": 475,
    "accepted_answer_id": 79507547,
    "answer_count": 1,
    "score": -4,
    "last_activity_date": 1746220897,
    "creation_date": 1741894711,
    "last_edit_date": 1746220897,
    "question_id": 79507460,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79507460/count-number-of-valid-substrings",
    "title": "Count number of valid substrings",
    "body": "<blockquote>\n<p>Given an input string contains letters from 'a' to 'g'</p>\n<p>Count how many substrings are there in the input string such that\nfrequency of any character inside the substring is not more than the\nnumber of distinct characters present in the substring.</p>\n<p>Example productSeq=&quot;abaa&quot; Output = 8</p>\n<p>Explanation: valid combinations are:</p>\n<p>a  b a a ab ba aba baa constraints:</p>\n<p>1 &lt;= input string length &lt;= 10^5 characters in input string are in\nrange a,b,c,d,e,f,g</p>\n</blockquote>\n<p>I tried using frequency array along with sliding window approach, but observed that with sliding window once we move forward on left index, we miss to count some valid substrings with higher length.</p>\n<p>Here is my code along with the expected outputs, but due to the issue I stated above, it fails to generate the correct output.</p>\n<pre><code>public class Main {\n        public static int solve(String str) {\n            int n = str.length();\n            int[] freq = new int[7]; // Frequency array for 'a' to 'g'\n            int left = 0, right = 0, distinct = 0, count = 0;\n    \n            while (right &lt; n) {\n                int rightChar = str.charAt(right) - 'a';\n                if (freq[rightChar] == 0) distinct++; // New character in window\n                freq[rightChar]++;\n    \n                // Ensure all character frequencies &lt;= distinct count\n                while (freq[rightChar] &gt; distinct) {\n                    int leftChar = str.charAt(left) - 'a';\n                    freq[leftChar]--;\n                    if (freq[leftChar] == 0) distinct--; // Removed a distinct character\n                    left++;\n                }\n    \n                // Count valid substrings ending at `right`\n                //System.out.println(left+&quot;:&quot;+right);\n                //count += (right - left + 1);\n                right++;\n            }\n    \n            return count;\n        }\n    \n        public static void main(String[] args) {\n            System.out.println(solve(&quot;abaa&quot;));  // Output: 8 \n            System.out.println(solve(&quot;abab&quot;));  // Output: 10\n            System.out.println(solve(&quot;aacd&quot;));  // Output: 9 \n\n        }\n\n    }\n</code></pre>\n<p>I have another idea about generating all possible substrings, also using hashmap that stores frequency of each character and then checking if they are valid or not that takes O(n<em>n</em>k) time complexity where n is size of input string, k is number of keys maintained in hashmap.</p>\n<p>But I want to solve this in less time complexity so tried the sliding window approach, but realised that it is not correct way to solve the problem.</p>\n<p>How can I solve this in less time complexity?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}