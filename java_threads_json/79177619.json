{
  "question": {
    "tags": [
      "java",
      "multithreading",
      "jetty",
      "java.util.concurrent",
      "thread-dump"
    ],
    "owner": {
      "account_id": 1340191,
      "reputation": 45,
      "user_id": 1282015,
      "user_type": "registered",
      "accept_rate": 100,
      "profile_image": "https://www.gravatar.com/avatar/0538e3b936bb975512fda8f68da3db1f?s=256&d=identicon&r=PG",
      "display_name": "Fabio Abreu",
      "link": "https://stackoverflow.com/users/1282015/fabio-abreu"
    },
    "is_answered": false,
    "view_count": 211,
    "answer_count": 0,
    "score": 1,
    "last_activity_date": 1732356075,
    "creation_date": 1731327270,
    "last_edit_date": 1731350703,
    "question_id": 79177619,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79177619/queued-thread-pool-high-cpu-usage",
    "title": "Queued Thread Pool High CPU Usage",
    "body": "<p>I have a Java process consuming upwards of 400% CPU on my server (AlmaLinux) which shouldnâ€™t be the case.\nOn my analysis I find multiple QTPs (Queued Thread Pools) consuming the CPU:</p>\n<p><a href=\"https://i.sstatic.net/nS7aT45P.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/nS7aT45P.png\" alt=\"QTP CPU USAGE\" /></a></p>\n<p>After analysing a Thread Dump and comparing the NIDs, the QTPs that are consuming CPU are in WAITING and TIMED_WAITING states, for example:</p>\n<p>This one is PID(NID) 3221507 which alone consumes 21%:</p>\n<pre><code>&quot;qtp737077247-58814&quot; #58814 prio=5 os_prio=0 tid=0x00007f60e0002000 nid=0x312803 runnable [0x00007f61125f0000]\n   java.lang.Thread.State: TIMED_WAITING (parking)\n    at sun.misc.Unsafe.park(Native Method)\n    - parking to wait for  &lt;0x00000000ed507048&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n    at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)\n    at org.eclipse.jetty.util.BlockingArrayQueue.poll(BlockingArrayQueue.java:392)\n    at org.eclipse.jetty.util.thread.QueuedThreadPool.idleJobPoll(QueuedThreadPool.java:546)\n    at org.eclipse.jetty.util.thread.QueuedThreadPool.access$800(QueuedThreadPool.java:47)\n    at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:609)\n    at java.lang.Thread.run(Thread.java:750)\n</code></pre>\n<p>And this one for example PID(NID) 3183314 which is eating 23%:</p>\n<pre><code>&quot;qtp737077247-58803&quot; #58803 prio=5 os_prio=0 tid=0x00007f60fc001800 nid=0x3092d2 waiting on condition [0x00007f61b1606000]\n   java.lang.Thread.State: WAITING (parking)\n    at sun.misc.Unsafe.park(Native Method)\n    - parking to wait for  &lt;0x00000000ed507028&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)\n    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:870)\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1199)\n    at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLock.java:209)\n    at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:285)\n    at org.eclipse.jetty.util.BlockingArrayQueue.offer(BlockingArrayQueue.java:302)\n    at org.eclipse.jetty.util.thread.QueuedThreadPool.execute(QueuedThreadPool.java:374)\n    at org.eclipse.jetty.util.thread.strategy.ExecuteProduceConsume.produceAndRun(ExecuteProduceConsume.java:207)\n    at org.eclipse.jetty.util.thread.strategy.ExecuteProduceConsume.run(ExecuteProduceConsume.java:147)\n    at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:654)\n    at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:572)\n    at java.lang.Thread.run(Thread.java:750)\n</code></pre>\n<p>Now I have no idea why a WAIT is eating so much CPU. I have seen <a href=\"https://stackoverflow.com/questions/18521183/jetty-9-hangs-queuedthreadpool-growing-large\">this question</a> but not much seems to help.</p>\n<p>An interesting point is that I have the same process running on other machines (Windows) that do not ever get to this point of CPU usage, keeping it to the normal, expected values.</p>\n<p>Any idea where I can steer my analysis here?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}