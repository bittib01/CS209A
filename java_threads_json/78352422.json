{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "unit-testing",
      "integration-testing",
      "spring-test"
    ],
    "owner": {
      "account_id": 26032801,
      "reputation": 43,
      "user_id": 19738740,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/5adc5ae16e07a2b7d5f42d19dbc7186f?s=256&d=identicon&r=PG",
      "display_name": "Misa",
      "link": "https://stackoverflow.com/users/19738740/misa"
    },
    "is_answered": false,
    "view_count": 861,
    "answer_count": 0,
    "score": 0,
    "last_activity_date": 1715086635,
    "creation_date": 1713516206,
    "last_edit_date": 1715086635,
    "question_id": 78352422,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78352422/the-bean-defined-in-class-path-resource-could-not-be-registered-a-bean-with-tha",
    "title": "The bean defined in class path resource could not be registered. A bean with that name has already been defined in URL and overriding is disabled",
    "body": "<p>I implemented a CustomCircuitBreakerFactory class to create separate circuitBreaker configs for my two APIs and have two beans in this class to create circuitbreaker instances.</p>\n<pre><code>@Component\npublic class CustomCircuitBreakerFactory {\n\n    private final ReactiveResilience4JCircuitBreakerFactory circuitBreakerFactory;\n    private final CircuitBreakerConfig api1CircuitBreakerConfig;\n    private final CircuitBreakerConfig api2CircuitBreakerConfig;\n\n    public CustomCircuitBreakerFactory(\n        ReactiveResilience4JCircuitBreakerFactory circuitBreakerFactory,\n        CircuitBreakerConfig api1CircuitBreakerConfig,\n        CircuitBreakerConfig api2CircuitBreakerConfig) {\n\n        circuitBreakerFactory.getCircuitBreakerRegistry().addConfiguration(&quot;api1&quot;, api1CircuitBreakerConfig);\n        circuitBreakerFactory.getCircuitBreakerRegistry().addConfiguration(&quot;api2&quot;, api2CircuitBreakerConfig);\n\n        this.circuitBreakerFactory = circuitBreakerFactory;\n        this.api1CircuitBreakerConfig = api1CircuitBreakerConfig;\n        this.api2CircuitBreakerConfig = api2CircuitBreakerConfig;\n    }\n\n    @Bean\n    public CircuitBreaker createApi1CircuitBreaker() {\n        return circuitBreakerFactory.getCircuitBreakerRegistry().circuitBreaker(&quot;api1&quot;,api1CircuitBreakerConfig);\n    }\n\n    @Bean\n    public CircuitBreaker createApi2CircuitBreaker() {\n        return circuitBreakerFactory.getCircuitBreakerRegistry().circuitBreaker(&quot;api2&quot;,api2CircuitBreakerConfig);\n    }\n</code></pre>\n<p>The config for circuitBreakrs are in application class like this and I have a bean to create an instance from circuitBreakerFactory:</p>\n<pre><code>@SpringBootApplication(scanBasePackages = {&quot;com.*&quot;})\npublic class ApiApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ApiFacadeApplication.class, args);\n    }\n\n    @Bean(&quot;api1CircuitBreakerConfig&quot;)\n    public CircuitBreakerConfig api1CircuitBreakerConfig() {\n\n        return CircuitBreakerConfig.custom()\n            .failureRateThreshold(50)\n            .waitDurationInOpenState(Duration.ofSeconds(10))\n            .permittedNumberOfCallsInHalfOpenState(10)\n            .slidingWindowSize(100)\n            .minimumNumberOfCalls(20)\n            .recordExceptions(RuntimeException.class, CallNotPermittedException.class)\n            .build();\n    }\n\n    @Bean(&quot;api2CircuitBreakerConfig&quot;)\n    public CircuitBreakerConfig api2CircuitBreakerConfig() {\n        return CircuitBreakerConfig.custom()\n            .failureRateThreshold(50)\n            .waitDurationInOpenState(Duration.ofSeconds(10))\n            .permittedNumberOfCallsInHalfOpenState(10)\n            .slidingWindowSize(100)\n            .minimumNumberOfCalls(20)\n            .recordExceptions(RuntimeException.class, CallNotPermittedException.class)\n            .build();\n\n    }\n\n    @Bean\n    public CustomCircuitBreakerFactory customCircuitBreakerFactory(\n        ReactiveResilience4JCircuitBreakerFactory circuitBreakerFactory,\n        @Qualifier(&quot;api1CircuitBreakerConfig&quot;) CircuitBreakerConfig api1CircuitBreakerConfig,\n        @Qualifier(&quot;api2CircuitBreakerConfig&quot;) CircuitBreakerConfig api2CircuitBreakerConfig) {\n        return new CustomCircuitBreakerFactory(circuitBreakerFactory, api1CircuitBreakerConfig, api2CircuitBreakerConfig);\n    }\n}\n</code></pre>\n<p>I used @CircuitBreaker to in my service like this:</p>\n<pre><code>@Service\npublic class Api1Search {\n\n    private static final String SERVICE_NAME = &quot;api1&quot;;\n\n    @Override\n    @CircuitBreaker(name = SERVICE_NAME, fallbackMethod = &quot;fallback&quot;)\n    public List&lt;String&gt; search(String input) {\n       // logic is implemented\n    }\n\n\n    public List&lt;String&gt; fallback(String input) {\n        // logic is implemented\n    }\n}\n\n\n\n@Service\npublic class Api2Search{\n\n    private static final String SERVICE_NAME = &quot;api2&quot;;\n\n    @Override\n    @CircuitBreaker(name = SERVICE_NAME, fallbackMethod = &quot;fallback&quot;)\n    public List&lt;String&gt; search(String input) {  \n       // logic is implemented\n    }\n\npublic List&lt;String&gt; fallback(String input) {\n        // logic is implemented\n    }\n}\n</code></pre>\n<p>and I create a Test class to test the service by circuit breaker:</p>\n<pre><code>@ActiveProfiles(&quot;test&quot;)\n@EnableAspectJAutoProxy\n@EnableTransactionManagement(proxyTargetClass = true)\n@SpringBootTest(classes = {TestClass.TestConfig.class, Api1Search .class, CustomCircuitBreakerFactory.class,\n    CircuitBreakerAutoConfiguration.class, CircuitBreakerAspect.class, CircuitBreakerProperties.class,\n    TimeLimiterConfiguration.class, TimeLimiterConfigurationProperties.class, ReactiveResilience4JAutoConfiguration.class,\n    Api2Search.class} ,properties = &quot;spring.main.allow-bean-definition-overriding=true&quot;)\npublic class TestClass {\n    \n    @Autowired\n    Api1Search api1Search;\n\n    @Autowired\n    @Qualifier(&quot;createApi1CircuitBreaker&quot;)\n    CircuitBreaker Api1CircuitBreaker;\n\n    @Autowired\n    CustomCircuitBreakerFactory customCircuitBreakerFactoryTest;\n\n    @Autowired\n    ReactiveResilience4JCircuitBreakerFactory reactiveResilience4JCircuitBreakerFactory;\n\n    @Autowired\n    CircuitBreakerRegistry circuitBreakerRegistry;\n\n    @Autowired\n    TimeLimiterConfiguration timeLimiterConfiguration;\n\n    @Autowired\n    ReactiveResilience4JAutoConfiguration reactiveResilience4JAutoConfiguration;\n\n    @Autowired\n    CircuitBreakerProperties circuitBreakerProperties;\n\n    @Autowired\n    CircuitBreakerAspect circuitBreakerAspect;\n\n    @Autowired\n    TimeLimiterConfigurationProperties timeLimiterConfigurationProperties;\n\n    @Autowired\n    Api2Search api2Search;\n\n    @Autowired\n    @Qualifier(&quot;createApi2CircuitBreaker&quot;)\n    CircuitBreaker api2CircuitBreaker;\n\n\n    @Test\n    void api1SearchWhenCircuitBreakerIsClosed() {\n        // logic is implemented\n    }\n\n   \n\n    @TestConfiguration\n    static class TestConfig {\n\n        @Bean(&quot;api1CircuitBreakerConfig&quot;)\n        public CircuitBreakerConfig api1CircuitBreakerConfig() {\n            return CircuitBreakerConfig.custom()\n                .failureRateThreshold(5)\n                .waitDurationInOpenState(Duration.ofSeconds(5))\n                .permittedNumberOfCallsInHalfOpenState(5)\n                .slidingWindowSize(5)\n                .minimumNumberOfCalls(10)\n                .recordExceptions(RuntimeException.class, CallNotPermittedException.class)\n                .build();\n        }\n\n        @Bean(&quot;api2CircuitBreakerConfig&quot;)\n        public CircuitBreakerConfig api2CircuitBreakerConfig() {\n            return CircuitBreakerConfig.custom()\n                .failureRateThreshold(5)\n                .waitDurationInOpenState(Duration.ofSeconds(5))\n                .permittedNumberOfCallsInHalfOpenState(5)\n                .slidingWindowSize(5)\n                .minimumNumberOfCalls(10)\n                .recordExceptions(RuntimeException.class, CallNotPermittedException.class)\n                .build();\n        }\n    }\n}\n\n</code></pre>\n<p>The <code>application.yml file</code> for application is:</p>\n<pre><code>spring:\n  main:\n    allow-bean-definition-overriding: true\n</code></pre>\n<p>and the <code>application-test.yaml</code> for test is:</p>\n<pre><code>spring:\n  main:\n    allow-bean-definition-overriding: true\n</code></pre>\n<p>When I run the test, it works properly, but when I run maven command: <code>mvn clean install</code> I got this error:</p>\n<pre><code>The bean CustomCircuitBreakerFactory  defined in class path resource [com/blahblah/blahblah/blahblah/ApiApplication.class], could not be registered. A bean with that name has already been defined in URL [jar:file:/C:/blahblah/blahblah/blahblah/blahblah/blahblah/blahblah/target/blahblah-1.16.0-SNAPSHOT.jar!/com/blahblah/blahblah/blahblah/CustomCircuitBreakerFactory .class] and overriding is disabled.\n</code></pre>\n<p>I enabled overriding and I got this error again. How can I resolve it.</p>\n<p><strong>New update:</strong></p>\n<p>I resolved this problem by removing <code>@Component</code> from <code>CustomCircuitBreakerFactory</code> Class.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}