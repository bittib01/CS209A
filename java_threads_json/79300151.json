{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "spring-security",
      "jwt",
      "cors"
    ],
    "owner": {
      "account_id": 38656606,
      "reputation": 11,
      "user_id": 28886170,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/e8b39849386cbec8248700b5f52d2dda?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Quenuo Real",
      "link": "https://stackoverflow.com/users/28886170/quenuo-real"
    },
    "is_answered": false,
    "view_count": 466,
    "answer_count": 1,
    "score": -1,
    "last_activity_date": 1735038749,
    "creation_date": 1734817094,
    "last_edit_date": 1734954651,
    "question_id": 79300151,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79300151/why-spring-security-is-rejecting-the-call-from-my-frontend",
    "title": "Why Spring Security is rejecting the call from my frontend?",
    "body": "<p>I am making a full stack application for my TFC, using Java with Spring Boot for the backend and Angular with the frontend. However, when making <code>GET</code> requests, Spring Boot security rejects my requests.</p>\n<p>These are the Spring Boot security logs that I get:</p>\n<pre><code>2024-12-23T12:42:44.562+01:00  INFO 14252 --- [nio-8080-exec-2] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'\n2024-12-23T12:42:44.562+01:00  INFO 14252 --- [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'\n2024-12-23T12:42:44.565+01:00  INFO 14252 --- [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : Completed initialization in 3 ms\n2024-12-23T12:42:44.594+01:00 DEBUG 14252 --- [nio-8080-exec-4] o.s.security.web.FilterChainProxy        : Securing GET /park/emergencies\n2024-12-23T12:42:44.594+01:00 DEBUG 14252 --- [nio-8080-exec-3] o.s.security.web.FilterChainProxy        : Securing GET /park/dinosaurs\n2024-12-23T12:42:44.594+01:00 DEBUG 14252 --- [nio-8080-exec-2] o.s.security.web.FilterChainProxy        : Securing GET /park/enclosures\n2024-12-23T12:42:44.595+01:00 DEBUG 14252 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy        : Securing GET /park/status\n2024-12-23T12:42:44.790+01:00 DEBUG 14252 --- [nio-8080-exec-2] o.s.s.w.a.Http403ForbiddenEntryPoint     : Pre-authenticated entry point called. Rejecting access\n2024-12-23T12:42:44.790+01:00 DEBUG 14252 --- [nio-8080-exec-4] o.s.s.w.a.Http403ForbiddenEntryPoint     : Pre-authenticated entry point called. Rejecting access\n2024-12-23T12:42:44.790+01:00 DEBUG 14252 --- [nio-8080-exec-1] o.s.s.w.a.Http403ForbiddenEntryPoint     : Pre-authenticated entry point called. Rejecting access\n2024-12-23T12:42:44.790+01:00 DEBUG 14252 --- [nio-8080-exec-3] o.s.s.w.a.Http403ForbiddenEntryPoint     : Pre-authenticated entry point called. Rejecting access\n2024-12-23T12:42:44.801+01:00 DEBUG 14252 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy        : Securing GET /error\n2024-12-23T12:42:44.801+01:00 DEBUG 14252 --- [nio-8080-exec-4] o.s.security.web.FilterChainProxy        : Securing GET /error\n2024-12-23T12:42:44.801+01:00 DEBUG 14252 --- [nio-8080-exec-2] o.s.security.web.FilterChainProxy        : Securing GET /error\n2024-12-23T12:42:44.801+01:00 DEBUG 14252 --- [nio-8080-exec-3] o.s.security.web.FilterChainProxy        : Securing GET /error\n2024-12-23T12:42:44.801+01:00 DEBUG 14252 --- [nio-8080-exec-1] o.s.s.w.a.Http403ForbiddenEntryPoint     : Pre-authenticated entry point called. Rejecting access\n2024-12-23T12:42:44.801+01:00 DEBUG 14252 --- [nio-8080-exec-4] o.s.s.w.a.Http403ForbiddenEntryPoint     : Pre-authenticated entry point called. Rejecting access\n2024-12-23T12:42:44.801+01:00 DEBUG 14252 --- [nio-8080-exec-2] o.s.s.w.a.Http403ForbiddenEntryPoint     : Pre-authenticated entry point called. Rejecting access\n2024-12-23T12:42:44.801+01:00 DEBUG 14252 --- [nio-8080-exec-3] o.s.s.w.a.Http403ForbiddenEntryPoint     : Pre-authenticated entry point called. Rejecting access\n2024-12-23T12:42:45.892+01:00 DEBUG 14252 --- [nio-8080-exec-5] o.s.security.web.FilterChainProxy        : Securing PUT /park/update\n2024-12-23T12:42:45.897+01:00 DEBUG 14252 --- [nio-8080-exec-5] o.s.s.w.a.Http403ForbiddenEntryPoint     : Pre-authenticated entry point called. Rejecting access\n2024-12-23T12:42:45.898+01:00 DEBUG 14252 --- [nio-8080-exec-5] o.s.security.web.FilterChainProxy        : Securing PUT /error\n2024-12-23T12:42:45.900+01:00 DEBUG 14252 --- [nio-8080-exec-5] o.s.s.w.a.Http403ForbiddenEntryPoint     : Pre-authenticated entry point called. Rejecting access\n</code></pre>\n<p>I have compared the two tokens, the frontend and the backend and they are the same so I don't know why they are rejecting my requests.</p>\n<p>This is the class where I configure the CORS:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    private final JwtFilter jwtFilter;\n\n    @Autowired\n    public SecurityConfig(JwtFilter jwtFilter){\n        this.jwtFilter=jwtFilter;\n    }\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http\n                .cors(Customizer.withDefaults())\n                .csrf(AbstractHttpConfigurer::disable)\n                .authorizeHttpRequests(auth -&gt; auth\n                        .requestMatchers(&quot;/auth/register&quot;, &quot;/auth/login&quot;).permitAll()\n                        .anyRequest().authenticated()\n                )\n                .anonymous(AbstractHttpConfigurer::disable)\n                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);\n        return http.build();\n    }\n\n    @Bean\n    public CorsConfigurationSource corsConfigurationSource() {\n        CorsConfiguration configuration = new CorsConfiguration();\n        configuration.setAllowedOrigins(List.of(&quot;http://localhost:4200&quot;));\n        configuration.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;));\n        configuration.setAllowedHeaders(List.of(&quot;Authorization&quot;, &quot;Content-Type&quot;, &quot;Accept&quot;));\n        configuration.setExposedHeaders(List.of(&quot;Authorization&quot;));\n        configuration.setMaxAge(3600L);\n        configuration.setAllowCredentials(true);\n\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(&quot;/**&quot;, configuration);\n        return source;\n    }\n</code></pre>\n<p>This is the <code>JwtFilter</code>:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Component\npublic class JwtFilter implements Filter {\n\n    private final JwtUtil jwtUtil;\n\n\n\n    @Autowired\n    public JwtFilter(JwtUtil jwtUtil){\n        this.jwtUtil=jwtUtil;\n    }\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n        String authHeader = httpRequest.getHeader(&quot;Authorization&quot;);\n//        System.out.println(authHeader+&quot; solicitud desde el fornted&quot;);\n\n          String path = httpRequest.getRequestURI();\n\n        if ( path.startsWith(&quot;/auth&quot;)) {\n            chain.doFilter(request, response);\n            return;\n        }\n        if (authHeader != null &amp;&amp; authHeader.startsWith(&quot;Bearer &quot;)) {\n            String token = authHeader.substring(7);\n            try {\n                String userId=jwtUtil.validateToken(token);\n                httpRequest.setAttribute(&quot;userId&quot;,userId);\n                System.out.println(&quot;Token válido. UserId extraído: &quot; + userId+&quot; token &quot;+authHeader);\n            } catch (Exception e) {\n                HttpServletResponse httpResponse = (HttpServletResponse) response;\n//                System.out.println(&quot;Error al validar el token de jwt filter &quot; + e.getMessage()+ &quot; &quot;+token);\n                httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, &quot;Token inválido&quot;);\n                return;\n            }\n        }\n\n        chain.doFilter(request, response);\n    }\n</code></pre>\n<p>And this is the class that I use to generate the token</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Component\npublic class JwtUtil {\n\n    @Value(&quot;${jwtKey}&quot;)\n    private String secretKey;\n\n    @Value(&quot;${jwtKeyExpiration}&quot;)\n    private long keyExpiration;\n\n    private Key key;\n\n    @PostConstruct\n    public void init() {\n        key = Keys.hmacShaKeyFor(secretKey.getBytes());\n    }\n    //genero un token con enlazado con el id del usuario mi key, que durara una 1 hora(despues el usuario\n    //Tendra que iniciar sesion de nuevo\n    public String generateToken(String userId) {\n        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();\n        return Jwts.builder()\n                .claims(claims)\n                .subject(userId)\n                .issuedAt(new Date())\n                .expiration(new Date(System.currentTimeMillis() + keyExpiration))\n                .signWith(key, SignatureAlgorithm.HS256)\n                .compact();\n    }\n\n    public String validateToken(String token) {\n        Claims claims = Jwts.parser()\n                .setSigningKey(key)\n                .build()\n                .parseSignedClaims(token)\n                .getPayload();\n        return claims.getSubject();\n    }\n}\n</code></pre>\n<p>What can I do to fix the 403 CORS errors?</p>\n<p>First I compared the tokens, and if the backend sent them correctly to the frontend at login, and if it was the same.\nI have also reviewed other posts on this site, about the securing error, and it has not worked for me.</p>\n<p>The CORS error that I get is:</p>\n<pre><code>Request URL:\nhttp://localhost:8080/park/update\nRequest Method:\nPUT\nStatus Code:\n403 Forbidden\nRemote Address:\n[::1]:8080\nReferrer Policy:\nstrict-origin-when-cross-origin\naccess-control-allow-credentials:\ntrue\naccess-control-allow-origin:\nhttp://localhost:4200\naccess-control-expose-headers:\nAuthorization\ncache-control:\nno-cache, no-store, max-age=0, must-revalidate\nconnection:\nkeep-alive\ncontent-length:\n0\ndate:\nMon, 23 Dec 2024 11:47:17 GMT\nexpires:\n0\nkeep-alive:\ntimeout=60\npragma:\nno-cache\nvary:\nOrigin\nvary:\nAccess-Control-Request-Method\nvary:\nAccess-Control-Request-Headers\nx-content-type-options:\nnosniff\nx-frame-options:\nDENY\nx-xss-protection:\n0\naccept:\napplication/json, text/plain, */*\naccept-encoding:\ngzip, deflate, br, zstd\naccept-language:\nes-ES,es;q=0.9\nauthorization:\nBearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxIiwiaWF0IjoxNzM0OTUzMTM0LCJleHAiOjE3MzQ5NTY3MzR9.x6VAuPFWyr2AaASPMO3Th7_6d7MDRyoEuwVdlxJf95U\nconnection:\nkeep-alive\ncontent-length:\n0\nhost:\nlocalhost:8080\norigin:\nhttp://localhost:4200\nreferer:\nhttp://localhost:4200/\nsec-ch-ua:\n&quot;Google Chrome&quot;;v=&quot;131&quot;, &quot;Chromium&quot;;v=&quot;131&quot;, &quot;Not_A Brand&quot;;v=&quot;24&quot;\nsec-ch-ua-mobile:\n?0\nsec-ch-ua-platform:\n&quot;Windows&quot;\nsec-fetch-dest:\nempty\nsec-fetch-mode:\ncors\nsec-fetch-site:\nsame-site\nuser-agent:\nMozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\n</code></pre>\n<p>This is the interceptor that I use in frontend:</p>\n<pre><code>    export const authInterceptor: HttpInterceptorFn = (req: HttpRequest&lt;any&gt;, next: HttpHandlerFn): Observable&lt;HttpEvent&lt;any&gt;&gt; =&gt; {\n  const token = localStorage.getItem('token');\n  console.log(&quot;El token es del fronted &quot;+token)\n  const clonedRequest = token\n    ? req.clone({\n        setHeaders: {\n          Authorization: `Bearer ${token}`,\n        },\n        withCredentials: true\n      })\n    : req.clone({ withCredentials: true });\n\n  return next(clonedRequest);\n};\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}