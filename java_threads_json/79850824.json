{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "asynchronous",
      "spring-websocket"
    ],
    "owner": {
      "account_id": 44931784,
      "reputation": 21,
      "user_id": 32011068,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/e30287b1a5e72b36641d45c2d3d27aab?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Laolu Ade OG CSR",
      "link": "https://stackoverflow.com/users/32011068/laolu-ade-og-csr"
    },
    "is_answered": false,
    "view_count": 43,
    "closed_date": 1766173163,
    "answer_count": 0,
    "score": -1,
    "last_activity_date": 1766117540,
    "creation_date": 1766117540,
    "question_id": 79850824,
    "link": "https://stackoverflow.com/questions/79850824/asynchronous-thread-is-not-able-to-obtain-updated-repository-information",
    "closed_reason": "Needs details or clarity",
    "title": "Asynchronous thread is not able to obtain updated repository information",
    "body": "<p>Application.properties</p>\n<pre><code>custom.async.executor.corePoolSize=3\ncustom.async.executor.maxPoolSize=5\ncustom.async.executor.queueCapacity=2\ncustom.async.executor.threadNamePrefix=serverAsyncThread-\n\ncustom.driver.socket=http://localhost:4444\ncustom.driver.timeoutSecs=3\n\ncustom.websocket.port=8080\ncustom.websocket.sendIntervalMilli=1000\n\ncustom.session.persistSecs=3\ncustom.session.checkIntervalMilli=2000\n\nserver.port=8080\nspring.application.name=archive-ingestion-server\nspring.threads.virtual.enabled=true\nspring.lifecycle.timeout-per-shutdown-phase=3s\n</code></pre>\n<p>Websocket configuration</p>\n<pre><code>@Configuration\n@EnableWebSocketMessageBroker\npublic class ServerWebsocketConfig implements WebSocketMessageBrokerConfigurer {\n    @Value(&quot;${custom.websocket.port:8080}&quot;)\n    private Integer port;\n\n    public void registerStompEndpoints(StompEndpointRegistry websocketRegistry) {\n        websocketRegistry.addEndpoint(&quot;/api/v1/websocket&quot;)\n                .setAllowedOriginPatterns(&quot;http://localhost:&quot; + this.port + &quot;*&quot;);\n    }\n\n    public void configureMessageBroker(MessageBrokerRegistry brokerRegistry) {\n        brokerRegistry.enableSimpleBroker(&quot;/api/v1/websocket/topic&quot;);\n        brokerRegistry.setApplicationDestinationPrefixes(&quot;/api/v1/websocket/app&quot;);\n    }\n}\n</code></pre>\n<p>Asynchronous configuration</p>\n<pre><code>@Bean(name = &quot;serverAsyncExecutor&quot;)\npublic Executor getAsyncExecutor()  {\n    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n    executor.setCorePoolSize(this.corePoolSize);\n    // Two additional thread for the session monitoring loop and driver creation\n    executor.setMaxPoolSize(this.maxPoolSize+2);\n    executor.setQueueCapacity(this.queueCapacity);\n    executor.setThreadNamePrefix(this.threadNamePrefix);\n    executor.initialize();\n    return executor;\n}\n\n@Bean\npublic AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {\n    return new ServerAsyncExceptionHandler();\n}\n</code></pre>\n<p>My issue is that the asynchronous thread I call to publish continous updates about an ongoing session is not working properly. I call the getSessionInformationLive() function through a REST api call to my controller, and in turn it sends back a confimation message and starts an asynchronous loop where, until the loop retrieves a response that has a finished flag set, publishes updates to my session at regular intervals.</p>\n<pre><code>@Async(&quot;serverAsyncExecutor&quot;)\npublic void runLiveSessionFeed(String sessionId) throws InterruptedException {\n    ServerResponseData responseData;\n    boolean sessionStillLive;\n    do {\n        // Get session entity information\n        Thread.sleep(this.sendIntervalMilli);\n        responseData = this.getSessionInformation(sessionId);\n\n        // Send response data\n        this.websocketTemplate.convertAndSend(&quot;/api/v1/websocket/topic/get-session-live&quot;, responseData);\n\n        // Log it\n        this.logService.createInfoLog(this.messageService.createWSSentMessage(sessionId, responseData.getResponseMessage()));\n\n        // Run a check to decide if to continue\n        boolean messageIsFail = responseData.getResponseMessage().equals(\n                this.messageService.getResponseGetSessionFailed()\n        );\n        boolean sessionComplete = responseData.isSessionFinished() || responseData.isSessionCanceled() ||\n                responseData.isSessionException();\n\n        sessionStillLive = !messageIsFail &amp;&amp; !sessionComplete;\n    } while (sessionStillLive);\n}\n\npublic ServerResponseData getSessionInformationLive(String sessionId) throws InterruptedException {\n    // Validate the session ID\n    boolean sessionIdValid = this.validateSessionId(sessionId);\n    if (!sessionIdValid) {\n        return new ServerResponseData(sessionId, this.messageService.getResponseBadSessionId());\n    }\n\n    // Start sending through websockets\n    this.runLiveSessionFeed(sessionId);\n\n    // Return the response\n    return new ServerResponseData(sessionId, this.messageService.getResponseNewSessionFeed());\n}\n</code></pre>\n<p>For further context, &quot;this.getSessionInformation(sessionId)&quot; calls a function that accesses an H2 database to retrieve the latest session information. This is used in this live variant of the function and as a response to it's own API endpoint. I tested the getSessionInformation function to made sure it still worked and it works perfectly fine when calling using the HTTP GET request as shown below:</p>\n<pre><code>2025-12-18T23:09:44.295-05:00  INFO 14472 --- [archive-ingestion-server] [erAsyncThread-2] c.l.i.ao3.services.ArchiveLogService     : Session service retrieved session 702f10fc1acd57577f728fd1a50537142ceda512b0acb108040689369970f11b.\n\n2025-12-18T23:09:44.296-05:00  INFO 14472 --- [archive-ingestion-server] [erAsyncThread-2] c.l.i.ao3.services.ArchiveLogService     : Session service updated last recorded message for session 702f10fc1acd57577f728fd1a50537142ceda512b0acb108040689369970f11b to: Added text -&gt; Not sure what she got this time, you go to where she was beside your home computer. She had managed to hook herself up by USB, resting against the table as she did everything through the USB. You look at the mouse and keyboard still on the counter, seeing the pointer icon zooming around on the screen by itself.\n\n2025-12-18T23:09:44.334-05:00  INFO 14472 --- [archive-ingestion-server] [           main] c.l.i.ao3.services.ArchiveLogService     : Session service retrieved session 702f10fc1acd57577f728fd1a50537142ceda512b0acb108040689369970f11b.\n\nResponse message -&gt; Added text -&gt; Not sure what she got this time, you go to where she was beside your home computer. She had managed to hook herself up by USB, resting against the table as she did everything through the USB. You look at the mouse and keyboard still on the counter, seeing the pointer icon zooming around on the screen by itself.\n\nOn update 9 for session ID 702f10fc1acd57577f728fd1a50537142ceda512b0acb108040689369970f11b...\n</code></pre>\n<p>What should I change so that I can do this for my websocket loop as well?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}