{
  "question": {
    "tags": [
      "java",
      "mongodb",
      "indexing",
      "time-series",
      "spring-data"
    ],
    "owner": {
      "account_id": 16351250,
      "reputation": 71,
      "user_id": 11809702,
      "user_type": "registered",
      "profile_image": "https://lh4.googleusercontent.com/-hnXo4FhKOrQ/AAAAAAAAAAI/AAAAAAAAAAA/ACHi3reiAEklkc-m1vH0Qw92CGBt3OmCig/s256-rj/photo.jpg",
      "display_name": "ben8622",
      "link": "https://stackoverflow.com/users/11809702/ben8622"
    },
    "is_answered": true,
    "view_count": 89,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1742784317,
    "creation_date": 1742510151,
    "last_edit_date": 1742559195,
    "question_id": 79524211,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79524211/mongodb-timeseries-query-not-using-index-and-taking-excessively-long",
    "title": "MongoDB Timeseries Query Not Using Index And Taking Excessively Long",
    "body": "<p>I have a large timeseries collection filled with millions of documents called &quot;Events&quot; that have the following structure</p>\n<pre><code>{\n  &quot;_id&quot;: {&quot;$oid&quot;: &quot;123456&quot;},\n  &quot;class&quot;: &quot;...&quot;,\n  &quot;event_data&quot;: {...},\n  &quot;ts&quot;: {&quot;$date&quot;: &quot;2025-01-01T01:00:00.000Z&quot;}\n}\n</code></pre>\n<p>With indexes on the <code>ts</code> field both ascending and descending. I am trying to run a query to pull the documents between two timestamps using Java. Like so:</p>\n<pre><code>ZonedDateTime lowerBound = ...;\nZonedDateTime upperBound = ...;\n\nvar query = Query.query(new Criteria().andOperator(\n  Criteria.where(&quot;ts&quot;).gte(lowerbound.toInstant().toEpochMilli()),\n  Criteria.where(&quot;ts&quot;).lt(upperbound.toInstant().toEpochMilli()),\n)\n\nvar result = mongoTemplate.find(query, Events.class)\n</code></pre>\n<p>This query works... eventually after like 20 minutes since it scans the entire collections not using the indexes. When I use IntelliJ's debugger I can see the query getting formatted as follows:</p>\n<pre><code>Query: { &quot;$and&quot; : [{ &quot;ts&quot;: { &quot;$gte&quot; : 1733852133000}}. { &quot;ts&quot; : { &quot;$lt&quot;: 1733853933000}} ] }\n</code></pre>\n<p>Which I translate into the MongoDB console's code as such:</p>\n<pre><code>db.events.find({\n  &quot;$and&quot;: [\n    { &quot;ts&quot;: { &quot;$gte&quot;: 1733852133000}},\n    { &quot;ts&quot;: { &quot;$lt&quot;: 1733853933000}},\n  ]\n})\n</code></pre>\n<p>Running this mimics what is happening in the Java code exactly, it technically works but is scanning the entire collection, which I can further see if a do a <code>.explain()</code> and only see the <code>COLLSCAN</code> stage.</p>\n<p>However, if I write the following snippet, the code executes in under a couple seconds:</p>\n<pre><code>db.events.find({\n  &quot;$and&quot;: [\n    { &quot;ts&quot;: { &quot;$gte&quot;: new Date(&quot;2025-01-01T01:00:00Z)}},\n    { &quot;ts&quot;: { &quot;$lt&quot;: new Date(&quot;2025-01-02T01:00:00Z)}},\n  ]\n})\n</code></pre>\n<p>Which also matches up when I run <code>.explain()</code> since I can see the <code>FETCH</code> and <code>IXSCAN</code> stages.</p>\n<p><strong>What is the underlying difference between these two queries? How can I get my Java code to translate into the second version and actually make use of the indexing we have in place?</strong></p>\n<p>Some things I have tried:</p>\n<ol>\n<li>Using <code>Instant</code> or <code>Date</code> instead of <code>Long</code> as the values, these just have the same issue of doing a <code>COLSCAN</code></li>\n<li>Adding a <code>hint(&quot;ts_1&quot;)</code> to force the usage of an index. When running this in the MongoDB console it errors out with <code>hint provided does not correspond to an existing index</code> which is completely false since I can see the index when running <code>.getIndexes()</code>. Running it in Java code seems to have the same issue as before where it does a <code>COLLSCAN</code></li>\n</ol>\n<h3>Edit 3/21/25</h3>\n<p>Here are some more details of what is going on. First just to show the indexes do exists:</p>\n<pre><code>db.events.getIndexes();\n\n// returns\n{\n    &quot;key&quot;: {\n      &quot;ts&quot;: 1\n    },\n    &quot;name&quot;: &quot;ts_1&quot;,\n    &quot;v&quot;: 2\n  },\n  {\n    &quot;key&quot;: {\n      &quot;ts&quot;: -1\n    },\n    &quot;name&quot;: &quot;ts_-1&quot;,\n    &quot;v&quot;: 2\n  }\n</code></pre>\n<p>Then the stages from <code>.explain()</code> on the <strong>working</strong> query (<em>I have stripped out some details</em>):</p>\n<pre><code>db.events.find({\n    &quot;$and&quot;: [\n        { &quot;ts&quot;: { &quot;$gte&quot;: new Date(&quot;2024-12-10T17:35:33Z&quot;)} },\n        { &quot;ts&quot;: { &quot;$lt&quot;: new Date(&quot;2024-12-10T18:05:33Z&quot;)} }\n    ],\n}, {}, {}).explain();\n\n// returns\n{\n ...\n &quot;stages&quot;: [\n      {\n        &quot;$cursor&quot;: {\n          &quot;queryPlanner&quot;: {\n            &quot;namespace&quot;: &quot;database.system.buckets.events&quot;,\n            &quot;indexFilterSet&quot;: false,\n            &quot;parsedQuery&quot;: {\n              &quot;$and&quot;: [\n                {\n                  &quot;_id&quot;: {\n                    &quot;$lt&quot;: {&quot;$oid&quot;: &quot;675882ed0000000000000000&quot;}\n                  }\n                },\n                {\n                  &quot;_id&quot;: {\n                    &quot;$gte&quot;: {&quot;$oid&quot;: &quot;67572a650000000000000000&quot;}\n                  }\n                },\n                {\n                  &quot;control.max.ts&quot;: {\n                    &quot;$_internalExprGte&quot;: {&quot;$date&quot;: &quot;2024-12-10T17:35:33.000Z&quot;}\n                  }\n                },\n                {\n                  &quot;control.min.ts&quot;: {\n                    &quot;$_internalExprGte&quot;: {&quot;$date&quot;: &quot;2024-12-09T17:35:33.000Z&quot;}\n                  }\n                },\n                {\n                  &quot;control.max.ts&quot;: {\n                    &quot;$_internalExprLt&quot;: {&quot;$date&quot;: &quot;2024-12-11T18:05:33.000Z&quot;}\n                  }\n                },\n                {\n                  &quot;control.min.ts&quot;: {\n                    &quot;$_internalExprLt&quot;: {&quot;$date&quot;: &quot;2024-12-10T18:05:33.000Z&quot;}\n                  }\n                }\n              ]\n            },\n            \n            ...\n\n            &quot;winningPlan&quot;: {\n              &quot;stage&quot;: &quot;FETCH&quot;,\n              &quot;filter&quot;: {\n                &quot;$and&quot;: [\n                  {\n                    &quot;_id&quot;: {\n                      &quot;$lt&quot;: {&quot;$oid&quot;: &quot;675882ed0000000000000000&quot;}\n                    }\n                  },\n                  {\n                    &quot;_id&quot;: {\n                      &quot;$gte&quot;: {&quot;$oid&quot;: &quot;67572a650000000000000000&quot;}\n                    }\n                  }\n                ]\n              },\n              &quot;inputStage&quot;: {\n                &quot;stage&quot;: &quot;IXSCAN&quot;,\n                &quot;keyPattern&quot;: {\n                  &quot;control.min.ts&quot;: 1,\n                  &quot;control.max.ts&quot;: 1\n                },\n                &quot;indexName&quot;: &quot;ts_1&quot;,\n                &quot;isMultiKey&quot;: false,\n                &quot;multiKeyPaths&quot;: {\n                  &quot;control.min.ts&quot;: [],\n                  &quot;control.max.ts&quot;: []\n                },\n                &quot;isUnique&quot;: false,\n                &quot;isSparse&quot;: false,\n                &quot;isPartial&quot;: false,\n                &quot;indexVersion&quot;: 2,\n                &quot;direction&quot;: &quot;forward&quot;,\n                &quot;indexBounds&quot;: {\n                  &quot;control.min.ts&quot;: [&quot;[new Date(1733765733000), new Date(1733853933000))&quot;],\n                  &quot;control.max.ts&quot;: [&quot;[new Date(1733852133000), new Date(1733940333000))&quot;]\n                }\n              }\n            }\n}\n\n</code></pre>\n<p>And the stages from <code>.explain()</code> on the <strong>non-working</strong> query (<em>also stripped out some details</em>):</p>\n<pre><code>db.events.find({\n    $and: [\n        { ts: { $gte: 1733852133000 } },\n        { ts: { $lt: 1733853933000 } }\n    ],\n}, {}, {})\n\n// returns\n{\n...\n&quot;stages&quot;: [\n      {\n        &quot;$cursor&quot;: {\n          &quot;queryPlanner&quot;: {\n            &quot;namespace&quot;: &quot;db.system.buckets.events&quot;,\n            &quot;indexFilterSet&quot;: false,\n            &quot;parsedQuery&quot;: {\n            },\n            &quot;queryHash&quot;: &quot;5F5FC979&quot;,\n            &quot;planCacheKey&quot;: &quot;5F5FC979&quot;,\n            &quot;maxIndexedOrSolutionsReached&quot;: false,\n            &quot;maxIndexedAndSolutionsReached&quot;: false,\n            &quot;maxScansToExplodeReached&quot;: false,\n            &quot;winningPlan&quot;: {\n              &quot;stage&quot;: &quot;COLLSCAN&quot;,\n              &quot;direction&quot;: &quot;forward&quot;\n            },\n            &quot;rejectedPlans&quot;: []\n          }\n        }\n      },\n      {\n        &quot;$_internalUnpackBucket&quot;: {\n          &quot;exclude&quot;: [],\n          &quot;timeField&quot;: &quot;ts&quot;,\n          &quot;metaField&quot;: &quot;data&quot;,\n          &quot;bucketMaxSpanSeconds&quot;: 86400,\n          &quot;assumeNoMixedSchemaData&quot;: true,\n          &quot;eventFilter&quot;: {\n            &quot;$and&quot;: [\n              {\n                &quot;ts&quot;: {\n                  &quot;$gte&quot;: 1733852133000\n                }\n              },\n              {\n                &quot;ts&quot;: {\n                  &quot;$lt&quot;: 1733853933000\n                }\n              }\n            ]\n          }\n        }\n      }\n    ]\n}\n</code></pre>\n<p>Finally here is the Java Query object's value which is how I am deriving the above MongoDB query:</p>\n<pre><code>Query: { &quot;$and&quot; : [{ &quot;ts&quot; : { &quot;$gte&quot; : 1733852133000}}, { &quot;ts&quot; : { &quot;$lt&quot; : 1733853933000}}]}, Fields: {}, Sort: {}\n</code></pre>\n<p>Even if I used <code>$date</code> instead of the epoch milli for the filters the results are the same.</p>\n<p>From these explain comments we can see the large difference between the two where the working one with <code>new Date()</code> is adding additional filtering on the <code>_id</code> column I am assuming this has something to do with how time series collections work but am not sure. In addition to that the filters get broken down and there is the <code>IXSCAN</code> input stage before the <code>FETCH</code>.</p>\n<p>I have found another question on the MongoDB Forum that is extremely similar but with no real answer on to what is going on.. <a href=\"https://www.mongodb.com/community/forums/t/mongotemplate-and-isodate/9544/5\" rel=\"nofollow noreferrer\">link</a></p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}