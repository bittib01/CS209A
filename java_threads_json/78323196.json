{
  "question": {
    "tags": [
      "java",
      "spring",
      "spring-webflux",
      "load-balancing",
      "spring-webclient"
    ],
    "owner": {
      "account_id": 13749644,
      "reputation": 13,
      "user_id": 20459630,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/e41396543851a59686ac5aee7f1c7ad9?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Vincent Schiller",
      "link": "https://stackoverflow.com/users/20459630/vincent-schiller"
    },
    "is_answered": false,
    "view_count": 726,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1725506491,
    "creation_date": 1713083679,
    "question_id": 78323196,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78323196/configuring-spring-webclient-with-spring-cloud-loadbalancer-resolving-role-ser",
    "title": "Configuring Spring WebClient with Spring Cloud LoadBalancer: Resolving &#39;ROLE-SERVICE&#39; Endpoint Issue",
    "body": "<p>I'm currently seeking a web client solution for my Spring Boot application, which needs to establish connections with my microservices. The application is configured to utilize Eureka service discovery and requires load balancing capabilities via Spring Cloud LoadBalancer.</p>\n<p>However, I'm encountering some confusion regarding the handling of Spring Cloud LoadBalancer. Below, I've outlined my configuration for multiple web clients:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Configuration\n@LoadBalancerClients({\n    @LoadBalancerClient(name = &quot;ROLE-SERVICE&quot;, configuration = LoadBalancerConfiguration.class),\n    @LoadBalancerClient(name = &quot;USER-SERVICE&quot;, configuration = LoadBalancerConfiguration.class)\n})\npublic class WebClientConfig {    \n\n    @Bean\n    @LoadBalanced\n    public WebClient webClientUserService() {\n        return WebClient\n                .builder()\n                .baseUrl(&quot;http://USER-SERVICE&quot;)\n                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)\n                .build();\n    }\n\n    @Bean\n    @LoadBalanced\n    public WebClient webClientRoleService() {\n        return WebClient\n                .builder()\n                .baseUrl(&quot;http://ROLE-SERVICE&quot;)\n                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)\n                .build();\n    }\n}\n</code></pre>\n<p>My <code>LoadBalancerConfiguration</code> looks like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Configuration\npublic class LoadBalancerConfiguration {\n\n    @Bean\n    public ServiceInstanceListSupplier discoveryClientServiceInstanceListSupplier(\n            ConfigurableApplicationContext context) {\n        return ServiceInstanceListSupplier.builder()\n                .withDiscoveryClient()\n                .withSameInstancePreference()                \n                .build(context);\n    }\n}\n</code></pre>\n<p>In my business logic, I utilize the WebClient as follows:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Service\n@RequiredArgsConstructor\npublic class ShopService {\n\n    private final WebClient webClientRoleService;    \n\n    @Value(&quot;${messages.default-error-message}&quot;)\n    private String DEFAULT_ERROR_MESSAGE;\n\n    Gson gson = new Gson();\n   \n    public Mono&lt;ChatMessage&gt; sendMessage(\n            ChatMessage userMessage,\n            String iss) {\n\n        return webClientRoleService\n                .get()\n                .uri(&quot;/roles&quot;)\n                .header(&quot;iss&quot;, iss)\n                .header(&quot;userID&quot;, userMessage.getUserID())\n                .accept(MediaType.APPLICATION_JSON)\n                .retrieve()\n                .bodyToMono(String.class);                \n    }\n}\n</code></pre>\n<p>In some tutorials, I noticed that the URL is created with <code>webClient.uri(&quot;http://ROLE-SERVICE/roles&quot;)</code>. However, I prefer setting the BaseURL in my WebClient configuration because I require a different configuration for testing in my JUnit tests.</p>\n<p>The instances of my microservices are correctly displayed in the admin panel of Eureka:</p>\n<pre class=\"lang-yaml prettyprint-override\"><code>eureka:\n  instance:\n    instance-id: ${spring.application.name}:${random.uuid}\n    prefer-ip-address: true\n  client:\n    healthcheck:\n      enabled: false\n    service-url:\n      defaultZone: http://localhost:8761/eureka\n    fetch-registry: true\n    register-with-eureka: true\n</code></pre>\n<p>When I execute my code, I encounter an error stating that &quot;ROLE-SERVICE&quot; could not be resolved. What am I doing wrong here?</p>\n<pre><code>2024-04-14T10:27:01.634+02:00 ERROR 12932 --- [kosmo-backend] [nio-8088-exec-2] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: org.springframework.web.reactive.function.client.WebClientRequestException: Failed to resolve 'ROLE-SERVICE' [A(1), AAAA(28)] after 6 queries ] with root cause\n\njava.net.UnknownHostException: Failed to resolve 'ROLE-SERVICE' [A(1), AAAA(28)] after 6 queries \n    at io.netty.resolver.dns.DnsResolveContext.finishResolve(DnsResolveContext.java:1120) ~[netty-resolver-dns-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.resolver.dns.DnsResolveContext.tryToFinishResolve(DnsResolveContext.java:1067) ~[netty-resolver-dns-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.resolver.dns.DnsResolveContext.query(DnsResolveContext.java:440) ~[netty-resolver-dns-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.resolver.dns.DnsResolveContext.onResponse(DnsResolveContext.java:670) ~[netty-resolver-dns-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.resolver.dns.DnsResolveContext.access$500(DnsResolveContext.java:68) ~[netty-resolver-dns-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.resolver.dns.DnsResolveContext$2.operationComplete(DnsResolveContext.java:497) ~[netty-resolver-dns-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:590) ~[netty-common-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:583) ~[netty-common-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:559) ~[netty-common-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:492) ~[netty-common-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:636) ~[netty-common-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:625) ~[netty-common-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:105) ~[netty-common-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.resolver.dns.DnsQueryContext.trySuccess(DnsQueryContext.java:338) ~[netty-resolver-dns-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.resolver.dns.DnsQueryContext.finishSuccess(DnsQueryContext.java:329) ~[netty-resolver-dns-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.resolver.dns.DnsNameResolver$DnsResponseHandler.channelRead(DnsNameResolver.java:1387) ~[netty-resolver-dns-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444) ~[netty-transport-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) ~[netty-transport-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412) ~[netty-transport-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103) ~[netty-codec-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444) ~[netty-transport-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) ~[netty-transport-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412) ~[netty-transport-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440) ~[netty-transport-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) ~[netty-transport-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe.read(AbstractNioMessageChannel.java:97) ~[netty-transport-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788) ~[netty-transport-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724) ~[netty-transport-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650) ~[netty-transport-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562) ~[netty-transport-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997) ~[netty-common-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.105.Final.jar:4.1.105.Final]\n    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.105.Final.jar:4.1.105.Final]\n    at java.base/java.lang.Thread.run(Thread.java:840) ~[na:na]\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}