{
  "question": {
    "tags": [
      "java",
      "hibernate",
      "jpa",
      "enums"
    ],
    "owner": {
      "account_id": 24265481,
      "reputation": 28,
      "user_id": 18214445,
      "user_type": "registered",
      "profile_image": "https://lh3.googleusercontent.com/a-/AOh14GiouJXZZh3ATFuqFaCdFcNS8gykO6ODkHiolfAPMBw=k-s256",
      "display_name": "Rishabh Rastogi",
      "link": "https://stackoverflow.com/users/18214445/rishabh-rastogi"
    },
    "is_answered": true,
    "view_count": 136,
    "closed_date": 1757247333,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1757319700,
    "creation_date": 1757150635,
    "last_edit_date": 1757319700,
    "question_id": 79757452,
    "link": "https://stackoverflow.com/questions/79757452/what-is-the-correct-approach-to-use-enums-in-database-with-jpa",
    "closed_reason": "Opinion-based",
    "title": "What is the correct approach to use Enums in Database with JPA?",
    "body": "<p>I am working on a Spring Boot + JPA application, and I am confused about the best practice for persisting enums in the database.</p>\n<p>Let’s say I have the following enum in Java:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public enum SellerStatus {\n    PENDING_REVIEW,\n    APPROVED,\n    REJECTED;\n}\n</code></pre>\n<hr />\n<p><strong>Approach 1:</strong> Using <code>@Enumerated(EnumType.STRING)</code></p>\n<pre class=\"lang-java prettyprint-override\"><code>@Entity\npublic class Seller {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(name = &quot;status&quot;)\n    @Enumerated(EnumType.STRING)\n    private SellerStatus status;\n\n    // getters/setters\n}\n</code></pre>\n<p>This stores the enum as a <code>VARCHAR</code> column in the DB. It’s simple and works well, but it has issues:</p>\n<ul>\n<li><p>Storage overhead (storing long strings instead of small ids).</p>\n</li>\n<li><p>If I rename an enum constant (<code>APPROVED</code> → <code>ACCEPTED</code>, <code>REJECTED</code> → <code>DELETED</code>) when the table has millions of rows, updating the DB will be painful.</p>\n</li>\n</ul>\n<p><strong>Approach 2</strong>: Using a lookup table for enum values</p>\n<p>I could also create a separate <code>SellerStatus</code> table in the DB:</p>\n<p>Table: <code>seller_status</code></p>\n<pre class=\"lang-sql prettyprint-override\"><code>id   |   name\n--------------------\n1    | PENDING_REVIEW\n2    | APPROVED\n3    | REJECTED\n</code></pre>\n<p>And then reference it in the <code>seller</code> table as a foreign key:</p>\n<pre class=\"lang-sql prettyprint-override\"><code>seller\n---------\nid | name | status_id\n</code></pre>\n<p>Now in Java, I can map like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Entity\npublic class Seller {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = &quot;status_id&quot;)\n    private SellerStatusEntity status;\n}\n</code></pre>\n<p>But here, <code>SellerStatusEntity</code> becomes an entity, not an enum. It feels wrong since these values are fixed and rarely change. Also, this adds an extra join query.</p>\n<p><strong>Approach 3</strong>: Enum with IDs and <code>@Converter</code></p>\n<p>Another idea is to keep the enum in Java but assign IDs that match the DB table:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Getter\n@AllArgsConstructor\npublic enum SellerStatus {\n    PENDING_REVIEW(1),\n    APPROVED(2),\n    REJECTED(3);\n\n    private final int id;\n}\n\n</code></pre>\n<p>Then use a custom JPA <code>@Converter</code> to map between enum and integer in the DB:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Converter(autoApply = true)\npublic class SellerStatusConverter implements AttributeConverter&lt;SellerStatus, Integer&gt; {\n\n    @Override\n    public Integer convertToDatabaseColumn(SellerStatus status) {\n        return status != null ? status.getId() : null;\n    }\n\n    @Override\n    public SellerStatus convertToEntityAttribute(Integer dbData) {\n        return Arrays.stream(SellerStatus.values())\n                     .filter(s -&gt; s.getId() == dbData)\n                     .findFirst()\n                     .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Unknown status id: &quot; + dbData));\n    }\n}\n\n</code></pre>\n<p>This way:</p>\n<ul>\n<li><p>DB stays normalized (integer column with foreign key to lookup table).</p>\n</li>\n<li><p>Java code still uses enums.</p>\n</li>\n<li><p>But whenever I add a new enum constant, I also need to update the DB table manually.</p>\n</li>\n</ul>\n<hr />\n<p><strong>My Question:</strong></p>\n<p>Out of these approaches, which one is best practice in real-world applications with large datasets?</p>\n<ul>\n<li><p>Should I just stick with <code>@Enumerated(EnumType.STRING)</code> and accept rename/update issues?</p>\n</li>\n<li><p>Or is maintaining a lookup table + <code>@Converter</code> the right approach even if it adds some DB management overhead?</p>\n</li>\n<li><p>Is there a cleaner pattern for handling enums in JPA that avoids both extra joins and painful renames?</p>\n</li>\n</ul>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}