{
  "question": {
    "tags": [
      "java",
      "autocloseable"
    ],
    "owner": {
      "account_id": 1927984,
      "reputation": 753,
      "user_id": 1738007,
      "user_type": "registered",
      "profile_image": "https://i.sstatic.net/PqYoh.jpg?s=256",
      "display_name": "Tugalsan Karabacak",
      "link": "https://stackoverflow.com/users/1738007/tugalsan-karabacak"
    },
    "is_answered": true,
    "view_count": 204,
    "accepted_answer_id": 78030659,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1737872456,
    "creation_date": 1705323780,
    "last_edit_date": 1708500781,
    "question_id": 77819961,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/77819961/how-to-run-parallel-tasks-in-a-for-loop-for-dealing-with-autocloseable-files-in",
    "title": "How to run parallel tasks in a for loop, for dealing with AutoCloseable files in Java",
    "body": "<p><b>MOTIVATION</b><br>\nOn a youtube video of Venkat Subramaniam, he tells about how not use AutoCloseable, but try to use a function like &quot;use&quot;. Because, one may forget to implement try block on a class which implements AutoCloseable.</p>\n<p><b>QUESTION</b><br>\nI have implemented this strategy on many cases, however there is one case that I could not able to. <br>\n<br>\nI have many file writers according to their file types. All of them uses same interface. So main macro code can be parsed and file actions can be processed for every kind of file types. (on the blog, I have reduced the function names to only &quot;addText&quot; and file-types as 2: &quot;FileWeb&quot; and &quot;FileTable&quot;.)<br>\n<br>\nAnd, users decides which type of files they want on everytime.<br></p>\n<p>The sequencial way of doing is as below. (There, in function &quot;constructFileAccordingToMacroCode&quot;, &quot;the parsing of macrocode line by line&quot; is processed twice).</p>\n<pre><code>{//SEQUENTIAL\n  boolean produceFileTable = true;\n  if (produceFileTable) {\n    FileTable.use(dir, fileLabel, fileTable -&gt; {\n      constructFileAccordingToMacroCode(macroCode, fileTable);\n    });\n  }\n\n  boolean produceFileWeb = true;\n  if (produceFileWeb) {\n    FileWeb.use(dir, fileLabel, fileWeb -&gt; {\n      constructFileAccordingToMacroCode(macroCode, fileWeb);\n    });\n  }\n}\n</code></pre>\n<p>Kind of parallel way of doing is as below. (There, the function &quot;constructFileAccordingToMacroCode&quot; runs once, hence, &quot;the parsing of macrocode line by line&quot; is processed once).</p>\n<pre><code>{//KIND OF PARALLEL\n  boolean produceFileTable = true;//?\n  boolean produceFileWeb = true;//?\n  FileTable.use(dir, fileLabel, fileTable -&gt; {\n    FileWeb.use(dir, fileLabel, fileWeb -&gt; {\n      constructFileAccordingToMacroCode(macroCode, fileTable, fileWeb);\n    });\n  });\n}\n</code></pre>\n<p>However, If I am gonna implement it, I will lose the option of not creating the unwanted file types.</p>\n<p>Is there more smart way of doing things?</p>\n<p><b>RELEVANT EXAMPLE CLASS FILES</b> <br>\n<br></p>\n<p><b>Main</b><br></p>\n<pre><code>public class Main {\n    public static void main(String... s) {\n        var macroCode = &quot;&quot;&quot;\n                        LINE1: ADD_FILE_TYPE\n                        LINE2: ADD_SYSTEM_MILLIS\n                        &quot;&quot;&quot;;\n        var dir = Path.of(&quot;c:\\\\fileFirectory&quot;);\n        var fileLabel = &quot;fileLabel&quot;;\n\n        {//SEQUENTIAL\n            boolean produceFileTable = true;\n            if (produceFileTable) {\n                FileTable.use(dir, fileLabel, fileTable -&gt; {\n                    constructFileAccordingToMacroCode(macroCode, fileTable);\n                });\n            }\n\n            boolean produceFileWeb = true;\n            if (produceFileWeb) {\n                FileWeb.use(dir, fileLabel, fileWeb -&gt; {\n                    constructFileAccordingToMacroCode(macroCode, fileWeb);\n                });\n            }\n        }\n\n        {//KIND OF PARALLEL\n            boolean produceFileTable = true;//?\n            boolean produceFileWeb = true;//?\n            FileTable.use(dir, fileLabel, fileTable -&gt; {\n                FileWeb.use(dir, fileLabel, fileWeb -&gt; {\n                    constructFileAccordingToMacroCode(macroCode, fileTable, fileWeb);\n                });\n            });\n        }\n    }\n\n    private static boolean constructFileAccordingToMacroCode(String macroCode, FileInterface... files) {\n        boolean result;\n        for (var file : files) {\n            //parse macroCode line by line in a for loop {\n                /*FOREXAMPLE LINE1: from macroCode*/\n                result = file.addText(&quot;I am a %s type file.&quot;.formatted(file.getClass().getSimpleName()));\n                if (!result) {\n                    return false;\n                }\n                /*FOREXAMPLE LINE2: from macroCode*/\n                file.addText(&quot;, and time is %L&quot;.formatted(System.currentTimeMillis()));\n                if (!result) {\n                    return false;\n                }\n            //}\n        }\n        return true;\n    }\n}\n</code></pre>\n<br>\n<p><b>TGS_RunnableType1</b><br></p>\n<pre><code>public interface TGS_RunnableType1&lt;A&gt; {\n    public void run(A result);\n}\n</code></pre>\n<br>\n<p><b>FileInterface</b><br></p>\n<pre><code>public interface FileInterface /*implements AutoCloseable*/{\n    public boolean addText(CharSequence text);\n}\n</code></pre>\n<br>\n<p><b>FileTable </b><br></p>\n<pre><code>public class FileTable implements FileInterface {\n\n    private FileTable(Path dir) {\n        this.dir = dir;\n    }\n    final public Path dir;\n\n    @Override\n    public boolean addText(CharSequence text) {\n        //TODO add text code\n        return true;\n    }\n\n    public static void use(Path dir, String fileLabel, TGS_RunnableType1&lt;FileTable&gt; fileTable) {\n        var instance = new FileTable(dir);\n        try {\n            instance.open();\n            fileTable.run(instance);\n            instance.close();\n        } catch (Exception e) {//SILENTLY CLOSE\n            try {\n                instance.close();\n            } catch (Exception e2) {\n                if (e2 instanceof InterruptedException) {//let InterruptedException propagate\n                    throw e2;\n                }\n            }\n            if (e instanceof InterruptedException) {//let InterruptedException propagate\n                throw e;\n            }\n        }\n    }\n\n    private void open() {\n        //open according to dir &amp; fileLabel &amp; type\n    }\n\n    private void close() {\n        //close according to dir &amp; fileLabel &amp; type\n    }\n}\n</code></pre>\n<br>\n<p><b>FileWeb </b><br></p>\n<pre><code>public class FileWeb implements FileInterface {\n\n    private FileWeb(Path dir) {\n        this.dir = dir;\n    }\n    final public Path dir;\n\n    @Override\n    public boolean addText(CharSequence text) {\n        //TODO add text code\n        return true;\n    }\n\n    public static void use(Path dir, String fileLabel, TGS_RunnableType1&lt;FileWeb&gt; fileWeb) {\n        var instance = new FileWeb(dir);\n        try {\n            instance.open();\n            fileWeb.run(instance);\n            instance.close();\n        } catch (Exception e) {//SILENTLY CLOSE\n            try {\n                instance.close();\n            } catch (Exception e2) {\n                if (e2 instanceof InterruptedException) {//let InterruptedException propagate\n                    throw e2;\n                }\n            }\n            if (e instanceof InterruptedException) {//let InterruptedException propagate\n                throw e;\n            }\n        }\n    }\n\n    private void open() {\n        //open according to dir &amp; fileLabel &amp; type\n    }\n\n    private void close() {\n        //close according to dir &amp; fileLabel &amp; type\n    }\n</code></pre>\n<br>\n<br>\n<br>\n<br>\n<b>------------------------- UPDATE ----------------<br></b>\n<b>PARALLEL VERSION OF constructFileAccordingToMacroCode</b>\n<pre><code>    //WILL POSSIBLY CREATE OUT OF MEMORY ERROR\n    private static boolean constructFileAccordingToMacroCode(String macroCode, FileInterface... files) {\n        //parse macroCode line by line in a for loop {\n            var errorPresent = IntStream.range(0, files.length).parallel()\n                    .mapToObj(i -&gt; {\n                        var file = files[i];\n                        /*FOREXAMPLE LINE1: from macroCode*/\n                        var result = file.addText(&quot;I am a %s type file.&quot;.formatted(file.getClass().getSimpleName()));\n                        if (!result) {\n                            return false;\n                        }\n                        /*FOREXAMPLE LINE2: from macroCode*/\n                        file.addText(&quot;, and time is %L&quot;.formatted(System.currentTimeMillis()));\n                        if (!result) {\n                            return false;\n                        }\n                        return true;\n                    })\n                    .filter(result -&gt; false)\n                    .findAny().isPresent();\n            if (errorPresent) {\n                return false;\n            }\n        //}\n        return true;\n    }\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}