{
  "question": {
    "tags": [
      "java",
      "multithreading",
      "unit-testing"
    ],
    "owner": {
      "account_id": 449256,
      "reputation": 2163,
      "user_id": 843943,
      "user_type": "registered",
      "accept_rate": 75,
      "profile_image": "https://i.sstatic.net/1V5SP.jpg?s=256",
      "display_name": "Grim",
      "link": "https://stackoverflow.com/users/843943/grim"
    },
    "is_answered": true,
    "view_count": 156,
    "accepted_answer_id": 79151993,
    "answer_count": 2,
    "score": 0,
    "last_activity_date": 1730603695,
    "creation_date": 1728811418,
    "question_id": 79082810,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79082810/arraylist-removefirst-throw-arrayindexoutofboundsexception-but-was-synchronize",
    "title": "ArrayList.removeFirst() throw ArrayIndexOutOfBoundsException but was synchronized",
    "body": "<p>Having this Threadpool:</p>\n<pre><code>package xxx;\n\nimport java.util.ArrayList;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.Consumer;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * A thread pool that hold an amount of work. During execution the amount of\n * work may grow.\n * \n * @param &lt;A&gt; The work\n */\npublic class DepleatingFiFoThreadPool&lt;A&gt; {\n\n    public static final Logger LOG = Logger.getLogger(DepleatingFiFoThreadPool.class.getCanonicalName());\n\n    public record Socket&lt;A&gt;(A r, String threadPostfix) {\n    }\n\n    private final Thread[] threadsRunning;\n    private final ArrayList&lt;Socket&lt;A&gt;&gt; unstartedRunnables = new ArrayList&lt;&gt;();\n    private int nextFreeSocketIndex = 0;\n    private final Consumer&lt;Throwable&gt; errorHandler;\n    private final Object lock = new Object();\n    private boolean waitingForLock = false;\n\n    private final String prefix;\n    private final Consumer&lt;A&gt; invoker;\n\n    /**\n     * Create the threadpool.\n     * \n     * @param threadsRunningMax The maximum of Threads running at the same time,\n     *                          must be higher than &lt;code&gt;0&lt;/code&gt;\n     * @param errorHandler      The handler in case of problems, never\n     *                          &lt;code&gt;null&lt;/code&gt;\n     * @param prefix            The prefix for the pool, required for debugging\n     *                          purposes, never &lt;code&gt;null&lt;/code&gt;\n     * @param invoker           The invoker who encapsule the work, never\n     *                          &lt;code&gt;null&lt;/code&gt;\n     */\n    public DepleatingFiFoThreadPool(final int threadsRunningMax, final Consumer&lt;Throwable&gt; errorHandler,\n            final String prefix, final Consumer&lt;A&gt; invoker) {\n        this.errorHandler = errorHandler;\n        this.prefix = prefix;\n        this.invoker = invoker;\n        this.threadsRunning = new Thread[threadsRunningMax];\n    }\n\n    /**\n     * Add and start a thread.\n     * \n     * Work after returning from {@link #executeUntilDeplated(long)} will not be\n     * executed.\n     * \n     * @param notRunningThread The not running work that is designated to be done\n     * @param threadPostfix    The postfix of the thread, never &lt;code&gt;null&lt;/code&gt;\n     */\n    public void addAndStartThread(final A notRunningThread, final String threadPostfix) {\n        var mustCallLater = false;\n        if (nextFreeSocketIndex &lt; threadsRunning.length) {\n            synchronized (this) {\n                if (nextFreeSocketIndex &lt; threadsRunning.length) {\n                    start(notRunningThread, threadPostfix);\n                } else {\n                    mustCallLater = true;\n                }\n            }\n        } else {\n            mustCallLater = true;\n        }\n        if (mustCallLater) {\n            unstartedRunnables.add(new Socket&lt;A&gt;(notRunningThread, threadPostfix));\n        }\n    }\n\n    private void finished() {\n        synchronized (this) {\n            threadsRunning[--nextFreeSocketIndex] = null;\n            if (nextFreeSocketIndex == 0) {\n                synchronized (lock) {\n                    if (waitingForLock) {\n                        lock.notify();\n                    }\n                }\n            } else {\n                Socket&lt;A&gt; e = null;\n                if (!unstartedRunnables.isEmpty()) {\n                    synchronized (unstartedRunnables) {\n                        if (!unstartedRunnables.isEmpty()) {\n                            e = unstartedRunnables.removeFirst();\n                        }\n                    }\n                }\n                if (e != null) {\n                    start(e.r, e.threadPostfix);\n                }\n            }\n        }\n    }\n\n    private void start(final A notRunningThread, final String name) {\n        var socket = nextFreeSocketIndex++;\n        Thread t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    invoker.accept(notRunningThread);\n                } catch (Throwable e) { // fault barrier!\n                    try {\n                        errorHandler.accept(e);\n                    } catch (Throwable ta) {\n                        ta.addSuppressed(e);\n                        LOG.log(Level.SEVERE, ta.getMessage(), ta);\n                    }\n                }\n                finished();\n            }\n        }, prefix + name);\n        threadsRunning[socket] = t;\n        t.start();\n    }\n\n    /**\n     * Execute the threads and every subsequent thread that is added during the\n     * progress.\n     * \n     * @param timeoutMs The timeout in miliseconds, should be an positive value\n     * @return &lt;code&gt;false&lt;/code&gt; if the timeout has reached, &lt;code&gt;true&lt;/code&gt;\n     *         otherwise\n     * @throws InterruptedException If the thread has been interrupted (maybe\n     *                              shutdown of application)\n     */\n    public boolean executeUntilDeplated(final long timeoutMs) throws InterruptedException {\n        AtomicBoolean resultHolder = new AtomicBoolean(true);\n        if (nextFreeSocketIndex &gt; 0) {\n            Thread timeout = new Thread(() -&gt; {\n                try {\n                    Thread.sleep(timeoutMs);\n                    resultHolder.set(false);\n                    synchronized (lock) {\n                        lock.notify();\n                    }\n                } catch (InterruptedException e) {\n                    LOG.log(Level.FINE, &quot;Not a bug, timeout not reached, watchdog not required.&quot;, e);\n                }\n            });\n            timeout.start();\n            if (nextFreeSocketIndex &gt; 0) {\n                waitingForLock = true;\n                synchronized (lock) {\n                    try {\n                        lock.wait(timeoutMs);\n                    } finally {\n                        timeout.interrupt();\n                    }\n                }\n            }\n        }\n        return resultHolder.get();\n    }\n}\n</code></pre>\n<p>A exception is thrown sometimes having this Stacktrace:</p>\n<pre><code>Exception in thread &quot;NN/SQL-caller&quot; java.lang.ArrayIndexOutOfBoundsException: arraycopy: last source index 50 out of bounds for object array[49]\n  at java.base/java.lang.System.arraycopy(Native Method)\n  at java.base/java.util.ArrayList.fastRemove(ArrayList.java:724)\n  at java.base/java.util.ArrayList.removeFirst(ArrayList.java:573)\n  at xxx.DepleatingFiFoThreadPool.finished(DepleatingFiFoThreadPool.java:74)\n  at xxx.DepleatingFiFoThreadPool$1.run(DepleatingFiFoThreadPool.java:100)\n  at java.base/java.lang.Thread.run(Thread.java:1570)\n</code></pre>\n<p>I am not able to debug this because it appears only once every three to five weeks.</p>\n<p>I use this test but I could not find the problem:</p>\n<pre><code>public void testMassiveQueuedFunction() throws InterruptedException {\n    var dtp = new DepleatingFiFoThreadPool&lt;Runnable&gt;(100, x -&gt; System.out.println(x), &quot;testQueueFunction&quot;,\n            Runnable::run);\n    var l = new CountDownLatch(0);\n    Runnable wait = () -&gt; {\n        try {\n            Thread.sleep(2);\n            l.countDown();\n        } catch (InterruptedException e) {\n        }\n    };\n    for (int i = 0; i &lt; 9999; i++) {\n        dtp.addAndStartThread(wait, i + &quot;&quot;);\n    }\n    long start = System.currentTimeMillis();\n    dtp.executeUntilDeplated(3000);\n    long took = System.currentTimeMillis() - start;\n    assert l.getCount() == 0 : &quot;Await a count of 0 but has: &quot; + l.getCount();\n    assert took &lt; 2900 : &quot;Should execute faster but took: &quot; + took;\n}\n</code></pre>\n<p>Can someone suggest a better unit-test?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}