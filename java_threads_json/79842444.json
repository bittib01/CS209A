{
  "question": {
    "tags": [
      "java",
      "spring",
      "reflection",
      "annotations",
      "spring-annotations"
    ],
    "owner": {
      "account_id": 9051315,
      "reputation": 346,
      "user_id": 6741328,
      "user_type": "registered",
      "profile_image": "https://graph.facebook.com/10209045323343600/picture?type=large",
      "display_name": "Gus Murphy",
      "link": "https://stackoverflow.com/users/6741328/gus-murphy"
    },
    "is_answered": false,
    "view_count": 55,
    "answer_count": 2,
    "score": 0,
    "last_activity_date": 1765350032,
    "creation_date": 1765322060,
    "question_id": 79842444,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79842444/avoiding-duplicated-spring-bean-classes-that-just-have-different-field-level-v",
    "title": "Avoiding duplicated Spring Bean classes that just have different field-level `@Value` annotations",
    "body": "<p>Suppose that I have two classes that differ only in terms of their <code>@Value</code> &quot;values&quot; on their fields. For example:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Component\npublic class BlueWidget {\n    @Value(&quot;${blue.message}&quot;)\n    private String message;\n    \n    public String getMessage() {\n        return message;\n    }\n}\n</code></pre>\n<p>And...</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Component\npublic class RedWidget {\n    @Value(&quot;${red.message}&quot;)\n    private String message;\n\n    public String getMessage() {\n        return message;\n    }\n}\n</code></pre>\n<p>This feels like a waste, but the hurdle I can't overcome is that <code>@Value</code> annotation. What I <em>feel</em> like should be possible is to do something like the following, where I just have a single <code>Widget</code> class that is able to take a &quot;name&quot; or something and then act as if it has a <code>@Value(&quot;${&lt;this name&gt;.message}&quot;)</code> on it's <code>message</code> field. Then wiring up those beans could look like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Configuration\npublic class WidgetConfiguration {\n    @Bean \n    Widget redWidget() {\n        return new Widget(&quot;red&quot;);\n    }\n    \n    @Bean\n    Widget blueWidget() {\n        return new Widget(&quot;blue&quot;);\n    }\n}\n</code></pre>\n<p>Or maybe there would be some sort of <code>WidgetFactory</code> or builder or what have you. However, I don't know what this more abstract <code>Widget</code> would look like.</p>\n<p>The codebase that I spend most of my day job in is littered with this sort of thing: multiple variations on a class with many, many fields that only vary by their <code>@Value</code> annotations.</p>\n<p>I've played around a bit with reflection, however even if I were able to change the &quot;value&quot; of a <code>@Value</code> annotation (the double &quot;value&quot; there has always bothered me...), I think I would end up changing that for every instance of the class, whereas I'm looking to achieve something like each instance of the class having different <code>@Value</code>s.</p>\n<p>The wrinkle of the instances still behaving <em>as if</em> they had the <code>@Value</code> annotation is important in my use case, since there are other things that look for that annotation, but maybe the answer is to ultimately take a second look at those things as well. However, this <em>feels</em> like something that should be achievable. Any thoughts?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}