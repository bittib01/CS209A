{
  "question": {
    "tags": [
      "java",
      "oop",
      "interface",
      "casting",
      "dagger"
    ],
    "owner": {
      "account_id": 19560900,
      "reputation": 1,
      "user_id": 14314139,
      "user_type": "registered",
      "profile_image": "https://lh3.googleusercontent.com/a-/AOh14Gin9MjnATNsc1v0ITypm3qtuKzybVcY_cpQc5x9Zw=k-s256",
      "display_name": "Muskan Kuchhal",
      "link": "https://stackoverflow.com/users/14314139/muskan-kuchhal"
    },
    "is_answered": false,
    "view_count": 64,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1720044589,
    "creation_date": 1716539289,
    "last_edit_date": 1716546092,
    "question_id": 78527343,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78527343/is-it-possible-to-typecast-interface-object-at-runtime-in-java-using-dependency",
    "title": "Is it possible to typecast interface object at runtime in Java using dependency injection?",
    "body": "<pre><code>public interface Animal {\n    void speak();\n}\n\npublic class Dog implements Animal{\n    void speak (){\n        System.out.println(&quot;This is dog.&quot;)\n    }\n}\n\npublic class Cat implements Animal{\n    void speak (){\n        System.out.println(&quot;This is cat.&quot;)\n    }\n}\n\n\n@Module\npublic class Module{\n\n    @Provides\n    @Named(&quot;Dog&quot;)\n        static Animal providesDog() {\n            return new Dog();\n    }\n\n    @Provides\n    @Named(&quot;Cat&quot;)\n        static Animal providesCat() {\n            return new Cat();\n        }\n}\n\npublic class AnimalOrchestrator {\n\n    @Inject\n    Animal animal;\n\n    public void speak(String type) {\n\n        if(type.equals(&quot;dog&quot;)\n            (Dog) animal.speak();\n        else\n            (Cat) animal.speak();\n\n    }\n}\n</code></pre>\n<p>Is such kind of typecasting possible where at runtime we determining which Dog/Cat object should Animal object translate as?</p>\n<p>Following are some other ways using which such a functionality is achieved.</p>\n<pre><code>public class AnimalOrchestrator {\n\n    @Inject\n    Dog dog;\n\n    @Inject\n    Cat cat;\n\n    public void speak(String type) {\n\n        if(type.equals(&quot;dog&quot;)\n            dog.speak();\n        else\n            cat.speak();\n\n    }\n}\n</code></pre>\n<p>The above code has the disadvantage that we need to create objects of dog and cat both although only one of the above will be used.</p>\n<p>Another way is the following:</p>\n<pre><code>public class AnimalOrchestrator {\n\n    Animal animal;\n\n    public void speak(String type) {\n\n        if(type.equals(&quot;dog&quot;){\n            animal = new Dog();\n            animal.speak();\n        } else {\n            animal = new Cat();\n            animal.speak();\n        }\n    }\n}\n</code></pre>\n<p>With this, We have to create this object using new operator that i wanted to avoid so as to leverage dependency injection.</p>\n<p>Is the first solution even possible? If yes, which among these is better?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}