{
  "question": {
    "tags": [
      "java",
      "multithreading",
      "collections",
      "hashmap",
      "heap-memory"
    ],
    "owner": {
      "account_id": 3864493,
      "reputation": 147,
      "user_id": 3201343,
      "user_type": "registered",
      "accept_rate": 0,
      "profile_image": "https://www.gravatar.com/avatar/60287496901d9f795cada39e508a0f2b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "user3201343",
      "link": "https://stackoverflow.com/users/3201343/user3201343"
    },
    "is_answered": true,
    "view_count": 80,
    "closed_date": 1726147101,
    "answer_count": 1,
    "score": -1,
    "last_activity_date": 1727694086,
    "creation_date": 1726136633,
    "last_edit_date": 1727694086,
    "question_id": 78977692,
    "link": "https://stackoverflow.com/questions/78977692/synchronized-hashmap-in-multithreaded-environment-is-not-working",
    "closed_reason": "Not suitable for this site",
    "title": "Synchronized HashMap in multithreaded environment is not working",
    "body": "<p>I have a scenario where I need the maximum size of my HashMap to be 10000. Any records inserted further should remove the oldest entry and proceed to insert. It is for a multithreaded scenario.</p>\n<p>I am seeing a strange scenario, where the maximum limit exceeds. I can see the size keeps increasing more than 10000 (i.e) 20000+. Here is the code:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class FixedSizeLinkedHashMap&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {\n    private final int maxSize;\n\n    public FixedSizeLinkedHashMap(int maxSize) {\n        super(maxSize, 0.75f, true);\n        this.maxSize = maxSize;\n    }\n\n    @Override\n    protected synchronized boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) {\n        return size() &gt; maxSize;\n    }\n\n    @Override\n    public synchronized V put(K key, V value) {\n        return super.put(key, value);\n    }\n\n    @Override\n    public synchronized V get(Object key) {\n        return super.get(key);\n    }\n\n    @Override\n    public synchronized V remove(Object key) {\n        return super.remove(key);\n    }\n\n    @Override\n    public synchronized void clear() {\n        super.clear();\n    }\n}\n</code></pre>\n<p>In the calling class I have used</p>\n<pre class=\"lang-java prettyprint-override\"><code>fixedsizeLhm = new FixedSizeLinkedHashMap&lt;&gt;(10000);\n</code></pre>\n<p>Is there anything I am missing?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}