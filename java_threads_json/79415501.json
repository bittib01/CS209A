{
  "question": {
    "tags": [
      "java",
      "sql-server",
      "jdbc"
    ],
    "owner": {
      "account_id": 5882885,
      "reputation": 521,
      "user_id": 4631752,
      "user_type": "registered",
      "accept_rate": 62,
      "profile_image": "https://www.gravatar.com/avatar/69a053739fc16ab6618dc006345d2a99?s=256&d=identicon&r=PG",
      "display_name": "Siick",
      "link": "https://stackoverflow.com/users/4631752/siick"
    },
    "is_answered": false,
    "view_count": 101,
    "answer_count": 0,
    "score": 0,
    "last_activity_date": 1742814279,
    "creation_date": 1738773775,
    "last_edit_date": 1738778867,
    "question_id": 79415501,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79415501/executebatch-method-from-java-interface-preparedstatement-is-not-updating-my-all",
    "title": "executeBatch method from Java interface PreparedStatement is not updating my all batch and just on some table on SQL server",
    "body": "<p>To sum up very simply before going into detail the problem is as follows. I have a method in which I run ALL my updates in batch on different tables in different databases. However on 3 tables coming from two different databases (and only there!), my queries are not executed on all my batch but only part of it. Let's move on to the real examples and the code.</p>\n<p>First some basics informations. This is my pom.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;2.6.11&lt;/version&gt;\n        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;/parent&gt;\n    &lt;groupId&gt;fr.xxxxxxx.data.rgpd&lt;/groupId&gt;\n    &lt;artifactId&gt;xxxxxxxAnonymizeData&lt;/artifactId&gt;\n    &lt;version&gt;2.0.2&lt;/version&gt;\n    &lt;name&gt;xxxxxxxAnonymizeData&lt;/name&gt;\n    &lt;description&gt;RGPD-Compliance : anonymisation des donnees personnelles&lt;/description&gt;\n    &lt;properties&gt;\n        &lt;java.version&gt;17&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;\n            &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;fr.xxxxxxx.tools&lt;/groupId&gt;\n            &lt;artifactId&gt;xxxxxxxcommons&lt;/artifactId&gt;\n            &lt;version&gt;1.16&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- data access --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mongodb&lt;/groupId&gt;\n            &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt;\n            &lt;version&gt;3.12.10&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- Test --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n            &lt;artifactId&gt;h2&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;de.flapdoodle.embed&lt;/groupId&gt;\n            &lt;artifactId&gt;de.flapdoodle.embed.mongo&lt;/artifactId&gt;\n            &lt;version&gt;3.4.3&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;/groupId&gt;\n            &lt;artifactId&gt;junit&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;argLine&gt;\n                        --add-opens java.base/java.lang=ALL-UNNAMED\n                    &lt;/argLine&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;excludes&gt;\n                        &lt;exclude&gt;**/logback.xml&lt;/exclude&gt;\n                    &lt;/excludes&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.1.0&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n    &lt;distributionManagement&gt;\n        &lt;repository&gt;\n            &lt;id&gt;xxxxxxx-release&lt;/id&gt;\n            &lt;uniqueVersion&gt;true&lt;/uniqueVersion&gt;\n            &lt;name&gt;Nexus xxxxxxx release&lt;/name&gt;\n            &lt;url&gt;https://nexus.xxxxxxx.fr/repository/xxxxxxx-release/&lt;/url&gt;\n            &lt;layout&gt;default&lt;/layout&gt;\n        &lt;/repository&gt;\n        &lt;snapshotRepository&gt;\n            &lt;id&gt;xxxxxxx-snapshot&lt;/id&gt;\n            &lt;uniqueVersion&gt;true&lt;/uniqueVersion&gt;\n            &lt;name&gt;Nexus xxxxxxx snapshot&lt;/name&gt;\n            &lt;url&gt;https://nexus.xxxxxxx.fr/repository/xxxxxxx-snapshot/&lt;/url&gt;\n            &lt;layout&gt;default&lt;/layout&gt;\n        &lt;/snapshotRepository&gt;\n    &lt;/distributionManagement&gt;\n    &lt;repositories&gt;\n        &lt;repository&gt;\n            &lt;id&gt;xxxxxxx-release&lt;/id&gt;\n            &lt;url&gt;https://nexus.xxxxxxx.fr/repository/xxxxxxx-release/&lt;/url&gt;\n        &lt;/repository&gt;\n        &lt;repository&gt;\n            &lt;id&gt;maven-public&lt;/id&gt;\n            &lt;url&gt;https://nexus.xxxxxxx.fr/repository/maven-public/&lt;/url&gt;\n        &lt;/repository&gt;\n    &lt;/repositories&gt;\n\n&lt;/project&gt;\n</code></pre>\n<p>Here is my portion of code that I use to make batch updates (with some debug message all along to find my problem)</p>\n<pre><code>public @NonNull List&lt;ErrorUpdateClient&gt;  queryFactoryUpdate(Set&lt;ClientGlobalActivity&gt; clientSet, Base base, Environnement env, String sql, String nomRequete){\n        if(clientSet == null || clientSet.isEmpty()){\n            return new ArrayList&lt;&gt;();\n        }\n        else if (clientSet.size() == 1 ){\n            return queryFactoryUpdate(clientSet.stream().findFirst().get(), base, env, sql, nomRequete);\n        }\n        else{\n            return queryFactoryBatchUpdate(clientSet, base, env, sql, nomRequete);\n        }\n    }\n\n\npublic @NonNull List&lt;ErrorUpdateClient&gt; queryFactoryBatchUpdate(Set&lt;ClientGlobalActivity&gt; clientSet, Base base, Environnement env, String sql, String nomRequete) {\n        logger.info(&quot;DEBUT - DAO - appel de la méthode [ &quot; + nomRequete + &quot; ]&quot;);\n        LocalDateTime debut = LocalDateTime.now();\n        List&lt;ErrorUpdateClient&gt; updateClientResults = new ArrayList&lt;&gt;();\n\n        try {\n            final JdbcTemplate jdbcTemplate = getJdbcTemplate(base, env);\n            jdbcTemplate.execute(new ConnectionCallback&lt;Object&gt;() {\n\n                @Override\n                public Object doInConnection(Connection con) throws SQLException, DataAccessException {\n                    PreparedStatement ps = null;\n                    int affectedRows = 0;\n                    try{\n                        String sqlStr = sqlTranslator.translate(sql);\n                        logger.debug(&quot;[FIX-DEBUG] : &quot; + sqlStr);\n                        ps = con.prepareStatement(sqlStr);\n                        Iterator&lt;ClientGlobalActivity&gt; it = clientSet.iterator();\n                        int runningQueries = 0;\n                        int totalQueries = clientSet.size();\n                        Set&lt;ClientGlobalActivity&gt; chunkClient = new HashSet&lt;&gt;();\n                        while(it.hasNext()){\n                            ClientGlobalActivity c = it.next();\n                            runningQueries++;\n                            ps.setString(1, c.getIdClient());\n                            logger.debug(&quot;[DEBUG-SQL] Preparing to add to batch: &quot; + sqlStr + &quot; | Param: xid_client = &quot; + c.getIdClient());\n                            ps.addBatch();\n                            chunkClient.add(c);\n                            if(runningQueries % app.getCommitSize() == 0 || runningQueries == totalQueries){\n                                try{\n                                    int[] batchResults = ps.executeBatch();\n                                    for (int i = 0; i &lt; batchResults.length; i++) {\n                                        logger.debug(&quot;[DEBUG-SQL] Batch result for query &quot; + (i + 1) + &quot;: &quot; + batchResults[i]);\n                                    }\n                                    //affectedRows += IntStream.of(ps.executeBatch()).sum();\n                                    logger.debug(&quot;Execution batch - nombre de client traites : &quot; + runningQueries  + &quot; - cumul de lignes impactees : &quot; + affectedRows);\n                                }\n                                catch(Exception e){\n                                    // Erreur lors de l'execution de la requete pour un client =&gt; Erreur non bloquante\n                                    logger.debug(&quot;Erreur modification des données impossible pour la requête : [ &quot; + nomRequete + &quot; ] ERREUR / &quot; + e);\n                                    // On stocke dans un nouvel objet le client, la base, la requete ainsi que l'exception\n                                    // Comme on insere en batch, on considère que tous les clients des chunk courant sont en erreur (pour ne pas passer à côté d'une erreur)\n                                    chunkClient.forEach(clientInChunk -&gt; {\n                                        updateClientResults.add(new ErrorUpdateClient(\n                                                clientInChunk.getIdClient(),\n                                                base,\n                                                env,\n                                                sql,\n                                                e)\n                                        );}\n                                    );\n                                }\n                                finally {\n                                    chunkClient.clear();\n                                }\n                            }\n                        }\n                    }\n                    catch (Exception e) {\n                        JdbcUtils.closeStatement(ps);\n                        ps = null;\n                        DataSourceUtils.releaseConnection(con, jdbcTemplate.getDataSource());\n                        con = null;\n                        // Erreur de création de l'objet JdbcTemplate (acces à la base,...) =&gt; Erreur bloquante pour tout le set de client\n                        logger.debug(&quot;Initialisation de la connexion impossible pour la base : [ &quot; + base.name()\n                                + &quot; ] de l'env [&quot; + env.name() + &quot;]  ERREUR / &quot; + e);\n                        throw e;\n                    } finally {\n                        ps.clearBatch();\n                        JdbcUtils.closeStatement(ps);\n                        ps = null;\n                        DataSourceUtils.releaseConnection(con, jdbcTemplate.getDataSource());\n                        con = null;\n                    }\n\n                    return null;\n                }\n            });\n        }\n        catch (Exception e) {\n            // Erreur de création de l'objet JdbcTemplate (acces à la base,...) =&gt; Erreur bloquante pour tout le set de client\n            logger.debug(&quot;Initialisation de la connexion impossible pour la base : [ &quot; + base.name()\n                            + &quot; ] de l'env [&quot; + env.name() + &quot;]  ERREUR / &quot; + e);\n            throw e;\n        } finally {\n            LocalDateTime fin = LocalDateTime.now();\n            logger.debug(&quot;FIN - DAO - exécution requête : [ &quot; + nomRequete + &quot; ] en [ &quot;\n                    + ChronoUnit.SECONDS.between(debut, fin) +\n                    &quot; ] secondes, pour [ &quot; + clientSet.size() + &quot; ] clients. Sur l'environnement [ &quot; + env + &quot; ] et sur la BDD [ &quot;\n                    + base + &quot; ].&quot;);\n        }\n        return updateClientResults;\n    }\n</code></pre>\n<p>And this my class with different methods to update some tables on a SQL server database</p>\n<pre><code>@Repository\npublic class CampaignCrmJdbcRepository extends JdbcGenericDao {\n\n    private final AppProperties app;\n\n    public CampaignCrmJdbcRepository(AppProperties app) {\n        this.app = app;\n    }\n\n    public List&lt;ErrorUpdateClient&gt; deleteOptinsInMarketingCampaigns(Set&lt;ClientGlobalActivity&gt; clientSet) {\n        String sqlDataOptin = &quot;UPDATE dbo.DATA_OPTIN_CRM &quot; +\n        &quot;SET TELEPHONE_FIXE = 0, &quot; +\n        &quot;MOBILE = 0, &quot; +\n        &quot;EMAIL = 0, &quot; +\n        &quot;COURRIER = 0, &quot; +\n        &quot;TELEPHONE_FIXE_PARTENAIRE = 0, &quot; +\n        &quot;MOBILE_PARTENAIRE = 0, &quot; +\n        &quot;EMAIL_PARTENAIRE = 0, &quot; +\n        &quot;COURRIER_PARTENAIRE = 0, &quot; +\n        &quot;CANAL_FAVORI = '', &quot; +\n        &quot;MODIFIED_DT = GETUTCDATE() &quot; +\n        &quot;FROM dbo.DATA_OPTIN_CRM doc &quot; +\n        &quot;INNER JOIN dbo.USERS_CONTACTS_CRM uc ON doc.USERID = uc.ID &quot; +\n        &quot;WHERE uc.ID_CLIENT = ?&quot;;\n\n\n        String sqlUsersContats = &quot;UPDATE dbo.USERS_CONTACTS_CRM &quot; +\n        &quot;SET OFFRE_INSTORE_UNIQUEMENT = 0, &quot; +\n        &quot;MODIFIED_DT = GETUTCDATE() &quot; +\n        &quot;WHERE ID_CLIENT = ?&quot;;\n\n        List&lt;ErrorUpdateClient&gt; errorUpdateClients = new ArrayList&lt;&gt;();\n        errorUpdateClients.addAll(queryFactoryUpdate(clientSet, Base.CAMPAIGN, app.getEnvironnement(), sqlDataOptin, &quot;delete optins DATA_OPTIN_CRM&quot;));\n        errorUpdateClients.addAll(queryFactoryUpdate(clientSet, Base.CAMPAIGN, app.getEnvironnement(), sqlUsersContats, &quot;delete optins USERS_CONTACTS_CRM&quot;));\n        return errorUpdateClients;\n    }\n\n    public List&lt;ErrorUpdateClient&gt; anonymizationClientCoordonneesFromCampaign(Set&lt;ClientGlobalActivity&gt; clientGlobalActivities) {\n        String sql = &quot;UPDATE dbo.USERS_CONTACTS_CRM &quot; +\n        &quot;SET MAIL = NULL, &quot; +\n        &quot;MOBILE_COMPLET = NULL &quot; +\n        &quot;where ID_CLIENT = ? &quot;;\n\n        return queryFactoryUpdate(clientGlobalActivities, Base.CAMPAIGN, app.getEnvironnement(), sql,&quot;anonymizationClientCoordonneesFromCampaign&quot;);\n    }\n\n    public List&lt;ErrorUpdateClient&gt; anonymizationClientIdentityFromCampaign(Set&lt;ClientGlobalActivity&gt; clientGlobalActivities) {\n        String sql = &quot;UPDATE dbo.USERS_CONTACTS_CRM &quot; +\n        &quot;SET NAME = '&quot; + AnonymizationRules.NAME_REPLACE_VALUE + &quot;', &quot; +\n        &quot;PRENOM = '&quot; + AnonymizationRules.FIRSTNAME_REPLACE_VALUE + &quot;' &quot; +\n        &quot;where ID_CLIENT = ? &quot;;\n\n        return queryFactoryUpdate(clientGlobalActivities, Base.CAMPAIGN, app.getEnvironnement(), sql, &quot;anonymizationClientIdentityFromCampaign&quot;);\n    }\n\n}\n</code></pre>\n<p>All the methods here update the client set I give them. All except deleteOptinsInMarketingCampaigns() !\nThe set passed to this method is more or less updated. Depending on the mood of the application, I suppose...\nIn fact, you only need to check the client set passed as a parameter in the database to see that only part of the set has been updated using the MODIFIED_DT column.\n<a href=\"https://i.sstatic.net/4RDwZmLj.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/4RDwZmLj.png\" alt=\"screen of database table\" /></a></p>\n<p>But when I look at the logs, I can see that every update line has passed and no exception has been raised.</p>\n<p>The logs are visible here --&gt; <a href=\"https://bin.siick.fr/?d3dc662d98214a77#89iNypF4755Y4woLPLCWjfX3R2RaHHSZTX9LiuJMKQbe\" rel=\"nofollow noreferrer\">https://bin.siick.fr/?d3dc662d98214a77#89iNypF4755Y4woLPLCWjfX3R2RaHHSZTX9LiuJMKQbe</a> because otherwise I ran out of space on this post</p>\n<p>And for those wondering, the second SQL query in the deleteOptinsInMarketingCampaigns() method, which should update the same set of clients in another table, gives me the same problem and doesn't update the whole set, but not necessarily the same clients as before.</p>\n<p>And I'd rather say it again, but this batch backup method is used everywhere else in my program for many other tables in Oracle and SQL server databases and everything works fine. Even more bizarrely, I update other tables in the same database using the same queryFactoryBatchUpdate() method with no problem.</p>\n<p>I've don't know how to debug the problem. If some kind soul wants to help me, I'm ready to hear it.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}