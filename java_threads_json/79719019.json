{
  "question": {
    "tags": [
      "java",
      "ignite",
      "distributed-computing",
      "gridgain"
    ],
    "owner": {
      "account_id": 10024548,
      "reputation": 799,
      "user_id": 7413086,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/d4fb3298de0146214cd2a125f6b91dc7?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "kushal Baldev",
      "link": "https://stackoverflow.com/users/7413086/kushal-baldev"
    },
    "is_answered": true,
    "view_count": 140,
    "answer_count": 1,
    "score": 3,
    "last_activity_date": 1754520344,
    "creation_date": 1753810300,
    "last_edit_date": 1753971327,
    "question_id": 79719019,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79719019/in-apache-ignite-the-replication-mode-and-partition-mode-does-not-work-all-toget",
    "title": "In Apache Ignite the Replication mode and Partition mode does not work all together",
    "body": "<p>Iâ€™m working with <strong>Apache Ignite 2.17.0</strong>. I load database tables into Ignite caches and run SQL queries using the SQLFieldsQuery API.</p>\n<p>Recently, I modified the cache configuration for some tables to use <code>CacheMode.REPLICATED instead of PARTITIONED</code> (for selected tables only).</p>\n<p>Now, I'm encountering an issue when querying across caches with different cache modes.</p>\n<p><strong>Example:</strong></p>\n<p><strong>Employee</strong> table is loaded into a <code>PARTITIONED</code> cache.</p>\n<p><strong>Company</strong> table is loaded into a <code>REPLICATED</code> cache.</p>\n<p>When I run a SQL query (with distributed joins enabled) that joins <code>Employee</code> with <code>Company</code>, using the <code>Employee cache</code> context (i.e., submitting the query from a compute task using the Employee cache reference), Ignite throws an error saying:</p>\n<blockquote>\n<p>Table 'Company' not found</p>\n</blockquote>\n<p>Even though the Company table is successfully loaded into its own cache, Ignite fails to recognize it during the query.</p>\n<p>Code Snippets how I configured cache</p>\n<pre><code>  private @NotNull CacheConfiguration&lt;Object, Object&gt; getCacheConfiguration(EntitySpec entitySpec, String cacheName,\n            Class&lt;?&gt; entityClass, Object compositeClassInstance, Field primaryKeyField, String pojoTableName) {\n        CacheConfiguration&lt;Object, Object&gt; cacheCfg = new CacheConfiguration&lt;&gt;(cacheName);\n        cacheCfg.setAtomicityMode(CacheAtomicityMode.ATOMIC);\n        if (replicateCaches.contains(cacheName)) {\n            cacheCfg.setCacheMode(CacheMode.REPLICATED);\n        } else {\n            cacheCfg.setCacheMode(CacheMode.PARTITIONED);\n        }\n        // Initially we disable write-through and then re-enable it after data loading\n        // has completed\n        cacheCfg.setWriteThrough(false);\n        cacheCfg.setReadThrough(false);\n        cacheCfg.setSqlSchema(schemaName);\n        cacheCfg.setQueryParallelism(queryParallelism);\n        // cacheCfg.setAffinity(new RendezvousAffinityFunction(false,\n        // CACHE_PARTITIONS));\n        cacheCfg.setOnheapCacheEnabled(enableOnHeapCache);\n        cacheCfg.setEventsDisabled(false);\n        cacheCfg.setStatisticsEnabled(true);\n        cacheCfg.setPartitionLossPolicy(PartitionLossPolicy.IGNORE);\n\n        if (enableOnHeapCache) {\n            log.warn(&quot;On-heap caching enabled for {}&quot;, entitySpec.getName());\n        } else {\n            log.info(&quot;Off-heap cache enabled for {}&quot;, entitySpec.getName());\n        }\n\n        if (cacheBackups &gt; 0) {\n            cacheCfg.setBackups(cacheBackups);\n            cacheCfg.setReadFromBackup(true);\n            cacheCfg.setWriteSynchronizationMode(CacheWriteSynchronizationMode.FULL_ASYNC);\n            log.info(&quot;Set cache backups to {}&quot;, cacheBackups);\n        } else {\n            log.info(&quot;Cache backups disabled&quot;);\n        }\n\n        // Configure JDBC POJO store factory\n        CacheJdbcPojoStoreFactory&lt;Object, Object&gt; jdbcPojoStoreFactory = jdbcPojoStoreConnectionFactoryProducer\n                .create();\n        jdbcPojoStoreFactory.setTypes(createJdbcType(entityClass, cacheName, schemaName, entitySpec.getName(),\n                Objects.isNull(compositeClassInstance) ? primaryKeyField.getName() : null,\n                Objects.isNull(compositeClassInstance) ? primaryKeyField.getType() : compositeClassInstance.getClass(),\n                Objects.isNull(compositeClassInstance) ? null : compositeClassInstance.getClass()));\n        cacheCfg.setCacheStoreFactory(jdbcPojoStoreFactory);\n        cacheCfg.setIndexedTypes(\n                Objects.isNull(compositeClassInstance) ? primaryKeyField.getType() : compositeClassInstance.getClass(),\n                entityClass);\n\n        // Set Query Entity\n        cacheCfg.setQueryEntities(Collections.singletonList(createQueryEntity(entityClass,\n                Objects.isNull(compositeClassInstance) ? primaryKeyField.getName() : null,\n                Objects.isNull(compositeClassInstance) ? primaryKeyField.getType() : compositeClassInstance.getClass(),\n                pojoTableName, Objects.isNull(compositeClassInstance) ? null : compositeClassInstance.getClass())));\n\n        return cacheCfg;\n    }\n</code></pre>\n<p>Now how I run the queries</p>\n<pre><code>QueryCursor&lt;List&lt;?&gt;&gt; getQueryCursor(String sql, IgniteCache&lt;Object, Object&gt; cache) {\n    SqlFieldsQuery query = new SqlFieldsQuery(sql);\n    query.setDistributedJoins(true);\n    query.setLazy(true);\n    query.setTimeout(0, TimeUnit.MILLISECONDS);\n    QueryCursor&lt;List&lt;?&gt;&gt; cursor = cache.query(query);\n    return cursor;\n}\n</code></pre>\n<p><strong>here the cache is the employee_cache</strong> so providing the employee_cache context we fire this query as soon as the database tables are loaded into cache.</p>\n<p>The query is the simple join of two tables one is in partitioned mode and other is in Replicated mode.</p>\n<p>For example <code>select employee e join company c on e.id=c.employee_id</code></p>\n<p>Here employee is loaded by partitioned way and company is loaded by replicated way we are ingesting data from Postgres via CacheJDBCPojoStore.</p>\n<p>We have the server and thick clients we run the compute task from thick clients on the server nodes we have set of 5 server nodes and 2 proxies that is thick client and we run this queries from the ComputeTask which extends ComputeTaskAdapter.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}