{
  "question": {
    "tags": [
      "java",
      "threadpool",
      "executorservice",
      "parallelstream"
    ],
    "owner": {
      "account_id": 11512926,
      "reputation": 125,
      "user_id": 10560184,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/3399de3e1ec229ab54f7a9926b6a35b8?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Andorrax",
      "link": "https://stackoverflow.com/users/10560184/andorrax"
    },
    "is_answered": false,
    "view_count": 138,
    "answer_count": 0,
    "score": 3,
    "last_activity_date": 1745405939,
    "creation_date": 1745324601,
    "last_edit_date": 1745405939,
    "question_id": 79586452,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79586452/why-are-thread-pools-so-significantly-slower-than-parallelstream-for-this-scenar",
    "title": "Why are thread pools so significantly slower than parallelStream for this scenario?",
    "body": "<p>This is for Java 23, but I've replicated this on Java 21 and 17 as well.</p>\n<p>I recently ran a benchmark to compare performance differences between threadpools and parallelstreams for some simple calculations.</p>\n<p>I've set up JMH to compare the following:</p>\n<ul>\n<li><code>Executors.newFixedThreadPool</code></li>\n<li><code>Executors.newWorkStealingPool</code></li>\n<li>A manually generated <code>ForkJoinPool</code></li>\n<li><code>ForkJoinPool.commonPool</code></li>\n<li>A <code>parallelStream()</code> implementation, and</li>\n<li>A sequential loop to act as a base case</li>\n</ul>\n<p>And this is the calculation I'm benchmarking:</p>\n<pre class=\"lang-java prettyprint-override\"><code>    @State(Scope.Benchmark)\n    private static class StateData{\n        public static final List&lt;ContainerClass&gt; models = IntStream.range(1,1000_001)\n                .mapToObj(x-&gt;{\n                    double length = 10.0; // meters\n                    // ContainerClass is a record with two double type args\n                    return new ContainerClass(beamLength, x);\n                }).toList();\n    }\n\n    Callable&lt;Double&gt; getCallable(ContainerClass x){\n        return ()-&gt; x.length()*x.load()/2.0;\n    }\n</code></pre>\n<p>The benchmark code is below:</p>\n<pre class=\"lang-java prettyprint-override\"><code>    @Benchmark\n    @Fork(value = 1)\n    @Warmup(iterations = 5)\n    @Measurement(iterations = 5)\n    public void testingParallelStream_toList(Blackhole bh){\n        var midMoments = StateData.models.parallelStream()\n                .unordered()\n                .map(x-&gt; x.load()*x.length()/2.0).toList();\n\n        bh.consume(midMoments);\n    }\n\n    @Benchmark\n    @Fork(value = 1)\n    @Warmup(iterations = 5)\n    @Measurement(iterations = 5)\n    public void testingSequential(Blackhole bh) {\n        List&lt;Double&gt; results = new ArrayList&lt;&gt;();\n        for(var x: StateData.models){\n            var result = x.load()*x.length()/2.0;\n            results.add(result);\n        }\n        bh.consume(results);\n    }\n\n    @Benchmark\n    @Fork(value = 1)\n    @Warmup(iterations = 5)\n    @Measurement(iterations = 5)\n    public void testingExecutorService_FixedThreadPool(Blackhole bh) throws InterruptedException {\n        var pool = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());\n        runPool(bh, pool);\n    }\n\n    @Benchmark\n    @Fork(value = 1)\n    @Warmup(iterations = 5)\n    @Measurement(iterations = 5)\n    public void testingExecutorService_WorkStealingPool(Blackhole bh) throws InterruptedException {\n        var pool = Executors.newWorkStealingPool(Runtime.getRuntime().availableProcessors());\n        runPool(bh, pool);\n    }\n\n    @Benchmark\n    @Fork(value = 1)\n    @Warmup(iterations = 5)\n    @Measurement(iterations = 5)\n    public void testingManualFJPool(Blackhole bh) throws InterruptedException, ExecutionException {\n        var pool = new ForkJoinPool();\n        runPool(bh, pool);\n    }\n\n    @Benchmark\n    @Fork(value = 1)\n    @Warmup(iterations = 5)\n    @Measurement(iterations = 5)\n    public void testingCommonFJPool(Blackhole bh) throws InterruptedException, ExecutionException {\n        var pool = ForkJoinPool.commonPool();\n        List&lt;Double&gt; results = new ArrayList&lt;&gt;();\n\n        List&lt;Callable&lt;Double&gt;&gt; callables = new ArrayList&lt;&gt;();\n\n        for(var m: StateData.models){\n            callables.add(getCallable(m));\n        }\n\n        var futures = pool.invokeAll(callables);\n        boolean isFinished = pool.awaitQuiescence(60L, TimeUnit.MINUTES);\n        if(!isFinished){\n            throw new IllegalArgumentException(&quot;Timeout&quot;);\n        } else {\n            for(var future: futures){\n                results.add(future.get());\n            }\n        }\n        bh.consume(results);\n    }\n    private void runPool(Blackhole bh, ExecutorService pool) throws InterruptedException {\n        List&lt;Double&gt; results = new ArrayList&lt;&gt;();\n\n        List&lt;Callable&lt;Double&gt;&gt; callables = new ArrayList&lt;&gt;();\n\n        for(var m: StateData.models){\n            callables.add(getCallable(m));\n        }\n\n        var futures = pool.invokeAll(callables);\n        // wait for thread runs\n        pool.shutdown();\n        try{\n            boolean isFinished = pool.awaitTermination(60L, TimeUnit.MINUTES);\n            if(isFinished){\n                for(var future: futures){\n                    results.add(future.get());\n                }\n                bh.consume(results);\n            } else {\n                throw new IllegalArgumentException(&quot;Timeout occurred before all threads could finish&quot;);\n            }\n        } catch(Exception e){\n            throw new IllegalArgumentException(e);\n        }\n    }\n</code></pre>\n<p>I expected the threadpools to be slower than parallelstream due to better task splitting in the latter, but the results are a bit surprising:</p>\n<pre class=\"lang-none prettyprint-override\"><code>Benchmark                                                                  Mode  Cnt   Score   Error  Units\nFunctionalVsImperative.PerfTests.testingCommonFJPool                      thrpt    5  10.859 ± 0.937  ops/s\nFunctionalVsImperative.PerfTests.testingExecutorService_FixedThreadPool   thrpt    5   5.605 ± 0.907  ops/s\nFunctionalVsImperative.PerfTests.testingExecutorService_WorkStealingPool  thrpt    5  10.278 ± 0.430  ops/s\nFunctionalVsImperative.PerfTests.testingManualFJPool                      thrpt    5   9.875 ± 1.709  ops/s\nFunctionalVsImperative.PerfTests.testingParallelStream_toList             thrpt    5  74.648 ± 4.755  ops/s\nFunctionalVsImperative.PerfTests.testingSequential                        thrpt    5  46.895 ± 6.828  ops/s\n</code></pre>\n<p>Not only are threadpools much slower than <code>parallelStream</code>, they're even slower than the base sequential loop! I've tested this across 1000, 10000 and 100000 tasks/iterations and the trend remains the same.</p>\n<p>(I'll note that for smaller iterations, the sequential version is faster than <code>parallelStream</code> and that's to be expected. However, for this specific case (and for larger iterations), <code>parallelStream</code> is faster than sequential, so presumedly there are enough computations that the overhead of creating threads is smaller than the benefit of parallel runs)</p>\n<p>Does anyone have an idea as to why this benchmark is behaving this way ? If it helps, I'm running this on a Core i7 10850H system with 12 available CPUs (hexcore + hyperthreading).</p>\n<p><strong>EDIT (23/04/25)</strong> : following some discussion in the comments (see below) I modified my <code>State</code> class like so:</p>\n<pre class=\"lang-java prettyprint-override\"><code>    @State(Scope.Benchmark)\n    private static class StateData{\n        public static final List&lt;ContainerClass&gt; models = IntStream.range(1,1000_001)\n                .mapToObj(x-&gt;{\n                    double beamLength = 10.0; // meters\n                    return new ContainerClass(beamLength, x);\n                }).toList();\n\n        public static final List&lt;Callable&lt;Double&gt;&gt; getCallables(){\n            List&lt;Callable&lt;Double&gt;&gt; callables = new ArrayList&lt;&gt;();\n            for(var m: StateData.models){\n                callables.add(StateData.getCallable(m));\n            }\n            return callables;\n        }\n\n        public static Callable&lt;Double&gt; getCallable(ContainerClass x){\n            return ()-&gt; x.length()*x.load()/2.0;\n        }\n    }\n</code></pre>\n<p>The intent was to remove any overhead incurred from instantiating one million <code>Callable</code> objects. The <code>runPool()</code> method was also modified:</p>\n<pre><code>private void runPool(Blackhole bh, ExecutorService pool) throws InterruptedException {\n        List&lt;Double&gt; results = new ArrayList&lt;&gt;();\n        var futures = pool.invokeAll(StateData.getCallables());\n        // ... rest of the code\n}\n</code></pre>\n<p>Unfortunately, this did absolutely nothing to improve the benchmark, the results of which remain very similar to what I was seeing before (which is why I haven't added them here)</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}