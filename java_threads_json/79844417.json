{
  "question": {
    "tags": [
      "java",
      "c++",
      "performance"
    ],
    "owner": {
      "account_id": 388557,
      "reputation": 189,
      "user_id": 747562,
      "user_type": "registered",
      "accept_rate": 25,
      "profile_image": "https://www.gravatar.com/avatar/5c15b03c434ed5ebaa5d74e52e00db6d?s=256&d=identicon&r=PG",
      "display_name": "CPW",
      "link": "https://stackoverflow.com/users/747562/cpw"
    },
    "is_answered": true,
    "view_count": 302,
    "answer_count": 10,
    "score": 1,
    "last_activity_date": 1765881067,
    "creation_date": 1765492276,
    "last_edit_date": 1765505594,
    "question_id": 79844417,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79844417/c-vs-java-performance-under-repeated-heave-computation",
    "title": "C++ vs Java performance under repeated heave computation",
    "body": "<p>Is it possible that under repeated heave computation Java out-perform C++ by an order of magnitude? My open-source project is such a benchmark: <a href=\"https://github.com/Chengpu0707/VarianceArithmetic\" rel=\"nofollow noreferrer\">https://github.com/Chengpu0707/VarianceArithmetic</a>:</p>\n<p><img src=\"https://i.sstatic.net/xVeDMvRi.png\" alt=\"enter image description here\" /></p>\n<p>In the above figure, I have compared the execution time of FFT of input data size $2^{order}$. As expected, the execution time increases exponentially as $~2^{order}$.</p>\n<p>The C++ project is compiled with -O3.  Still, it is an order of magnitude slower than Java when the FFT order is larger than 10. I am completely surprised by this result.</p>\n<p>Some other technical details about my computer:</p>\n<ul>\n<li><p>Java version: java version &quot;1.8.0_441&quot;</p>\n</li>\n<li><p>gcc version: gcc.exe (Rev3, Built by MSYS2 project) 13.2.0</p>\n</li>\n<li><p>CPU: 12th Gen Intel(R) Core(TM) i7-1255U (1.70 GHz) 10-core</p>\n</li>\n<li><p>RAM: 16.0 GB (15.7 GB usable)</p>\n</li>\n<li><p>The figure shows the means of 72 runs at each FFT order. When the FFT order is larger than 10, the execution deviation is much smaller than the corresponding execution mean.</p>\n</li>\n<li><p>All codes are single-threaded.</p>\n</li>\n<li><p>The code has no intention to optimize for any of the programming language.</p>\n</li>\n<li><p>My laptop has no GPU, and the codes are not compiled targeting any CPU.</p>\n</li>\n<li><p>Please see the README for how to run each.</p>\n</li>\n</ul>\n<p>The C++ flags as in the task.json of Vs Code:</p>\n<pre><code>            &quot;args&quot;: [\n                &quot;--std&quot;,\n                &quot;c++23&quot;,\n                &quot;-fdiagnostics-color=always&quot;,\n                &quot;-g&quot;,\n                &quot;-O3&quot;,\n            ],\n</code></pre>\n<p>Does this show that Java JIT compiler optimization is superior to C++ static optimization under repeated heave computation?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}