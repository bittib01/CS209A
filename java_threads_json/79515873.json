{
  "question": {
    "tags": [
      "java",
      "hibernate",
      "entitymanager"
    ],
    "owner": {
      "account_id": 1014607,
      "reputation": 4671,
      "user_id": 1026453,
      "user_type": "registered",
      "accept_rate": 83,
      "profile_image": "https://www.gravatar.com/avatar/63c564d87d2cb4b19ecab12094534b9b?s=256&d=identicon&r=PG",
      "display_name": "DuncanKinnear",
      "link": "https://stackoverflow.com/users/1026453/duncankinnear"
    },
    "is_answered": true,
    "view_count": 61,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1742436756,
    "creation_date": 1742249982,
    "last_edit_date": 1742436756,
    "question_id": 79515873,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79515873/hibernate-entity-manager-behaviour-logging",
    "title": "Hibernate Entity Manager behaviour logging",
    "body": "<p>We have two JPA entities, let's call them 'C' and 'P'. These Entities have a one-to-one optional relationship based on their primary keys. That is, Entity 'P' can exist without a related Entity 'C', and vice versa.</p>\n<p>When we try to delete a 'C' Entity, we first 'find' the Entity which loads it into the EntityManager's Persistence Context. A consequence of this is that Hibernate insists on Eager loading the associated 'P' Entity, and creates object references from each object to the other.</p>\n<p>However, if we then 'remove' the 'C' Entity and try to 'flush', the EntityManager complains that the 'P' Entity has an unsaved transient reference to the now removed 'C' Entity. But we never asked the EntityManager to 'merge' the 'P' Entity.</p>\n<p>What we want to know is why is the EntityManager making a decision to merge the 'P' Entity? Is there a class that we can switch on logging for to see what rational it is using to do the automatic merge? There is a possibility that our code is somehow making some sort of low-level change to the 'P' Entity, but without knowing why the EntityManager is doing the merge, we are kind of blind to what is happening.</p>\n<p>We know that we can manually remove the object references from each object to the other and that 'fixes' the problem, but why is this necessary when we don't want to merge the 'P' Entity?</p>\n<hr />\n<p>UPDATE:</p>\n<p>So I found a way to add an <code>Interceptor</code> which catches the 'onFlushDirty' event during Hibernate's dirty checking.</p>\n<p>When our error occurs, the <code>P</code> entity is not marked as dirty, so now I really don't know why Hibernate is trying to merge it.</p>\n<p>The only thing I can think of is that the <code>C</code> entity that <code>P</code> entity refers to is somehow different to the <code>C</code> entity that we tell the EntityManager to remove, and that's why Hibernate thinks it is an 'unsaved transient'.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}