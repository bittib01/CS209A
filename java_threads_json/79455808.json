{
  "question": {
    "tags": [
      "java",
      "jackson",
      "proguard",
      "jackson-databind"
    ],
    "owner": {
      "account_id": 320962,
      "reputation": 33604,
      "user_id": 639520,
      "user_type": "registered",
      "accept_rate": 72,
      "profile_image": "https://i.sstatic.net/KzMc4.jpg?s=256",
      "display_name": "E-Riz",
      "link": "https://stackoverflow.com/users/639520/e-riz"
    },
    "is_answered": true,
    "view_count": 93,
    "accepted_answer_id": 79482052,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1741033113,
    "creation_date": 1740084507,
    "last_edit_date": 1740090751,
    "question_id": 79455808,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79455808/why-would-jackson-be-omitting-type-information-for-serialized-polymorphic-types",
    "title": "Why would Jackson be omitting type information for serialized polymorphic types?",
    "body": "<p>In a project that's being obfuscated with ProGuard (using the Gradle plugin), I have lots of serialization/deserialization using Jackson. I've found that in the obfuscated builds, certain kinds of serialization of polymorphic types is omitting the type information (specified with <code>@JsonTypeInfo(use = Id.NAME, include = As.PROPERTY, property = &quot;type&quot;)</code>), which causes some very strange behavior during deserialization.</p>\n<p>For example, here's the (correct) serialized form when run with <em>unobfuscated</em> code:</p>\n<pre class=\"lang-json prettyprint-override\"><code>{\n  &quot;owner&quot; : &quot;Jay Leno&quot;,\n  &quot;cars&quot; : [ {\n    &quot;type&quot; : &quot;Corvette&quot;,\n    &quot;name&quot; : &quot;Corvette&quot;,\n    &quot;year&quot; : 1963\n  }, {\n    &quot;type&quot; : &quot;Aztek&quot;,\n    &quot;name&quot; : &quot;Ugly&quot;,\n    &quot;year&quot; : 2003\n  } ]\n}\n</code></pre>\n<p>Here's the output of the exact same code after running through ProGuard:</p>\n<pre class=\"lang-json prettyprint-override\"><code>{\n  &quot;owner&quot; : &quot;Jay Leno&quot;,\n  &quot;cars&quot; : [ {\n    &quot;a&quot; : 1963,\n    &quot;name&quot; : &quot;Corvette&quot;\n  }, {\n    &quot;a&quot; : 2003,\n    &quot;name&quot; : &quot;Ugly&quot;\n  } ]\n}\n</code></pre>\n<p>Note the <code>&quot;type&quot;</code> property is missing from the array elements in the obfuscated form. This causes Jackson to deserialize those objects incorrectly.</p>\n<p>Here is an MRE of the code; sorry for including so much code in a question, but this is as minimal as I could get it and still demonstrate the context and problem.</p>\n<p>Also <a href=\"https://gist.github.com/erizzo/3b9d6f42c8f97a54f89c8a2e81d85c6d\" rel=\"nofollow noreferrer\">viewable as a gist</a>, or <a href=\"https://drive.google.com/file/d/1ksJ0i4mAsVEa5FNOdIkJotd9w-voJJjC/view?usp=sharing\" rel=\"nofollow noreferrer\">downloadable ZIP of the project</a>.</p>\n<pre class=\"lang-java prettyprint-override\"><code>@JsonAutoDetect(fieldVisibility = Visibility.ANY)\n@JsonTypeInfo(use = Id.NAME, include = As.PROPERTY, property = &quot;type&quot;)\n@JsonSubTypes({\n        @JsonSubTypes.Type(value = Corvette.class),\n        @JsonSubTypes.Type(value = Aztek.class)\n})\npublic abstract class CarModel {\n\n    public abstract String getName();\n    public abstract int getYear();\n}\n\n@Getter\n@AllArgsConstructor\n@ToString\npublic class Corvette extends CarModel {\n\n    private int year;\n\n    @JsonCreator\n    public Corvette(@JsonProperty(&quot;name&quot;) String name, @JsonProperty(&quot;year&quot;) int year) {\n        this.year = year;\n    }\n\n    @Override\n    @ToString.Include\n    public String getName() {\n        return &quot;Corvette&quot;;\n    }\n}\n\n@Getter\n@Setter\n@AllArgsConstructor\n@ToString\npublic class Aztek extends CarModel {\n\n    private int year;\n\n    @JsonCreator\n    public Aztek(@JsonProperty(&quot;name&quot;) String name, @JsonProperty(&quot;year&quot;) int year) {\n        this.year = year;\n    }\n\n    @Override\n    @ToString.Include\n    public String getName() {\n        return &quot;Ugly&quot;;\n    }\n}\n\n@Getter\npublic class Inventory {\n\n    private String owner;\n    private List&lt;CarModel&gt; cars;\n\n    @JsonCreator\n    public Inventory(@JsonProperty(&quot;owner&quot;) String owner, @JsonProperty(&quot;cars&quot;) List&lt;CarModel&gt; cars) {\n        this.owner = owner;\n        this.cars = cars;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder(&quot;Inventory [&quot;);\n        builder.append(&quot;owner=&quot;)\n            .append(owner)\n            .append(&quot;, cars=&lt;&quot;);\n\n        System.out.println(&quot;First cars element is of type &quot; + cars.get(0).getClass());\n\n        cars.forEach(car -&gt; builder.append(car).append(&quot;, &quot;));\n        builder.append(&quot;&gt;&quot;);\n\n        builder.append(&quot;]&quot;);\n        return builder.toString();\n    }\n}\n\npublic class JacksonPolymorphicSerialization {\n\n    private final static ObjectMapper JSONMapper =\n            JsonMapper.builder()\n            .configure(DEFAULT_VIEW_INCLUSION, false)\n            .configure(FAIL_ON_UNKNOWN_PROPERTIES, false)\n            .serializationInclusion(Include.NON_ABSENT)\n            .build();\n    private static final ObjectReader JSONReader = JSONMapper.readerFor(Inventory.class);\n    private static final ObjectWriter JSONWriter = JSONMapper.writerFor(Inventory.class).withDefaultPrettyPrinter();\n\n\n    public static void main(String[] args) throws JacksonException {\n        Corvette corvette = new Corvette(1963);\n        Aztek aztek = new Aztek(2003);\n        Inventory inventory = new Inventory(&quot;Jay Leno&quot;, List.of(corvette, aztek));\n\n        String json = JSONWriter.writeValueAsString(inventory);\n        System.out.println(&quot;Serialized form:\\n&quot; + json);\n\n        System.out.println();\n\n        inventory = JSONReader.readValue(json);\n        System.out.println(&quot;Deserialized object: &quot; + inventory);\n    }\n}\n</code></pre>\n<p>Here's the Gradle build file</p>\n<pre class=\"lang-none prettyprint-override\"><code>buildscript {\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath 'com.guardsquare:proguard-gradle:7.6.1'\n    }\n}\n\nplugins {\n    id 'java'\n    id &quot;io.freefair.lombok&quot; version &quot;8.12.1&quot;\n}\n\nrepositories {\n    mavenCentral()\n}\n\ndef appMainClass = 'rizzo.test.JacksonPolymorphicSerialization'\n\njava {\n    toolchain {\n        languageVersion = JavaLanguageVersion.of(17)\n    }\n}\n\njar {\n    duplicatesStrategy = 'exclude'\n    \n    manifest {\n        attributes 'Main-Class': &quot;${appMainClass}&quot;\n    }\n    \n    from {\n        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }\n    }\n}\n\ndependencies {\n    implementation group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: '2.18.2'\n    implementation group: 'com.fasterxml.jackson.core', name: 'jackson-annotations', version: '2.18.2'\n}\n\ntask proguard(type: proguard.gradle.ProGuardTask) {\n    dependsOn classes\n    \n    verbose\n    printmapping &quot;${buildDir}/proguard-mapping.txt&quot;\n\n    injars &quot;${buildDir}/classes/java/main&quot;\n    outjars &quot;${buildDir}/classes/obfuscated/&quot;\n\n    libraryjars &quot;${System.getProperty('java.home')}/jmods/java.base.jmod&quot;, jarfilter: '!**.jar', filter: '!module-info.class'\n    libraryjars &quot;${System.getProperty('java.home')}/jmods/java.logging.jmod&quot;, jarfilter: '!**.jar', filter: '!module-info.class'\n    libraryjars &quot;${System.getProperty('java.home')}/jmods/java.desktop.jmod&quot;, jarfilter: '!**.jar', filter: '!module-info.class'\n    libraryjars &quot;${System.getProperty('java.home')}/jmods/java.xml.jmod&quot;, jarfilter: '!**.jar', filter: '!module-info.class'\n    libraryjars &quot;${System.getProperty('java.home')}/jmods/java.sql.jmod&quot;, jarfilter: '!**.jar', filter: '!module-info.class'\n\n    // This will contain the app dependencies.\n    libraryjars sourceSets.main.compileClasspath\n\n    keepdirectories\n\n    // Preserve getters and setters\n    keepclassmembers 'class * { \\\n        ** get*(); \\\n        void set*(***); \\\n    }'\n\n    // Keep the main class entry point.\n    keep &quot;public class ${appMainClass} { \\\n            public static void main(java.lang.String[]); \\\n         }&quot;\n\n    // This helps produce useful stack traces (see https://www.guardsquare.com/manual/configuration/examples#stacktrace)\n    renamesourcefileattribute 'SourceFile'\n    keepattributes '*Annotation*,EnclosingMethod,SourceFile,LineNumberTable'\n\n    doLast {\n        delete &quot;${buildDir}/classes/java/main&quot;\n        copy {\n            from &quot;${buildDir}/classes/obfuscated/&quot;\n            into &quot;${buildDir}/classes/java/main&quot;\n        }\n        \n    }\n}\n\n</code></pre>\n<p>Run <code>./gradlew jar</code> to build, you'll get a normal (unobfuscated) JAR. Run <code>./gradlew proguard jar</code> and the resulting JAR will be obfuscated. Either way, you can then run with <code>java -jar ...</code></p>\n<p>Here's what happens with each.</p>\n<p>Unobfuscated:</p>\n<pre><code>&gt; java -jar build/libs/ProguardJacksonTest.jar           \nSerialized form:\n{\n  &quot;owner&quot; : &quot;Jay Leno&quot;,\n  &quot;cars&quot; : [ {\n    &quot;type&quot; : &quot;Corvette&quot;,\n    &quot;name&quot; : &quot;Corvette&quot;,\n    &quot;year&quot; : 1963\n  }, {\n    &quot;type&quot; : &quot;Aztek&quot;,\n    &quot;name&quot; : &quot;Ugly&quot;,\n    &quot;year&quot; : 2003\n  } ]\n}\n\nFirst cars element is of type class rizzo.test.Corvette\nDeserialized object: Inventory [owner=Jay Leno, cars=&lt;Corvette(year=1963, getName=Corvette), Aztek(year=2003, getName=Ugly), &gt;]\n</code></pre>\n<p>Output using the obfuscated build:</p>\n<pre><code>&gt; java -jar build/libs/ProguardJacksonTest.jar\nSerialized form:\n{\n  &quot;owner&quot; : &quot;Jay Leno&quot;,\n  &quot;cars&quot; : [ {\n    &quot;a&quot; : 1963,\n    &quot;name&quot; : &quot;Corvette&quot;\n  }, {\n    &quot;a&quot; : 2003,\n    &quot;name&quot; : &quot;Ugly&quot;\n  } ]\n}\n\nException in thread &quot;main&quot; java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class rizzo.test.b (java.util.LinkedHashMap is in module java.base of loader 'bootstrap'; rizzo.test.b is in unnamed module of loader 'app')\n        at rizzo.test.d.toString(SourceFile:29)\n        at java.base/java.lang.StringConcatHelper.stringOf(StringConcatHelper.java:453)\n        at java.base/java.lang.StringConcatHelper.simpleConcat(StringConcatHelper.java:408)\n        at rizzo.test.JacksonPolymorphicSerialization.main(SourceFile:38)\n</code></pre>\n<p>The <code>ClassCastException</code> indicates that the <code>cars</code> List is actually populated with LinkedHashMap instances rather than CarModel instances as it should. But I guess that makes sense given the serialized form that's missing type information - I suppose Jackson is just deserializing that into maps since it doesn't have the actual expected type at runtime (thanks, stoopid type erasure!).</p>\n<p>The real question is, why is Jackson omitting the type info from the serialized form when the code has been obfuscated, and what can I do about it?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}