{
  "question": {
    "tags": [
      "java",
      "spring-integration",
      "spring-dsl"
    ],
    "owner": {
      "account_id": 30980250,
      "reputation": 29,
      "user_id": 23795230,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/bcbcd250e51df5b389323c950ac7ab3c?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Nicolas",
      "link": "https://stackoverflow.com/users/23795230/nicolas"
    },
    "is_answered": true,
    "view_count": 1227,
    "accepted_answer_id": 78259589,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1719328465,
    "creation_date": 1711465866,
    "last_edit_date": 1719328465,
    "question_id": 78226325,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78226325/spring-integration-open-a-new-ssh-connection-after-each-sftpexception",
    "title": "Spring Integration open a new ssh connection after each SftpException",
    "body": "<p><strong>Versions:</strong>\nspring-boot-starter-parent : 3.2.3\njava: 17</p>\n<p><strong>maven artifacts :</strong>\nspring-boot-starter-integration\nspring-integration-sftp</p>\n<p>I'm facing an issue with the number of ssh connections opened to my SFTP server.</p>\n<p>All works fine when there is no exception, I keep the same session open to check and transfert files.\nBut as soon as there is an Exception, the connections keep increasing on each encountered error until it overload the SFTP.</p>\n<p><strong>Here is the interresting part of my code :</strong></p>\n<pre class=\"lang-java prettyprint-override\"><code>    @Bean\n    public CachingSessionFactory&lt;SftpClient.DirEntry&gt; sftpSessionFactory(\n            final SftpPrivateKeyConfigurationProperties privateKeyConfigurationProperties,\n            final SftpConfigurationProperties sftpConfigurationProperties) {\n        final DefaultSftpSessionFactory factory = new DefaultSftpSessionFactory(true);\n        factory.setHost(privateKeyConfigurationProperties.getHost());\n        factory.setPort(privateKeyConfigurationProperties.getPort());\n        factory.setUser(privateKeyConfigurationProperties.getUser());\n        factory.setPrivateKey(new ByteArrayResource(privateKeyConfigurationProperties.getPrivateKey().getBytes()));\n        factory.setAllowUnknownKeys(true);\n        factory.setTimeout(Math.toIntExact(sftpConfigurationProperties.getTimeout().toMillis()));\n        var cachedFactory = new CachingSessionFactory&lt;&gt;(factory, sftpConfigurationProperties.getPoolSize());\n        cachedFactory.setSessionWaitTimeout(sftpConfigurationProperties.getSessionWaitTimeout().toMillis());\n        return cachedFactory;\n    }\n\n    @Bean\n    IntegrationFlow flowSubAccount(final SftpConfigurationProperties sftpConfigurationProperties,\n            final CachingSessionFactory&lt;SftpClient.DirEntry&gt; sessionFactory,\n            @Qualifier(&quot;sftpFilter&quot;) final ChainFileListFilter&lt;SftpClient.DirEntry&gt; sftpFilter,\n            final ConfigurableApplicationContext ctx)\n            throws IOException {\n\n        return IntegrationFlow.from(\n                Sftp.inboundAdapter(sessionFactory, Comparator.comparingLong(File::lastModified))\n                        .preserveTimestamp(true)\n                        .deleteRemoteFiles(sftpConfigurationProperties.getDeleteRemoteFiles())\n                        .remoteDirectory(sftpConfigurationProperties.getRemoteDirectory())\n                        .filter(sftpFilter)\n                        .localDirectory(new File(sftpConfigurationProperties.getLocalDirectory()))\n                        .localFilenameExpression(&quot;#root&quot;)\n                        .autoCreateLocalDirectory(true),\n                e -&gt; e.autoStartup(true).poller(Pollers.fixedDelay(sftpConfigurationProperties.getPollDuration()).maxMessagesPerPoll(1).errorHandler((ex) -&gt; {\n                    log.error(&quot;An error has been encountered&quot;, ex);\n                })))\n                .route(Message.class, this::payloadTypeSubAccountRouter)\n                .get();\n</code></pre>\n<p>Every time the poller retrieve a file, if an exception occurs (not enough permission on file, no such file) there is a new ssh connection created.</p>\n<p>Here one of the stacktrace :</p>\n<pre><code>org.springframework.messaging.MessagingException: Problem occurred while synchronizing 'this/path/does/not/exists' to local directory\n    at org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer.synchronizeToLocalDirectory(AbstractInboundFileSynchronizer.java:348) ~[spring-integration-file-6.2.2.jar:6.2.2]\n    at org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizingMessageSource.doReceive(AbstractInboundFileSynchronizingMessageSource.java:267) ~[spring-integration-file-6.2.2.jar:6.2.2]\n    at org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizingMessageSource.doReceive(AbstractInboundFileSynchronizingMessageSource.java:69) ~[spring-integration-file-6.2.2.jar:6.2.2]\n    at org.springframework.integration.endpoint.AbstractFetchLimitingMessageSource.doReceive(AbstractFetchLimitingMessageSource.java:47) ~[spring-integration-core-6.2.2.jar:6.2.2]\n    at org.springframework.integration.endpoint.AbstractMessageSource.receive(AbstractMessageSource.java:142) ~[spring-integration-core-6.2.2.jar:6.2.2]\n    at org.springframework.integration.endpoint.SourcePollingChannelAdapter.receiveMessage(SourcePollingChannelAdapter.java:222) ~[spring-integration-core-6.2.2.jar:6.2.2]\n    at org.springframework.integration.endpoint.AbstractPollingEndpoint.doPoll(AbstractPollingEndpoint.java:450) ~[spring-integration-core-6.2.2.jar:6.2.2]\n    at org.springframework.integration.endpoint.AbstractPollingEndpoint.pollForMessage(AbstractPollingEndpoint.java:419) ~[spring-integration-core-6.2.2.jar:6.2.2]\n    at org.springframework.integration.endpoint.AbstractPollingEndpoint.lambda$createPoller$4(AbstractPollingEndpoint.java:355) ~[spring-integration-core-6.2.2.jar:6.2.2]\n    at org.springframework.integration.util.ErrorHandlingTaskExecutor.lambda$execute$0(ErrorHandlingTaskExecutor.java:57) ~[spring-integration-core-6.2.2.jar:6.2.2]\n    at org.springframework.core.task.SyncTaskExecutor.execute(SyncTaskExecutor.java:50) ~[spring-core-6.1.4.jar:6.1.4]\n    at org.springframework.integration.util.ErrorHandlingTaskExecutor.execute(ErrorHandlingTaskExecutor.java:55) ~[spring-integration-core-6.2.2.jar:6.2.2]\n    at org.springframework.integration.endpoint.AbstractPollingEndpoint.lambda$createPoller$5(AbstractPollingEndpoint.java:348) ~[spring-integration-core-6.2.2.jar:6.2.2]\n    at org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54) ~[spring-context-6.1.4.jar:6.1.4]\n    at org.springframework.scheduling.concurrent.ReschedulingRunnable.run(ReschedulingRunnable.java:96) ~[spring-context-6.1.4.jar:6.1.4]\n    at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539) ~[na:na]\n    at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) ~[na:na]\n    at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304) ~[na:na]\n    at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136) ~[na:na]\n    at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) ~[na:na]\n    at java.base/java.lang.Thread.run(Thread.java:833) ~[na:na]\nCaused by: org.springframework.messaging.MessagingException: Failed to execute on session\n    at org.springframework.integration.file.remote.RemoteFileTemplate.execute(RemoteFileTemplate.java:461) ~[spring-integration-file-6.2.2.jar:6.2.2]\n    at org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer.synchronizeToLocalDirectory(AbstractInboundFileSynchronizer.java:341) ~[spring-integration-file-6.2.2.jar:6.2.2]\n    ... 20 common frames omitted\nCaused by: org.apache.sshd.sftp.common.SftpException: No such file\n    at org.apache.sshd.sftp.client.impl.AbstractSftpClient.throwStatusException(AbstractSftpClient.java:277) ~[sshd-sftp-2.11.0.jar:2.11.0]\n    at org.apache.sshd.sftp.client.impl.AbstractSftpClient.checkAttributesResponse(AbstractSftpClient.java:333) ~[sshd-sftp-2.11.0.jar:2.11.0]\n    at org.apache.sshd.sftp.client.impl.AbstractSftpClient.checkAttributes(AbstractSftpClient.java:325) ~[sshd-sftp-2.11.0.jar:2.11.0]\n    at org.apache.sshd.sftp.client.impl.AbstractSftpClient.lstat(AbstractSftpClient.java:1010) ~[sshd-sftp-2.11.0.jar:2.11.0]\n    at org.springframework.integration.sftp.session.SftpSession.doList(SftpSession.java:102) ~[spring-integration-sftp-6.2.2.jar:6.2.2]\n    at org.springframework.integration.sftp.session.SftpSession.list(SftpSession.java:80) ~[spring-integration-sftp-6.2.2.jar:6.2.2]\n    at org.springframework.integration.sftp.session.SftpSession.list(SftpSession.java:52) ~[spring-integration-sftp-6.2.2.jar:6.2.2]\n    at org.springframework.integration.file.remote.session.CachingSessionFactory$CachedSession.list(CachingSessionFactory.java:246) ~[spring-integration-file-6.2.2.jar:6.2.2]\n    at org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer.transferFilesFromRemoteToLocal(AbstractInboundFileSynchronizer.java:356) ~[spring-integration-file-6.2.2.jar:6.2.2]\n    at org.springframework.integration.file.remote.synchronizer.AbstractInboundFileSynchronizer.lambda$synchronizeToLocalDirectory$0(AbstractInboundFileSynchronizer.java:342) ~[spring-integration-file-6.2.2.jar:6.2.2]\n    at org.springframework.integration.file.remote.RemoteFileTemplate.execute(RemoteFileTemplate.java:452) ~[spring-integration-file-6.2.2.jar:6.2.2]\n    ... 21 common frames omitted\n\n</code></pre>\n<p>The sessions keep increasing until the shutdown of the application. As soon as the application is stopped, the connections are closed and the sftp server is back to normal. (Seen more thant 300 connections)</p>\n<p>I tried to replace the CachingSessionFactory with a default session factory, but this is worse obviously.\nI tried to put logs in TRACE for Spring Integration to check the path of the sessions.\nIt seems that Spring, when the exception occurs, ask for the close of the connection, flag it dirty and create a new one. But the &quot;dirty connection&quot; keeps opened.</p>\n<p>Logs said that :\nsession is flagged dirty\nSpring remove it from the pool of connection\nSpring create a new one\nThe connection removed from pool remain active.</p>\n<p>I tried to close completely the pool of connection to create a new one, but i was facing other issues.</p>\n<p>An idea, but seems weird, should be to stop my flow a &quot;restart&quot; it when this kind of exception is caught.</p>\n<p>Do you have any idea of to close completely these dirty sessions, still active?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}