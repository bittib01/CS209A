{
  "question": {
    "tags": [
      "java",
      "constructor",
      "nullpointerexception",
      "subclass",
      "super"
    ],
    "owner": {
      "account_id": 25950392,
      "reputation": 47,
      "user_id": 21094238,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/9d6932338d1236a69742ee3e7f87f69f?s=256&d=identicon&r=PG",
      "display_name": "Amateur Linguist",
      "link": "https://stackoverflow.com/users/21094238/amateur-linguist"
    },
    "is_answered": true,
    "view_count": 251,
    "accepted_answer_id": 79135677,
    "answer_count": 2,
    "score": 2,
    "last_activity_date": 1746037545,
    "creation_date": 1730166972,
    "last_edit_date": 1730511198,
    "question_id": 79135581,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79135581/in-java-avoiding-null-dereferences-when-calling-super-in-constructor",
    "title": "In Java, avoiding null dereferences when calling super(...) in constructor",
    "body": "<p>I am using Java 21.</p>\n<p>I have two classes:</p>\n<pre class=\"lang-java prettyprint-override\"><code>abstract class MySuperClass {\n    private final Object mySuperField;\n    MySuperClass(Object myField) {\n        this.mySuperField = myField;\n    }\n    public Object getMySuperField() {\n        return mySuperField;\n    }\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>public class MySubClass extends MySuperClass {\n    private final Object mySubField;\n    public MySubClass(MySubClass toCopy) {\n        super(toCopy.getMySuperField());\n        this.mySubField = toCopy.mySubField;\n    }\n}\n</code></pre>\n<p>The class <code>MySubClass</code> has a copy constructor, as shown above.</p>\n<p>I want to avoid throwing a <code>NullPointerException</code> in the <code>MySubClass</code> constructor if the <code>toCopy</code> argument is null, and would rather throw my own exception. But of course, the call to <code>super(...)</code> must be the first line in the constructor.</p>\n<p>Is there some Java pattern which I can use to do my own argument validation before calling <code>super(...)</code>?</p>\n<p>I have tried a few different things, but they all seem ugly/hacky, like passing nulls into the super class constructor and not doing validation in the super class, and then doing the argument validation after the call to <code>super(...)</code> in the subclass, or making <code>mySuperField</code> in <code>MySuperClass</code> not final, and providing a setter in the super class. There must be something better.</p>\n<p>Of everything I have tried, this might be the best option, but it still feels hacky.</p>\n<pre><code>public class MySubClass extends MySuperClass {\n    private final Object mySubField;\n    public MySubClass(MySubClass toCopy) {\n        super(toCopy == null ? null : toCopy.getMySuperField());\n        if (toCopy == null) {\n            // Throw my exception\n        }\n        this.mySubField = toCopy.mySubField;\n    }\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}