{
  "question": {
    "tags": [
      "java",
      "collections",
      "functional-programming",
      "java-stream",
      "iterable"
    ],
    "owner": {
      "account_id": 32246808,
      "reputation": 1,
      "user_id": 25039547,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/b874f36868e7a3fc476a2d427e7b781c?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Saerujeji Reebu CHINA",
      "link": "https://stackoverflow.com/users/25039547/saerujeji-reebu-china"
    },
    "is_answered": false,
    "view_count": 124,
    "answer_count": 0,
    "score": 0,
    "last_activity_date": 1719091573,
    "creation_date": 1715692500,
    "last_edit_date": 1719091573,
    "question_id": 78478348,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78478348/how-to-use-stream-collect-with-specific-class-as-suplider",
    "title": "How to use Stream.collect with specific class as suplider",
    "body": "<p>I am a student.\nYou might think I'm overloading the code with this, unnecessarily, but the goal is just to improve the understanding of the collect method. So all these components that I mention are part of the topic, and the goal is to solve the error, not another way to get the same result, so don't suggest me other ways than why this doesn't work! Thanks in advance. So here is the code:</p>\n<pre><code>package konekcija;\n\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JList;\nimport javax.swing.JPanel;\nimport javax.swing.JTextField;\nimport javax.swing.JToolBar;\n\nimport java.awt.EventQueue;\nimport java.sql.*;\nimport java.util.HashMap;\nimport java.util.Queue;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport java.util.Map.Entry;\npublic class app {\n\n  private JFrame okvir;\n  private JList lst;\n  private JLabel[] conn = new JLabel[20];\n  private JTextField txt;\n  private JPanel[] pnl = new JPanel[20];\n  private JButton query[] = new JButton[20];\n  private JToolBar box;\n\n  public static void main(String[] args) {\n\n    EventQueue.invokeLater(() -&gt; {\n      var app = new app();\n      app.okvir.setVisible(true);\n\n    });\n  }\n\n  public app() {\n    this.initialize();\n\n  }\nrecord Counting(HashMap&lt;JPanel,Integer&gt; hm){\npublic Counting() {\n  this(new HashMap&lt;JPanel,Integer&gt; ());// odnos glavnog yapisa i adicionih svojstava u nekanonskom konstrunktu\n  \n}\n  public void accumulator(JPanel p) {\n    this.hm.put(p, 1);\n    \n  }\n    \n   // samo da ukazem na to da se iako su polja kao u nekoj POJO oznakom final, ne znaci da je sadrzaj ref konacan\n    public void combiner(Counting cn) {\n      var key = cn.hm().keySet().stream().findFirst().get();\n   this.hm.put(key, (int)this.hm.getOrDefault(key,0)+1);\n  \n    }\n    }\nprivate void initialize() {\n\n\n   okvir = new JFrame();\n  okvir.getContentPane().setLayout(null);\n  okvir.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n  okvir.setBounds(000, 0000, 1880, 1880);\n  okvir.setResizable(false);\nokvir.setTitle(&quot;PREDUZEÄ†E&quot;);\n\n\n\n  Stream.of( (Stream.of(this.pnl).limit(3)\n      .collect(new Counting(),(c,p)-&gt;((Counting) c).accumulator(p), \n             (c1,c2)-&gt;((Counting) c2).combiner((Counting) \n              c1))).hm().entrySet()).peek((entry)-&gt;{\n                   var idx=entry.getValue();\n                   var pnl=entry.getKey();\n                   switch(idx) {\n                         case 1:\n                            pnl.setBounds(0,0,idx*100,100);\n                            break;\n                         case 2:\n                            pnl.setBounds(0,0,idx*100,100);\n                            break;\n                         case 3:\n                            pnl.setBounds(0,0,idx*100,100);\n                            break;\n                         default:\n                            break;\n                        }\n                   }).close();\n} }\n\n\n</code></pre>\n<p>The problem is in the part related to collect, which doesn't understand that the record &quot;Counting&quot; is my container-suplider. In the book, I saw that the same techniques are used, or some predefined classes like HashMap or List are specified, but it's the same. Where am I wrong.Not to confuse, after collect there was an error, and regardless of it, I wrote the rest of the stream, by heart, just so that I had a complete whole, so now I'm looking to fix the part. And here I have two Streams, one will take the field hm from the passed Counting-s, using the method hm() and extract the entrySet, and then generate a new stream (external) from it.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}