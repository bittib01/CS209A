{
  "question": {
    "tags": [
      "java",
      "svg",
      "graphics",
      "3d",
      "vector-graphics"
    ],
    "owner": {
      "account_id": 12448976,
      "reputation": 473,
      "user_id": 9064287,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/731f1bf7c821cb7c18a9e3dae3685cf2?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "nhaggen",
      "link": "https://stackoverflow.com/users/9064287/nhaggen"
    },
    "is_answered": false,
    "view_count": 94,
    "answer_count": 0,
    "score": 0,
    "last_activity_date": 1752739553,
    "creation_date": 1751468833,
    "last_edit_date": 1752739553,
    "question_id": 79687660,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79687660/how-to-render-j3d-into-svg",
    "title": "How to render j3d into svg",
    "body": "<p>I have a project where geometries are rendered on screen or into BufferedImage using the <code>javax.media.j3d</code> library in combination with <code>jogl</code>.\nNow i would like to export the projected image as SVG instead of a rastered image and i am wondering how to proceed.</p>\n<p>I have taken a look at the code of <a href=\"https://www.jfree.org/jfreesvg/\" rel=\"nofollow noreferrer\">jFreeSVG</a>, here the Graphics object is replaced/subclassed by an instance that transforms the draw/fill commands into svg code. This approach looks very straightforward, the drawing of Rectangles, Strings, etc is simply redirected to SVG code instead of a pixel-device.</p>\n<p>Unfortunately, I don't really know where in the j3d-world I'll be able to intercept the graphics output before it is rendered to screen or buffer. There is a J3DGraphics2D Object, but i can't see how i could replace it with a subclassed version that redirects to svg (there's only a getter-method but none to set the graphics object).</p>\n<p>Has anybody played around with this before, or can give me a hint how to intercept the rendering process in order to transform the drawXY() and fillXY() calls into SVG code?</p>\n<p><strong>Edit:</strong></p>\n<p>I made a test program to try out this approach. It does not work!</p>\n<ul>\n<li>Decompiled j3d</li>\n<li>Edited <code>J3DGraphics2DImpl</code> in order to remove the <code>final</code>attribute</li>\n<li>Subclassed <code>J3DGraphics2DImpl</code> and replaced the <code>offScreenGraphics2D</code> object with one of type <code>SVGGraphics2D</code></li>\n<li>Create a scene, add some objects, display on screen (works) render off-screen into svg (does not work)</li>\n</ul>\n<p><strong>I wrongly assumed, that the rendering of the scene finally is reduced to <code>drawXY()</code> and <code>fillXY()</code> methods of the <code>J3DGraphics2DImpl</code>, but these are never touched. The rendering is executed in a Render-class which renders directly into a buffer.</strong> If I want to get svg-paths I would have to dig much deeper into j3d. At the moment this is not an option since I have no source code available (decompiling the whole library creates a mess of errors) and not the time to understand how j3d really works.</p>\n<p>I suppose it would be easier (not simple) to iterate the objects i want to render and transform their outlines into svg-paths and shapes. The hardest part here would be to compute which ones are visible and in which order they are. (That's actually what j3d is for, but it seems to closed up to be extendable to svg)</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}