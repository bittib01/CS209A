{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "hibernate-search"
    ],
    "owner": {
      "account_id": 14113926,
      "reputation": 53,
      "user_id": 10196093,
      "user_type": "registered",
      "profile_image": "https://lh4.googleusercontent.com/-KZqYathbc30/AAAAAAAAAAI/AAAAAAAAAAA/AAnnY7rZSE01ajDBEf75dw60D_83A4CWCA/mo/s256-rj/photo.jpg",
      "display_name": "Hanbey Tokta≈ü",
      "link": "https://stackoverflow.com/users/10196093/hanbey-tokta%c5%9f"
    },
    "is_answered": false,
    "view_count": 44,
    "answer_count": 0,
    "score": 0,
    "last_activity_date": 1740403664,
    "creation_date": 1739987055,
    "last_edit_date": 1740403664,
    "question_id": 79452306,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79452306/hibernate-search-5-date-between-range",
    "title": "Hibernate Search 5 date between range",
    "body": "<p>I am using Hibernate Search 5 in my project. I have a global search and filter mechanism. I apply a wildcard-based search similar to &quot;like&quot; and also allow searching by specific fields. However, when performing a range search on date values, I am not getting any results. The logs confirm that the relevant value has been indexed. The related code blocks are as follows. So What exactly is my problem according to the codes below? What am I not seeing?</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Column(name = &quot;created_at&quot;, updatable = false)\n@Field(name = &quot;createdAt&quot;, analyze = Analyze.NO)\n@SortableField(forField = &quot;createdAt&quot;)\n@FieldBridge(impl = SearchableSortableOffsetDateTimeBridge.class)\n@CreationTimestamp\nprotected OffsetDateTime createdAt;\n</code></pre>\n<p>Field bridge is here :</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class SearchableSortableOffsetDateTimeBridge implements TwoWayFieldBridge {\n    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(&quot;dd-MM-yyyy&quot;);\n\n    @Override\n    public void set(String name, Object value, Document document, LuceneOptions luceneOptions) {\n        if (value != null) {\n            OffsetDateTime date = (OffsetDateTime) value;\n            long millis = date.toInstant().toEpochMilli();\n            String formattedDate = FORMATTER.format(date);\n            document.add(new NumericDocValuesField(name + &quot;_long&quot;, millis));\n            document.add(new StoredField(name + &quot;_long&quot;, millis));\n            document.add(new StringField(name, formattedDate, Field.Store.YES));\n        }\n    }\n\n    @Override\n    public Object get(String name, Document document) {\n        String dateString = document.get(name);\n        if (dateString != null) {\n            return FORMATTER.parse(dateString);\n        }\n        return null;\n    }\n\n    @Override\n    public String objectToString(Object object) {\n        if (object instanceof OffsetDateTime) {\n            return FORMATTER.format((OffsetDateTime) object);\n        }\n        return object.toString();\n    }\n}\n</code></pre>\n<p>and global search code is here :</p>\n<pre class=\"lang-java prettyprint-override\"><code>QueryBuilder searchQueryBuilder = getQueryBuilder();\nQuery searchQuery = searchQueryBuilder.keyword()\n                        .wildcard()\n                        .onFields(fields)\n                        .matching(&quot;*&quot; + specialCharacters(searchTerm) + &quot;*&quot;)\n                        .createQuery();\n\n// All query field\nQueryBuilder queryBuilder = getQueryBuilder();\n;\nBooleanJunction&lt;BooleanJunction&gt; boolJunction = queryBuilder.bool();\n\n// filter query\nif (request.getFilter() != null) {\n    if (request.getFilterList() == null) {\n        request.setFilterList(new ArrayList&lt;&gt;());\n    }\n    request.getFilterList().add(request.getFilter());\n}\n\nif (request.getFilterList() != null) {\n    for (ApiFilterRule apiFilterRule : request.getFilterList()) {\n        if (apiFilterRule.getValue() == null || ((String) apiFilterRule.getValue()).length() &lt; 1)\n            continue;\n        Query filterQuery = null;\n        String filterTerm = null;\n        QueryBuilder filterQueryBuilder = getQueryBuilder();\n\n        if (apiFilterRule.getOperator().equals(OperatorType.EQUAL)\n            || apiFilterRule.getOperator().equals(OperatorType.NOT_EQUAL)) {\n            filterTerm = specialCharacters(String.valueOf(apiFilterRule.getValue()));\n            filterQuery = filterQueryBuilder.keyword()\n                              .wildcard()\n                              .onFields(apiFilterRule.getField())\n                              .matching(filterTerm)\n                              .createQuery();\n\n        } else if ((apiFilterRule.getOperator().equals(OperatorType.BETWEEN)\n                       || apiFilterRule.getOperator().equals(OperatorType.NOT_BETWEEN))) {\n            String[] values = ((String) apiFilterRule.getValue()).split(&quot;,&quot;);\n            if (values.length == 2) {\n                try {\n                    Long lowerBound = Long.valueOf(values[0].trim());\n                    Long upperBound = Long.valueOf(values[1].trim());\n                    filterQuery = queryBuilder.range()\n                                      .onField(apiFilterRule.getField() + &quot;_long&quot;)\n                                      .from(lowerBound)\n                                      .to(upperBound)\n                                      .createQuery();\n                } catch (NumberFormatException e) {\n                    throw new IllegalArgumentException(&quot;Invalid numeric range values: &quot; + apiFilterRule.getValue(), e);\n                }\n            }\n\n        } else {\n            filterTerm = &quot;*&quot; + specialCharacters(String.valueOf(apiFilterRule.getValue())) + &quot;*&quot;;\n            filterQuery = filterQueryBuilder.keyword()\n                              .wildcard()\n                              .onFields(apiFilterRule.getField())\n                              .matching(filterTerm)\n                              .createQuery();\n        }\n        if (filterQuery != null) {\n            if (apiFilterRule.getOperator().equals(OperatorType.NOT_EQUAL)\n                || apiFilterRule.getOperator().equals(OperatorType.NOT_BETWEEN)) {\n                boolJunction.must(queryBuilder.all().except(filterQuery).createQuery());\n            } else {\n                boolJunction.must(filterQuery);\n            }\n        }\n    }\n}\n// join filter and search\nboolJunction.must(searchQuery);\n\nQuery query = boolJunction.createQuery();\n</code></pre>\n<p>Edit ------</p>\n<p>I replaced</p>\n<pre><code>long millis = offsetDateTime.toInstant().toEpochMilli();\ndocument.add(new NumericDocValuesField(name + &quot;_long&quot;, millis));\n</code></pre>\n<p>to</p>\n<pre><code>long millis = date.toEpochSecond();\ndocument.add(new LongField(name + &quot;_long&quot;, millis, Field.Store.YES));\n</code></pre>\n<p>and date range filter is ok.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}