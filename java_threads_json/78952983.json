{
  "question": {
    "tags": [
      "java",
      "android",
      "kotlin",
      "exoplayer",
      "panning"
    ],
    "owner": {
      "account_id": 14041016,
      "reputation": 1,
      "user_id": 10142420,
      "user_type": "registered",
      "profile_image": "https://lh6.googleusercontent.com/-ssMMRE_MtyY/AAAAAAAAAAI/AAAAAAAAAck/0FmvkzuorQ8/s256-rj/photo.jpg",
      "display_name": "Usama Wajid",
      "link": "https://stackoverflow.com/users/10142420/usama-wajid"
    },
    "is_answered": false,
    "view_count": 199,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1730827215,
    "creation_date": 1725538587,
    "last_edit_date": 1730827215,
    "question_id": 78952983,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78952983/exoplayer-use-zoom-feature-on-video",
    "title": "Exoplayer Use zoom feature on video",
    "body": "<p>I've implemented zoomin and panning functionality in a screen using ScaleGesture but it's not working smoothly. and in Full Screen mode i've implemented this functionality using TextureView.SurfaceTextureListener. I need need zoomin and panning functionality in screen without destroying current activity because with <code>TextureView.SurfaceTextureListener</code> we need to destroy screen to load new video. Is there any way where i can implement zoomin and paning functionality using matrix like TextureView.SurfaceTextureListener have. With TextureView.SurfaceTextureListener functionality is working very smoothly</p>\n<p>Here is my code</p>\n<pre><code>override fun onTouch(v: View?, event: MotionEvent?): Boolean {\n//        binding.txtScaleVideo.visibility = View.VISIBLE\n        if (event!=null){\n            val maxDx:Float = 0f\n            val maxDy:Float = 0f\n            when(event.action and MotionEvent.ACTION_MASK){\n                MotionEvent.ACTION_DOWN -&gt; {\n                    Log.d(&quot;ModTouchEvent:::&quot;,&quot;ACTION_DOWN ------ $mode&quot;)\n                    if (scale &gt; MIN_ZOOM){\n                        mode = Mode.DRAG\n                        startX = event.x - previousDx\n                        startY = event.y - previousDy\n                    }\n                }\n                MotionEvent.ACTION_MOVE -&gt; {\n                    Log.d(&quot;ModTouchEvent:::&quot;,&quot;ACTION_MOVE ------ $mode&quot;)\n                    isEnable = false\n                    if (mode == Mode.DRAG) {\n                        dx = event.x - startX\n                        dy = event.y - startY\n                    }\n\n                }\n                MotionEvent.ACTION_POINTER_DOWN -&gt;{\n                    Log.d(&quot;ModTouchEvent:::&quot;,&quot;ACTION_POINTER_DOWN ------ $mode&quot;)\n                    mode = Mode.ZOOM\n                }\n\n                MotionEvent.ACTION_UP -&gt;{\n\n                    Log.d(&quot;ModTouchEvent:::&quot;,&quot;ACTION_UP ------ $mode&quot;)\n                    previousDx = dx\n                    previousDy = dy\n                    mode = Mode.NONE\n                }\n\n                else -&gt; {}\n            }\n\n            scaleGestureDetector?.onTouchEvent(event)\n            gestureDetector?.onTouchEvent(event)\n\n            if ((mode == Mode.DRAG &amp;&amp; scale &gt;= MIN_ZOOM) || mode == Mode.ZOOM){\n                binding.zoomLayout.requestDisallowInterceptTouchEvent(true)\n\n\n                val maxDx = ((child().width * scale - child().width) ).coerceAtLeast(0f)\n                val maxDy = ((child().height * scale - child().height) ).coerceAtLeast(0f)\n\n                dx = dx.coerceIn(-maxDx, maxDx)\n                dy = dy.coerceIn(-maxDy, maxDy)\n\n                Log.d(&quot;ZoomInValues:::&quot;,&quot;DX -&gt; $dx   DY -&gt; $dy&quot;)\n\n\n\n                applyScaleAndTranslation()\n            }\n        }\n\n\n\n        return true\n    }\n\n    @RequiresApi(Build.VERSION_CODES.TIRAMISU)\n    override fun onScale(detector: ScaleGestureDetector): Boolean {\n\n        val scaleFactor = detector.scaleFactor\n        if (lastScaleFactor == 0f || (sign(scaleFactor) == sign(lastScaleFactor))){\n            scale *= scaleFactor\n            scale = scale.coerceIn(MIN_ZOOM, MAX_ZOOM)\n\n            val threshold = 1f\n            dx = if (abs(dx) &lt; threshold) 0f else dx\n            dy = if (abs(dy) &lt; threshold) 0f else dy\n\n            var scaleVal = AppGlobal.roundTwoPlaces(scale.toDouble(), &quot;#.#&quot;).toString()\n            if (!scaleVal.contains(&quot;.&quot;)){\n                scaleVal = &quot;$scaleVal.0&quot;\n            }\n\n            val height=binding.layoutPlayerView.measuredHeight\n            val width=binding.layoutPlayerView.measuredWidth\n            val drawBB= scale== 1.0.toFloat()\n            binding.layoutPlayerView.removeAllViews()\n\n            if (drawBB &amp;&amp; (seekToPositions.toDouble() == videoStartseekToPositions)){\n                val bBoxList = startBbox\n                bBoxList?.let { bBoxList -&gt;\n                    val drawView = PaintView(requireActivity(), bBoxList, height, width);\n                    binding.layoutPlayerView.removeAllViews()\n                    binding.layoutPlayerView.addView(drawView)\n                }\n            }\n            val scaleText = &quot;${scaleVal}&quot;+&quot; x&quot;\n            binding.txtScaleVideo.text = scaleText.toString()\n            lastScaleFactor = scaleFactor\n        }\n        else{\n            lastScaleFactor = 0f\n        }\n        applyScaleAndTranslation()\n        return true\n\n    }\n\n    override fun onScaleBegin(detector: ScaleGestureDetector): Boolean {\n        return true\n    }\n\n    override fun onScaleEnd(detector: ScaleGestureDetector) {\n\n    }\n\n\n\n    private fun applyScaleAndTranslation(){\n\n        child().scaleX = scale\n        child().scaleY = scale\n        child().translationX = dx\n        child().translationY = dy\n\n    }\n\n    private fun child() : View{\n        return zoomLayout(0)\n    }\n    private fun zoomLayout(i: Int):View{\n        return binding.videoView\n    }\n\n    enum class Mode{\n        DRAG,\n        ZOOM,\n        NONE\n    }\n    private inner class GestureDetector : android.view.GestureDetector.SimpleOnGestureListener() {\n\n        override fun onSingleTapConfirmed(e: MotionEvent): Boolean {\n            if (isEnable){\n                isEnable = false\n               // binding.videoView?.useController = false\n            }\n            else{\n                isEnable = true\n                //videoView?.useController = true\n            }\n            return super.onSingleTapConfirmed(e)\n        }\n\n        override fun onDoubleTap(event: MotionEvent): Boolean {\n            if (event.x &lt; (sWidth/2)){\n                intLeft = true\n                intRight = false\n            }\n            else if (event.x &gt; (sWidth/2)){\n                intLeft = false\n                intRight = true\n            }\n            return super.onDoubleTap(event)\n        }\n    }\n</code></pre>\n<p>in this code panning is not too smooth like panning working using TextureView.SurfaceTextureListener and custom <code>ZoomableTextureView</code>. For load new video i need to call onSurfaceTextureDestroyed everytime when need to load new video but onSurfaceTextureDestroyed is only called when onDestroy is called in Activity.</p>\n<pre><code>public class ZoomableTextureView extends TextureView {\n   private static final String SUPERSTATE_KEY = &quot;superState&quot;;\n   private static final String MIN_SCALE_KEY = &quot;minScale&quot;;\n   private static final String MAX_SCALE_KEY = &quot;maxScale&quot;;\n   private Context context; \n   private float minScale = 1f;\n   private float maxScale = 5f;\n   private float saveScale = 1f;  \n   public void setMinScale(float scale) {\n    if (scale &lt; 1.0f || scale &gt; maxScale)\n        throw new RuntimeException(&quot;minScale can't be lower than 1 or larger than maxScale(&quot; + maxScale + &quot;)&quot;);\n    else minScale = scale;\n}\npublic void setMaxScale(float scale) {\n    if (scale &lt; 1.0f || scale &lt; minScale)\n        throw new RuntimeException(&quot;maxScale can't be lower than 1 or minScale(&quot; + minScale + &quot;)&quot;);\n    else minScale = scale;\n}\n private static final int NONE = 0;\n private static final int DRAG = 1;\n private static final int ZOOM = 2;\n private int mode = NONE;\n private Matrix matrix = new Matrix();\n private ScaleGestureDetector mScaleDetector;\nprivate float[] m;\nprivate PointF last = new PointF();\nprivate PointF start = new PointF();\nprivate float right, bottom;\npublic ZoomableTextureView(Context context) {\n    super(context);\n    this.context = context;\n    initView(null);\n}\npublic ZoomableTextureView(final Context context, final AttributeSet attrs) {\n    super(context, attrs);\n    this.context = context;\n    initView(attrs);\n}\npublic ZoomableTextureView(Context context, AttributeSet attrs, int defStyle) {\n    super(context, attrs, defStyle);\n    this.context = context;\n    initView(attrs);\n}\n@Override\nprotected Parcelable onSaveInstanceState() {\n    Bundle bundle = new Bundle();\n    bundle.putParcelable(SUPERSTATE_KEY, super.onSaveInstanceState());\n    bundle.putFloat(MIN_SCALE_KEY, minScale);\n    bundle.putFloat(MAX_SCALE_KEY, maxScale);\n    return bundle;\n}\n@Override\npublic void onRestoreInstanceState(Parcelable state) {\n    if (state instanceof Bundle) {\n        Bundle bundle = (Bundle) state;\n        this.minScale = bundle.getInt(MIN_SCALE_KEY);\n        this.minScale = bundle.getInt(MAX_SCALE_KEY);\n        state = bundle.getParcelable(SUPERSTATE_KEY);\n    }\n    super.onRestoreInstanceState(state);\n}    \nprivate void initView(AttributeSet attrs) {\n    TypedArray a = context.getTheme().obtainStyledAttributes(\n            attrs,\n            R.styleable.ZoomableTextureView,\n            0, 0);\n    try {\n        minScale = a.getFloat(R.styleable.ZoomableTextureView_minScale, minScale);\n        maxScale = a.getFloat(R.styleable.ZoomableTextureView_maxScale, maxScale);\n    } finally {\n        a.recycle();\n    }\n    setOnTouchListener(new ZoomOnTouchListeners());\n}\npublic void deAttachFromWindow() {\n    onDetachedFromWindow();\n    onFinishTemporaryDetach();\n}\npublic void clearWindow() {\n    onDetachedFromWindow();\n    onFinishTemporaryDetach();\n}\nprivate class ZoomOnTouchListeners implements View.OnTouchListener {\n    public ZoomOnTouchListeners() {\n        super();\n        m = new float[9];\n        mScaleDetector = new ScaleGestureDetector(context, new ScaleListener());\n    }    \n    @Override\n    public boolean onTouch(View view, MotionEvent motionEvent) {\n        mScaleDetector.onTouchEvent(motionEvent);\n        matrix.getValues(m);\n        float x = m[Matrix.MTRANS_X];\n        float y = m[Matrix.MTRANS_Y];\n        PointF curr = new PointF(motionEvent.getX(), motionEvent.getY());\n        switch (motionEvent.getActionMasked()) {\n            case MotionEvent.ACTION_DOWN:\n                last.set(motionEvent.getX(), motionEvent.getY());\n                start.set(last);\n                mode = DRAG;\n                break;\n            case MotionEvent.ACTION_UP:\n                mode = NONE;\n                break;\n            case MotionEvent.ACTION_POINTER_DOWN:\n                last.set(motionEvent.getX(), motionEvent.getY());\n                start.set(last);\n                mode = ZOOM;\n                break;\n            case MotionEvent.ACTION_MOVE:\n                if (mode == ZOOM || (mode == DRAG &amp;&amp; saveScale &gt; minScale)) {\n                    float deltaX = curr.x - last.x;// x difference\n                    float deltaY = curr.y - last.y;// y difference\n                    if (y + deltaY &gt; 0)\n                        deltaY = -y;\n                    else if (y + deltaY &lt; -bottom)\n                        deltaY = -(y + bottom);\n                    if (x + deltaX &gt; 0)\n                        deltaX = -x;\n                    else if (x + deltaX &lt; -right)\n                        deltaX = -(x + right);\n                    matrix.postTranslate(deltaX, deltaY);\n                    last.set(curr.x, curr.y);\n                }\n                break;\n            case MotionEvent.ACTION_POINTER_UP:\n                mode = NONE;\n                break;\n        }\n        ZoomableTextureView.this.setTransform(matrix);\n        ZoomableTextureView.this.invalidate();\n        return true;\n    }\n    private class ScaleListener extends ScaleGestureDetector.SimpleOnScaleGestureListener {\n        @Override\n        public boolean onScaleBegin(ScaleGestureDetector detector) {\n            mode = ZOOM;\n            return true;\n        }\n        @Override\n        public boolean onScale(ScaleGestureDetector detector) {\n            float mScaleFactor = detector.getScaleFactor();\n            float origScale = saveScale;\n            saveScale *= mScaleFactor;\n            if (saveScale &gt; maxScale) {\n                saveScale = maxScale;\n                mScaleFactor = maxScale / origScale;\n            } else if (saveScale &lt; minScale) {\n                saveScale = minScale;\n                mScaleFactor = minScale / origScale;\n            }\n            MutableLiveData&lt;Float&gt; zoomScale = AppGlobal.Companion.getZoomScale();\n            zoomScale.setValue(saveScale); // Set the new value for zoomScale\n            right = getWidth() * saveScale - getWidth();\n            bottom = getHeight() * saveScale - getHeight();\n            if (0 &lt;= getWidth() || 0 &lt;= getHeight()) {              matrix.postScale(mScaleFactor,mScaleFactor,detector.getFocusX(),detector.getFocusY());\n                if (mScaleFactor &lt; 1) {\n                    matrix.getValues(m);\n                    float x = m[Matrix.MTRANS_X];\n                    float y = m[Matrix.MTRANS_Y];\n                    if (mScaleFactor &lt; 1) {\n                        if (0 &lt; getWidth()) {\n                            if (y &lt; -bottom)\n                                matrix.postTranslate(0, -(y + bottom));\n                            else if (y &gt; 0)\n                                matrix.postTranslate(0, -y);\n                        } else {\n                            if (x &lt; -right)\n                                matrix.postTranslate(-(x + right), 0);\n                            else if (x &gt; 0)\n                                matrix.postTranslate(-x, 0);\n                        }\n                    }\n                }\n            } else {\n                matrix.postScale(mScaleFactor, mScaleFactor, detector.getFocusX(), detector.getFocusY());\n                matrix.getValues(m);\n                float x = m[Matrix.MTRANS_X];\n                float y = m[Matrix.MTRANS_Y];\n                if (mScaleFactor &lt; 1) {\n                    if (x &lt; -right)\n                        matrix.postTranslate(-(x + right), 0);\n                    else if (x &gt; 0)\n                        matrix.postTranslate(-x, 0);\n                    if (y &lt; -bottom)\n                        matrix.postTranslate(0, -(y + bottom));\n                    else if (y &gt; 0)\n                        matrix.postTranslate(0, -y);\n                }\n            }\n            return true;\n        }\n    }\n}\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}