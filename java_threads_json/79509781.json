{
  "question": {
    "tags": [
      "java",
      "zos"
    ],
    "owner": {
      "account_id": 40171204,
      "reputation": 19,
      "user_id": 29646390,
      "user_type": "registered",
      "profile_image": "https://i.sstatic.net/UmVShSyE.jpg?s=256",
      "display_name": "user29646390",
      "link": "https://stackoverflow.com/users/29646390/user29646390"
    },
    "is_answered": false,
    "view_count": 83,
    "answer_count": 2,
    "score": 1,
    "last_activity_date": 1754161086,
    "creation_date": 1741972025,
    "last_edit_date": 1749029568,
    "question_id": 79509781,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79509781/java-jvm-for-ibm-zos-does-it-use-dfsms-i-o-efficiencies-such-as-large-bufno",
    "title": "Java JVM for IBM ZOS, does it use DFSMS I/O efficiencies such as large BUFNO?",
    "body": "<p>Looking at run time efficiencies on zOS 16 on 3931 mainframe with Java. We found on jobs running assembler level programs that specifying a large number of buffers when reading huge files reduces run times. Does the JVM exploit the zOS DFSMS subsystem directly?</p>\n<p>We know that specifying BUFNO=50 for large files read by other languages improves run time by reducing the number of physical I/O operations. We are designing testing for Java batch jobs with these changes in JCL BUFNO values, but we do not know how well the JVM interacts with the zOS host.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}