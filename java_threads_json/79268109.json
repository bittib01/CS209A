{
  "question": {
    "tags": [
      "java",
      "c++",
      "benchmarking",
      "jit"
    ],
    "owner": {
      "account_id": 38321090,
      "reputation": 228,
      "user_id": 28712954,
      "user_type": "registered",
      "profile_image": "https://i.sstatic.net/rsn0z2kZ.png?s=256",
      "display_name": "Joas Coder",
      "link": "https://stackoverflow.com/users/28712954/joas-coder"
    },
    "is_answered": true,
    "view_count": 1079,
    "accepted_answer_id": 79283500,
    "answer_count": 3,
    "score": 16,
    "last_activity_date": 1736775938,
    "creation_date": 1733830961,
    "last_edit_date": 1736775938,
    "question_id": 79268109,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79268109/c-implementation-of-a-simple-map-slower-than-equivalent-implementation-in-java",
    "title": "C++ implementation of a simple map slower than equivalent implementation in Java: Code/Benchmark Issue?",
    "body": "<p>The goal of this research is to explore the performance differences between JIT (just-in-time compilation) and AOT (ahead-of-time compilation) strategies and to understand their respective advantages and disadvantages. The intent is not to claim that one language is slower or worse than the other.<br />\nIn our tests, we observed better results with the HotSpot JVM 23 using JIT compilation (JVMCI and C2). We got slower results with C++ (compiled with Clang 18), GraalVM 23 (compiled with native-image), and HotSpot JVM 23 with the -Xcomp flag (JVMCI and C2). We are seeking to understand why this happens, and if possible, identify ways to improve the performance of the C++ version to match the results of Java's JIT compilation.</p>\n<p>Our benchmark involves comparing a simple and small hash table (map) implementation in Java to an equivalent (<em>line-by-line</em>) implementation in C++. We made every effort to ensure consistency between the two implementations. The goal is <em><strong>not</strong></em> to compare the standard library implementations of hash table (<code>java.util.HashMap</code> and <code>std::unordered_map</code>) as they are of course implemented with non-equivalent source code.</p>\n<p>The benchmark creates a hash table with 20,000 buckets and inserts 2,000,000 objects. We insert once, clear the map and then insert again, to take advantage of the <code>Entry</code> object internal object pool of the hash table. In other words, the first time you insert, objects are going to be allocated in the heap. The second time you insert objects are going to be re-used from the internal object pool.</p>\n<p>The <code>Bench</code> class, which handles the measurements, should also be equivalent in both languages.</p>\n<p><strong>Given these details, does anyone have insights into why the C++ map implementation was slower than the Java map implementation? Could there be something we overlooked or an aspect of the C++ implementation that could be optimized further? Perhaps specific Clang optimization options we should explore?</strong></p>\n<hr />\n<p>(This section added by @petercordes to describe in more detail what the benchmark does. And from discussion in comments with the OP, to describe what I think one of the goals is.)</p>\n<p><strong>The C++ version is written such that it could compile to similar machine code to what a JVM might JIT for the Java version.</strong>  How does Java manages to do the same machine operations as the C++ version but faster.</p>\n<p>(Editor's note (@petercordes): I have single-stepped the machine code generated by the Hotspot JVM, and indeed the main loops are linked-list linear searches, using 32-bit compressed references vs. <code>clang++</code> using native pointers.  Interrupting the JVM with GDB, usually RIP points to a place where the code spends most of its time.\n<code>clang++ -O3 ... -m32</code> is still slower, so it's not just 32-bit pointers, and the Java objects were still at least 24 bytes, not just 12 for 2 references + an int.  Probably something about allocation patterns and cache misses, since Java runs more machine instructions inside the loop and even has to <code>shl</code> by 3 to turn a 32-bit value into a pointer, so best-case load-use latency is worse.)</p>\n<p>The C++ version uses pointers extensively to mirror Java's semantics.  The &quot;values&quot; stored and retrieved are just pointers (all to the same dummy object).  It's probably not useful for most use-cases. For example, <code>put</code> takes an object by <code>const</code>-reference, i.e. a pointer in asm, while <code>get</code> returns it as a non-<code>const</code> pointer.  The hash table never dereferences the value pointer or deletes the pointed-to object; in Java the GC takes care of this.  In C++ it could hypothetically be used for building a map of objects owned by something else, or in automatic or static storage.  It could equivalently take a <code>uintptr_t</code> by value. (A reference is non-nullable but we don't depend on that.)</p>\n<p>The hash table is an array of linked lists (pointers in C++, with <code>nullptr</code> indicating on keys in that bucket).  With a load-factor of 100, this is really a linked-list benchmark, not normal operating conditions for a hash table.</p>\n<p>This was chosen to make the time for each operation long enough to measure with Linux <code>clock_gettime</code> as called from Java's <code>System.nanoTime</code> or Glibc's <code>chrono::steady_clock::now</code>.  Measurement overhead should be fairly equal in both languages, and very high compared to just a hash-bucket lookup that hits in cache, but pretty small compared to traversing a 50-element (average length) linked list.<br />\nThe <code>Bench</code> class itself also adds each time to a <code>std::map</code> in C++, or a custom hashmap in Java using a similar design to the hash table being benchmarked, used with a load factor well below 1.  This is outside the timed region but does need to do some allocation on the first run, so that will happen between every allocation of a node for the hash table being benchmarked.</p>\n<p>To attempt to minimize performance differences between Java's GC vs. non-GC C++, we use a free-list with unbounded size, only ever deleting in the destructor: if <code>remove()</code> finds a match, it moves the node from the bucket's linked list to the <code>head</code> of the free list.  <code>put</code> takes the head of the free list, only calling <code>new</code> if empty.  So <code>new</code> gets called only inside the first round of <code>put</code> calls, with the second (after <code>clear</code>) having to advance through the linked-list of nodes.  Which should be cheap because there's a whole linked-list search between allocations for out-of-order execution to hide the load latency even on a cache miss.</p>\n<p>The initial <code>put</code> stage is not the only one that's slower for the C++ version than the Java version, so it's not <em>just</em> raw performance of <code>new</code>.  Perhaps something about locality of allocations?</p>\n<hr />\n<p>All source code, which is not much, with scripts to compile and execute together with our results are in the open-source Github project <a href=\"https://github.com/coralblocks/CoralBench?tab=readme-ov-file#hotspotvm--xcomp-and-jit-vs-c-llvm-clang-vs-graalvm\" rel=\"nofollow noreferrer\">CoralBench</a>.</p>\n<p>From the comments below, it looks like <strong>a major source of improvement for the C++ code could be <em>custom allocators</em></strong> for the hash table internal <code>Entry</code> objects. It has been mentioned that Java has an easier/faster time allocating objects in the heap than C++, through the <code>new</code> keyword, but that this shortcoming can be addressed in C++ by using <strong>custom allocators</strong>. Unfortunately my knowledge of C++ is limited and I will have to do some research to understand how to do that. <strong>An answer here with such a change/improvement in the C++ code would be great.</strong></p>\n<p>It is important to note that <strong>on the second put benchmark, the C++ code will not be allocating any <code>Entry</code> in the heap</strong>, as the objects will be all available in the internal object pool (from the first put). Therefore I'm not sure why C++ is still slower on the second put benchmark.</p>\n<p>FTR, below are our current results for Java and C++:</p>\n<p><strong>HotSpotVM JIT: (with Graal JVMCI JIT)</strong></p>\n<pre><code>PUT =&gt; Avg: 371 ns | Min: 28 ns | 99.9% = [avg: 367 ns, max: 1.743 micros]\nPUT =&gt; Avg: 613 ns | Min: 27 ns | 99.9% = [avg: 606 ns, max: 2.184 micros]\nGET =&gt; Avg: 615 ns | Min: 14 ns | 99.9% = [avg: 607 ns, max: 2.549 micros]\nDEL =&gt; Avg: 662 ns | Min: 18 ns | 99.9% = [avg: 658 ns, max: 2.538 micros]\n</code></pre>\n<p><strong>HotSpotVM JIT: (with C2 JIT)</strong></p>\n<pre><code>PUT =&gt; Avg: 342 ns | Min: 29 ns | 99.9% = [avg: 338 ns, max: 1.661 micros]\nPUT =&gt; Avg: 596 ns | Min: 28 ns | 99.9% = [avg: 589 ns, max: 2.161 micros]\nGET =&gt; Avg: 599 ns | Min: 20 ns | 99.9% = [avg: 592 ns, max: 2.275 micros]\nDEL =&gt; Avg: 826 ns | Min: 23 ns | 99.9% = [avg: 817 ns, max: 3.420 micros]\n</code></pre>\n<p><strong>C++ LLVM: (clang)</strong></p>\n<pre><code>PUT =&gt; Avg: 726 ns | Min: 30 ns | 99.9% = [avg: 720 ns, max: 4.097 micros]\nPUT =&gt; Avg: 857 ns | Min: 18 ns | 99.9% = [avg: 848 ns, max: 2.933 micros]\nGET =&gt; Avg: 874 ns | Min: 18 ns | 99.9% = [avg: 865 ns, max: 3.010 micros]\nDEL =&gt; Avg: 875 ns | Min: 19 ns | 99.9% = [avg: 871 ns, max: 2.810 micros]\n</code></pre>\n<p><strong>GraalVM: (native-image)</strong></p>\n<pre><code>PUT =&gt; Avg: 190 ns | Min: 21 ns | 99.9% = [avg: 183 ns, max: 814 ns]\nPUT =&gt; Avg: 659 ns | Min: 23 ns | 99.9% = [avg: 656 ns, max: 2.762 micros]\nGET =&gt; Avg: 399 ns | Min: 21 ns | 99.9% = [avg: 396 ns, max: 2.124 micros]\nDEL =&gt; Avg: 323 ns | Min: 27 ns | 99.9% = [avg: 321 ns, max: 1.850 micros]\n</code></pre>\n<p><strong>Benchmark Environment:</strong></p>\n<pre><code>$ uname -a\nLinux hivelocity 4.15.0-20-generic #21-Ubuntu SMP Tue Apr 24 06:16:15 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n\n$ cat /etc/issue | head -n 1\nUbuntu 18.04.6 LTS \\n \\l\n\n$ cat /proc/cpuinfo | grep &quot;model name&quot; | head -n 1 | awk -F &quot;: &quot; '{print $NF}'\nIntel(R) Xeon(R) E-2288G CPU @ 3.70GHz\n\n$ arch\nx86_64\n\n$ clang++ --version\nUbuntu clang version 18.1.0 (++20240220094926+390dcd4cbbf5-1~exp1~20240220214944.50)\nTarget: x86_64-pc-linux-gnu\nThread model: posix\nInstalledDir: /usr/bin\n\n$ java -version\njava version &quot;23.0.1&quot; 2024-10-15\nJava(TM) SE Runtime Environment Oracle GraalVM 23.0.1+11.1 (build 23.0.1+11-jvmci-b01)\nJava HotSpot(TM) 64-Bit Server VM Oracle GraalVM 23.0.1+11.1 (build 23.0.1+11-jvmci-b01, mixed mode, sharing)\n\n$ native-image --version\nnative-image 23.0.1 2024-10-15\nGraalVM Runtime Environment Oracle GraalVM 23.0.1+11.1 (build 23.0.1+11-jvmci-b01)\nSubstrate VM Oracle GraalVM 23.0.1+11.1 (build 23.0.1+11, serial gc, compressed references)\n</code></pre>\n<p><strong>To compile the C++ code:</strong></p>\n<pre><code>rm -f target/cpp/int_map_benchmark target/cpp/int_map.o target/cpp/bench.o target/cpp/int_map_benchmark.o\n\nmkdir -p target/cpp\n\nclang++ -Ofast -march=native -flto -std=c++17 -I./src/main/c -c ./src/main/c/int_map.cpp -o ./target/cpp/int_map.o\nclang++ -Ofast -march=native -flto -std=c++17 -I./src/main/c -c ./src/main/c/bench.cpp -o ./target/cpp/bench.o\nclang++ -Ofast -march=native -flto -std=c++17 -I./src/main/c -c ./src/main/c/int_map_benchmark.cpp -o ./target/cpp/int_map_benchmark.o\n\nclang++ -Ofast -march=native -flto -std=c++17 -o ./target/cpp/int_map_benchmark ./target/cpp/int_map.o ./target/cpp/bench.o ./target/cpp/int_map_benchmark.o\n</code></pre>\n<p><strong>To run the C++ code:</strong></p>\n<pre><code>#!/bin/bash\n\nWARMUP=${1:-0}\nMEASUREMENTS=${2:-2000000}\nCAPACITY=${3:-20000}\n\n./target/cpp/int_map_benchmark $WARMUP $MEASUREMENTS $CAPACITY\n</code></pre>\n<p><strong>Below the C++ code:</strong></p>\n<pre><code>// =====&gt; bench.hpp\n#ifndef BENCH_HPP\n#define BENCH_HPP\n\n#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;iomanip&gt;\n#include &lt;string&gt;\n#include &lt;cmath&gt;\n#include &lt;map&gt;\n#include &lt;sstream&gt;\n\nclass Bench {\npublic:\n    Bench(int warmupCount = 0);\n    ~Bench();\n\n    void mark();\n    void measure();\n    bool measure(long long);\n    void reset();\n    void reset(bool);\n    void printResults() const;\n    void printResults(bool) const;\n    bool isWarmingUp() const;\n    int getIterations() const;\n    int getMeasurements() const;\n    double getAverage() const;\n\nprivate:\n    int warmupCount;\n    int measurementCount;\n    long long sum;\n    long long minTime;\n    long long maxTime;\n    int size;\n    std::map&lt;long long, long long&gt;* results;\n    std::chrono::steady_clock::time_point startTime;\n    \n    static std::string formatWithCommas(long long value);\n    static std::pair&lt;double, std::string&gt; formatTime(double nanos);\n    static std::string formatPercentage(double perc);\n    static double roundToDecimals(double d, int decimals);\n    void printPercentiles() const;\n    void addPercentile(double perc) const;\n    double avg() const;\n};\n\n#endif // BENCH_HPP\n\n// =====&gt; bench.cpp\n#include &quot;bench.hpp&quot;\nusing namespace std;\n\nBench::Bench(int warmupCount)\n    : warmupCount(warmupCount),\n      measurementCount(0),\n      sum(0),\n      minTime(numeric_limits&lt;long long&gt;::max()),\n      maxTime(numeric_limits&lt;long long&gt;::min()),\n      size(0) {\n\n        results = new map&lt;long long, long long&gt;();\n\n}\n\nBench::~Bench() {\n    delete results;\n}\n\nvoid Bench::mark() {\n    startTime = chrono::steady_clock::now();\n}\n\nvoid Bench::measure() {\n    auto endTime = chrono::steady_clock::now();\n    auto elapsed = chrono::duration_cast&lt;chrono::nanoseconds&gt;(endTime - startTime).count();\n    measure(elapsed);\n}\n\nbool Bench::measure(long long elapsed) {\n\n    bool isToMeasure = ++measurementCount &gt; warmupCount;\n\n    if (isToMeasure) {\n        sum += elapsed;\n        if (elapsed &lt; minTime) minTime = elapsed;\n        if (elapsed &gt; maxTime) maxTime = elapsed;\n\n        // Increment the frequency of this elapsed time\n        auto it = results-&gt;find(elapsed);\n        if (it == results-&gt;end()) {\n            results-&gt;insert({elapsed, 1});\n        } else {\n            it-&gt;second++;\n        }\n        size++;\n    }\n    \n    return isToMeasure;\n}\n\nint Bench::getIterations() const {\n    return measurementCount;\n}\n\nint Bench::getMeasurements() const {\n    return size;\n}\n\nvoid Bench::reset() {\n    reset(false);\n}\n\nvoid Bench::reset(bool repeatWarmup) {\n    measurementCount = 0;\n    sum = 0;\n    if (!repeatWarmup) warmupCount = 0;\n    minTime = numeric_limits&lt;long long&gt;::max();\n    maxTime = numeric_limits&lt;long long&gt;::min();\n    results-&gt;clear();\n    size = 0;\n}\n\nbool Bench::isWarmingUp() const {\n    return warmupCount &lt;= measurementCount;\n}\n\ndouble Bench::avg() const {\n    const int effectiveCount = measurementCount - warmupCount;\n    if (effectiveCount &lt;= 0) {\n        return 0;\n    }\n    const double avg = static_cast&lt;double&gt;(sum) / effectiveCount;\n    const double rounded = round(avg * 100.0) / 100.0;\n    return rounded;\n}\n\ndouble Bench::getAverage() const {\n    return avg();\n}   \n\nvoid Bench::printResults() const {\n    printResults(true);\n}\n\nvoid Bench::printResults(bool includePercentiles) const {\n\n    int effectiveCount = measurementCount - warmupCount;\n\n    string effCountStr = formatWithCommas(effectiveCount);\n    string warmupStr = formatWithCommas(warmupCount);\n    string totalStr = formatWithCommas(measurementCount);\n\n    cout &lt;&lt; &quot;Measurements: &quot; &lt;&lt; effCountStr\n         &lt;&lt; &quot; | Warm-Up: &quot; &lt;&lt; warmupStr\n         &lt;&lt; &quot; | Iterations: &quot; &lt;&lt; totalStr &lt;&lt; endl;\n         \n    if (effectiveCount &gt; 0) {\n\n        auto [avgVal, avgUnit] = formatTime(avg());\n        auto [minVal, minUnit] = formatTime(static_cast&lt;double&gt;(minTime));\n        auto [maxVal, maxUnit] = formatTime(static_cast&lt;double&gt;(maxTime));\n    \n        cout &lt;&lt; fixed &lt;&lt; setprecision(3);\n        cout &lt;&lt; &quot;Avg Time: &quot; &lt;&lt; avgVal &lt;&lt; &quot; &quot; &lt;&lt; avgUnit &lt;&lt; &quot; | &quot;\n             &lt;&lt; &quot;Min Time: &quot; &lt;&lt; minVal &lt;&lt; &quot; &quot; &lt;&lt; minUnit &lt;&lt; &quot; | &quot;\n             &lt;&lt; &quot;Max Time: &quot; &lt;&lt; maxVal &lt;&lt; &quot; &quot; &lt;&lt; maxUnit &lt;&lt; endl;\n    \n        if (includePercentiles) printPercentiles();\n    }\n    \n    cout &lt;&lt; endl;\n}\n\nstring Bench::formatWithCommas(long long value) {\n    string numStr = to_string(value);\n    int insertPosition = static_cast&lt;int&gt;(numStr.length()) - 3;\n    while (insertPosition &gt; 0) {\n        numStr.insert(insertPosition, &quot;,&quot;);\n        insertPosition -= 3;\n    }\n    return numStr;\n}\n\npair&lt;double, string&gt; Bench::formatTime(double nanos) {\n    if (nanos &gt;= 1'000'000'000.0) {\n        double seconds = nanos / 1'000'000'000.0;\n        return {roundToDecimals(seconds, 3), seconds &gt; 1 ? &quot;seconds&quot; : &quot;second&quot;};\n    } else if (nanos &gt;= 1'000'000.0) {\n        double millis = nanos / 1'000'000.0;\n        return {roundToDecimals(millis, 3), millis &gt; 1 ? &quot;millis&quot; : &quot;milli&quot;};\n    } else if (nanos &gt;= 1000.0) {\n        double micros = nanos / 1000.0;\n        return {roundToDecimals(micros, 3), micros &gt; 1 ? &quot;micros&quot; : &quot;micro&quot;};\n    } else {\n        double ns = nanos;\n        return {roundToDecimals(ns, 3), ns &gt; 1 ? &quot;nanos&quot; : &quot;nano&quot;};\n    }\n}\n\ndouble Bench::roundToDecimals(double d, int decimals) {\n    double pow10 = pow(10.0, decimals);\n    return round(d * pow10) / pow10;\n}\n\nvoid Bench::printPercentiles() const {\n\n    if (size == 0) return;\n\n    double percentiles[] = {0.75, 0.90, 0.99, 0.999, 0.9999, 0.99999};\n\n    for (double p : percentiles) {\n        addPercentile(p);\n    }\n}\n\nstring Bench::formatPercentage(double perc) {\n    double p = perc * 100.0;\n\n    ostringstream oss;\n    oss &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; p;\n\n    string s = oss.str();\n    // remove trailing zeros\n    while (s.back() == '0') {\n        s.pop_back();\n    }\n\n    // if the last character is now a '.', remove it\n    if (s.back() == '.') {\n        s.pop_back();\n    }\n\n    // Append the '%' sign\n    s += &quot;%&quot;;\n\n    return s;\n}\n\nvoid Bench::addPercentile(double perc) const {\n\n    if (results-&gt;empty()) return;\n\n    long long target = static_cast&lt;long long&gt;(llround(perc * size));\n    if (target == 0) return;\n    if (target &gt; size) target = size;\n\n    // Iterate through the map to find the top element at position target\n    long long iTop = 0;\n    long long sumTop = 0;\n    long long maxTop = -1;\n\n    for (auto &amp;entry : *results) {\n        long long time = entry.first;\n        long long count = entry.second;\n\n        for (int i = 0; i &lt; count; i++) {\n            iTop++;\n            sumTop += time;\n            if (iTop == target) {\n                maxTop = time;\n                goto FOUND;\n            }\n        }\n    }\n\nFOUND:;\n\n    double avgTop = static_cast&lt;double&gt;(sumTop) / iTop;\n    auto [avgVal, avgUnit] = formatTime(avgTop);\n    auto [maxVal, maxUnit] = formatTime(static_cast&lt;double&gt;(maxTop));\n\n    cout &lt;&lt; fixed &lt;&lt; setprecision(3);\n    cout &lt;&lt; formatPercentage(perc) &lt;&lt; &quot; = [avg: &quot; &lt;&lt; avgVal &lt;&lt; &quot; &quot; &lt;&lt; avgUnit\n         &lt;&lt; &quot;, max: &quot; &lt;&lt; maxVal &lt;&lt; &quot; &quot; &lt;&lt; maxUnit &lt;&lt; &quot;]\\n&quot;;\n}\n\n// =====&gt; int_map.hpp\n#ifndef INT_MAP_HPP\n#define INT_MAP_HPP\n\n#include &lt;optional&gt;\n#include &lt;cstddef&gt;\n\ntemplate &lt;typename E&gt;\nclass IntMap {\n\nprivate:\n\n    template &lt;typename T&gt;\n    struct Entry {\n        int key;\n        T* value; // removed unnecessary std::optional (thanks to Paul McKenzie at https://stackoverflow.com/users/3133316/paulmckenzie)\n        Entry&lt;T&gt;* next;\n    };\n\n    Entry&lt;E&gt;** data;\n    int count;\n    Entry&lt;E&gt;* head;\n    const int capacity;\n\n    Entry&lt;E&gt;* newEntry(int key, const E&amp; value, Entry&lt;E&gt;* next) {\n        Entry&lt;E&gt;* newEntry = head;\n\n        if (newEntry != nullptr) {\n            head = newEntry-&gt;next;\n        } else {\n            newEntry = new Entry&lt;E&gt;();\n        }\n\n        newEntry-&gt;key = key;\n        newEntry-&gt;value = const_cast&lt;E*&gt;(&amp;value);\n        newEntry-&gt;next = next;\n\n        return newEntry;\n    }\n\n    void free(Entry&lt;E&gt;* e) {\n        e-&gt;value = nullptr;\n        e-&gt;next = head;\n        head = e;\n    }\n\n    int toArrayIndex(int key) const {\n        return (key &amp; 0x7FFFFFFF) % capacity;\n    }\n\npublic:\n\n    IntMap(int capacity)\n        : capacity(capacity), count(0), head(nullptr) {\n        data = new Entry&lt;E&gt;*[capacity];\n        for (int i = 0; i &lt; capacity; i++) {\n            data[i] = nullptr;\n        }\n    }\n\n    ~IntMap() {\n        clear();\n\n        while (head != nullptr) {\n            Entry&lt;E&gt;* temp = head;\n            head = head-&gt;next;\n            delete temp;\n        }\n\n        delete[] data;\n    }\n\n    int size() const {\n        return count;\n    }\n\n    E* get(int key) const {\n        Entry&lt;E&gt;* e = data[toArrayIndex(key)];\n        while (e != nullptr) {\n            if (e-&gt;key == key) {\n                return e-&gt;value;\n            }\n            e = e-&gt;next;\n        }\n        return nullptr;\n    }\n\n    E* put(int key, const E&amp; value) {\n        int index = toArrayIndex(key);\n        Entry&lt;E&gt;* e = data[index];\n\n        while (e != nullptr) {\n            if (e-&gt;key == key) {\n                E* old = e-&gt;value;\n                e-&gt;value = const_cast&lt;E*&gt;(&amp;value);\n                return old;\n            }\n            e = e-&gt;next;\n        }\n\n        data[index] = newEntry(key, value, data[index]);\n        count++;\n        return nullptr;\n    }\n\n    E* remove(int key) {\n        int index = toArrayIndex(key);\n        Entry&lt;E&gt;* e = data[index];\n        Entry&lt;E&gt;* prev = nullptr;\n\n        while (e != nullptr) {\n            if (e-&gt;key == key) {\n                if (prev != nullptr) {\n                    prev-&gt;next = e-&gt;next;\n                } else {\n                    data[index] = e-&gt;next;\n                }\n\n                E* oldValue = e-&gt;value;\n                free(e);\n                count--;\n                return oldValue;\n            }\n            prev = e;\n            e = e-&gt;next;\n        }\n        return nullptr;\n    }\n\n    void clear() {\n        for (int index = capacity - 1; index &gt;= 0; index--) {\n            while (data[index] != nullptr) {\n                Entry&lt;E&gt;* next = data[index]-&gt;next;\n                free(data[index]);\n                data[index] = next;\n            }\n        }\n        count = 0;\n    }\n};\n\n#endif // INT_MAP_HPP\n\n// =====&gt; int_map.cpp\n#include &quot;int_map.hpp&quot;\n\n// NOOP\n\n// =====&gt; int_map_benchmark.cpp\n#include &quot;int_map.hpp&quot;\n#include &quot;bench.hpp&quot;\n\nusing namespace std;\n\nstruct Dummy {};\n\nint main(int argc, char* argv[]) {\n\n    int warmupCount = 1000000;\n    int measureCount = 1000000;\n    int capacity = 100000;\n\n    if (argc &gt; 1) {\n        warmupCount = atoi(argv[1]);\n    }\n    if (argc &gt; 2) {\n        measureCount = atoi(argv[2]);\n    }\n    if (argc &gt; 3) {\n        capacity = atoi(argv[3]);\n    }\n\n    cout &lt;&lt; &quot;\\nArguments: warmup=&quot; &lt;&lt; warmupCount &lt;&lt; &quot; measurements=&quot; &lt;&lt; measureCount &lt;&lt; &quot; mapCapacity=&quot; &lt;&lt; capacity &lt;&lt; endl &lt;&lt; endl;\n\n    int iterations = warmupCount + measureCount;\n\n    IntMap&lt;Dummy&gt;* map = new IntMap&lt;Dummy&gt;(capacity);\n    Bench bench(warmupCount);\n    Dummy dummy;\n\n    cout &lt;&lt; &quot;Benchmarking put on empty map... (1) =&gt; creating new Entry objects&quot; &lt;&lt; endl;\n    for (int i = 0; i &lt; iterations; i++) {\n        bench.mark();\n        map-&gt;put(i, dummy);\n        bench.measure();\n    }\n    bench.printResults();\n    \n    cout &lt;&lt; &quot;Benchmarking put after clear()... (2) =&gt; hitting the pool of Entry objects&quot; &lt;&lt; endl;\n    map-&gt;clear(); // clear the map, but the entry pool will be there\n    bench.reset(true);\n    for (int i = 0; i &lt; iterations; i++) {\n        bench.mark();\n        map-&gt;put(i, dummy);\n        bench.measure();\n    }\n    bench.printResults();\n\n    cout &lt;&lt; &quot;Benchmarking get...&quot; &lt;&lt; endl;\n    bench.reset(true);\n    for (int i = 0; i &lt; iterations; i++) {\n        bench.mark();\n        volatile auto val = map-&gt;get(i); // volatile to prevent optimization out\n        bench.measure();\n    }\n    bench.printResults();\n\n    cout &lt;&lt; &quot;Benchmarking remove...&quot; &lt;&lt; endl;\n    bench.reset(true);\n    for (int i = 0; i &lt; iterations; i++) {\n        bench.mark();\n        map-&gt;remove(i);\n        bench.measure();\n    }\n    bench.printResults();\n\n    delete map; \n    return 0;\n}\n</code></pre>\n<p><strong>Disclaimer:</strong> I'm one of the developers of the open-source project <a href=\"https://www.github.com/coralblocks/CoralBench\" rel=\"nofollow noreferrer\">CoralBench</a></p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}