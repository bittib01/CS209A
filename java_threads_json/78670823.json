{
  "question": {
    "tags": [
      "java",
      "spring",
      "spring-boot",
      "openai-api",
      "http-status-code-403"
    ],
    "owner": {
      "account_id": 24101774,
      "reputation": 11,
      "user_id": 18073517,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/6eb0d516a19a5cfba6c02716e388fc0c?s=256&d=identicon&r=PG",
      "display_name": "vbsc",
      "link": "https://stackoverflow.com/users/18073517/vbsc"
    },
    "is_answered": true,
    "view_count": 438,
    "accepted_answer_id": 78883399,
    "answer_count": 2,
    "score": 0,
    "last_activity_date": 1723934127,
    "creation_date": 1719386114,
    "question_id": 78670823,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78670823/endpoint-returning-403-after-successfully-executing-spring-boot",
    "title": "Endpoint returning 403 after successfully executing (Spring Boot)",
    "body": "<p>I made an endpoint &quot;/api/chat&quot; that, when called, makes another request to the OpenAI API (paid for and API key valid, all that). When testing the endpoint in Postman, I first request my /auth/login endpoint to get a valid JWT login token, copy that for the Authorization header of my /api/chat call, then send it (The login auth token is 100% valid, and works perfectly for all other endpoints as well).</p>\n<p>When the request to /api/chat is made, Postman takes around 1.5-2 seconds to process it. In the first second, my Run Console in Intellij logs the correct things to signify a request being made. For the remaining time, it then logs the exact expected response from the OpenAI API model. You would think this means everything executed fine, and it seemingly did, but then Postman (and my website if you try it there), returns 403 instead of 200 OK. This is an issue because even though I can physically see the correct response being logged in my IDE console with no errors, the 403 means I can't extract any of it for use and the website can't receive it and treats it like a completely failed request.</p>\n<p>The ONLY way that I &quot;fixed&quot; this was making the /api/chat endpoint public in my SecurityConfig file, which made it execute the exact same way and give the same result, but returns 200 OK as expected. However, I, of course, can't leave it like this as it would mean people have public access to make calls to an endpoint that costs me for each request.</p>\n<p>I've spent many hours trying to figure this out, including Googling, asking GPT - nothing. Verified all my JWT authentication stuff, tried something where the auth token is retained throughout, nothing worked. CORS and CSRF stuff, seemingly not that either. I can only think its something up with Spring Security because adding the endpoint to the .permitAll() list (making it public) in SecurityConfig is the only thing that made it return 200 OK as expected. This is extremely frustrating because it executes and logs exactly how and what it should, but just for some reason returns 403.</p>\n<p>This is my first project with Spring so if its something trivial then please help out. Thanks in advance. The API key is set in my env variables, and even though I've included some error logging, no errors are ever logged, only the correct responses that I'm expecting from the AI model, with it then returning 403 as I've mentioned. I'll include the relevant bits of code, but if you think the issue is in another file or part of these files, let me know and I'll share what I can. Not that it's too important I don't think, but I'm using React for frontend.</p>\n<p>:</p>\n<p>Security Config:</p>\n<pre><code>@Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http.csrf()\n                .disable()\n                .authorizeHttpRequests(authorize -&gt; authorize\n                        .requestMatchers(&quot;/auth/**&quot;, &quot;/&quot;, &quot;/index.html&quot;, &quot;/manifest.json&quot;, &quot;/static/**&quot;, &quot;/*.js&quot;, &quot;/*.jsx&quot;, &quot;/*.css&quot;, &quot;/home&quot;, &quot;/log-in&quot;, &quot;/sign-up&quot;)\n                        .permitAll()\n                        .requestMatchers(&quot;/auth/signup&quot;, &quot;/auth/login&quot;).anonymous()\n                        .anyRequest()\n                        .authenticated()\n                )\n                .sessionManagement(session -&gt; session\n                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                )\n                .authenticationProvider(authenticationProvider)\n                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);\n\n        return http.build();\n</code></pre>\n<p>Controller:</p>\n<pre><code>@PostMapping\n    public Mono&lt;ResponseEntity&lt;String&gt;&gt; getChatCompletion(@RequestBody ChatRequest chatRequest, @RequestHeader HttpHeaders headers) {\n\n        return openAiService.getChatCompletion(chatRequest.getInput())\n                .map(response -&gt; {\n                    logger.info(&quot;Response: {}&quot;, response); // Logging response\n                    return ResponseEntity.ok(response);\n                })\n                .defaultIfEmpty(ResponseEntity.noContent().build());\n    }\n\n    public static class ChatRequest {\n        private String input;\n\n        public String getInput() {\n            return input;\n        }\n\n        public void setInput(String input) {\n            this.input = input;\n        }\n    }\n</code></pre>\n<p>Service:</p>\n<pre><code>public Mono&lt;String&gt; getChatCompletion(String userInput) {\n        String requestBody = String.format(&quot;&quot;&quot;\n                {\n                    &quot;model&quot;: &quot;gpt-3.5-turbo&quot;,\n                    &quot;messages&quot;: [\n                        {\n                            &quot;role&quot;: &quot;system&quot;,\n                            &quot;content&quot;: &quot;MY CONTENT&quot;\n                        },\n                        {\n                            &quot;role&quot;: &quot;user&quot;,\n                            &quot;content&quot;: &quot;%s&quot;\n                        }\n                    ],\n                    &quot;temperature&quot;: 1,\n                    &quot;max_tokens&quot;: 256,\n                    &quot;top_p&quot;: 1,\n                    &quot;frequency_penalty&quot;: 0,\n                    &quot;presence_penalty&quot;: 0\n                }\n                &quot;&quot;&quot;, userInput);\n\n        logger.info(&quot;Sending request to OpenAI with body: {}&quot;, requestBody);\n\n        return this.webClient.post()\n                .uri(&quot;/chat/completions&quot;)\n                .header(&quot;Content-Type&quot;, &quot;application/json&quot;)\n                .header(&quot;Authorization&quot;, &quot;Bearer &quot; + openaiApiKey)\n                .bodyValue(requestBody)\n                .retrieve()\n                .bodyToMono(String.class)\n                .doOnNext(response -&gt; logger.info(&quot;Received response from OpenAI: {}&quot;, response))\n                .doOnError(WebClientResponseException.class, error -&gt; {\n                    logger.error(&quot;Error response from OpenAI: {}&quot;, error.getResponseBodyAsString());\n                })\n                .doOnError(error -&gt; logger.error(&quot;Error occurred: &quot;, error));\n    }\n</code></pre>\n<p>My Postman request (not too relevant, this is not the issue):</p>\n<pre><code>{\ninput: &quot;MY INPUT&quot;\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}