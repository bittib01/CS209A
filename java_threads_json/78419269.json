{
  "question": {
    "tags": [
      "java",
      "android",
      "service",
      "bluetooth"
    ],
    "owner": {
      "account_id": 32008611,
      "reputation": 1,
      "user_id": 24815990,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/38896650b9a96f3d478e7b04e2e57e05?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "user24815990",
      "link": "https://stackoverflow.com/users/24815990/user24815990"
    },
    "is_answered": false,
    "view_count": 107,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1719477364,
    "creation_date": 1714654102,
    "last_edit_date": 1714742421,
    "question_id": 78419269,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78419269/null-object-reference-when-trying-to-use-my-bluetooth-service-in-android",
    "title": "Null object reference when trying to use my bluetooth service in android",
    "body": "<p>I have created a bluetooth service that should be handling the connection in the background after it has connected with the other device. I currently have 2 files where one is the service and the other one is an activity that interacts with the service to establish a connection. My service code looks like this:</p>\n<pre><code>public class BTservice extends Service {\n\n\n\n    private static final String TAG = &quot;BluetoothConnectionServ&quot;;\n\n    private static final String appName = &quot;MYAPP&quot;;\n\n    private static final UUID MY_UUID_INSECURE =\n            UUID.fromString(&quot;8ce255c0-200a-11e0-ac64-0800200c9a66&quot;);\n\n\n    Context mContext;\n\n    private AcceptThread mInsecureAcceptThread;\n\n    private ConnectThread mConnectThread;\n    private BluetoothDevice mmDevice;\n    private UUID deviceUUID;\n    ProgressDialog mProgressDialog;\n\n    private ConnectedThread mConnectedThread;\n\n    BluetoothDevice mBTDevice;\n\n    public ArrayList&lt;BluetoothDevice&gt; mBTDevices = new ArrayList&lt;&gt;();\n\n    public DeviceListAdapter mDeviceListAdapter;\n\n    ListView lvNewDevices;\n\n    public BluetoothAdapter mBluetoothAdapter;\n\n\n    public BTservice(Context context) {\n        mContext = context;\n        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();\n        start();\n    }\n\n\n    public BTservice(){\n        super();\n\n    }\n    private class AcceptThread extends Thread {\n\n        // The local server socket\n        private final BluetoothServerSocket mmServerSocket;\n\n        public AcceptThread(){\n            BluetoothServerSocket tmp = null;\n\n            // Create a new listening server socket\n            try{\n                tmp = mBluetoothAdapter.listenUsingInsecureRfcommWithServiceRecord(appName, MY_UUID_INSECURE);\n\n                Log.d(TAG, &quot;AcceptThread: Setting up Server using: &quot; + MY_UUID_INSECURE);\n            }catch (IOException e){\n                Log.e(TAG, &quot;AcceptThread: IOException: &quot; + e.getMessage() );\n            }\n\n            mmServerSocket = tmp;\n        }\n\n        public void run(){\n            Log.d(TAG, &quot;run: AcceptThread Running.&quot;);\n\n            BluetoothSocket socket = null;\n\n            try{\n                // This is a blocking call and will only return on a\n                // successful connection or an exception\n                Log.d(TAG, &quot;run: RFCOM server socket start.....&quot;);\n\n                socket = mmServerSocket.accept();\n\n                Log.d(TAG, &quot;run: RFCOM server socket accepted connection.&quot;);\n\n            }catch (IOException e){\n                Log.e(TAG, &quot;AcceptThread: IOException: &quot; + e.getMessage() );\n            }\n\n            //talk about this is in the 3rd\n            if(socket != null){\n                connected(socket,mmDevice);\n            }\n\n            Log.i(TAG, &quot;END mAcceptThread &quot;);\n        }\n\n        public void cancel() {\n            Log.d(TAG, &quot;cancel: Canceling AcceptThread.&quot;);\n            try {\n                mmServerSocket.close();\n            } catch (IOException e) {\n                Log.e(TAG, &quot;cancel: Close of AcceptThread ServerSocket failed. &quot; + e.getMessage() );\n            }\n        }\n\n    }\n\n    /**\n     * This thread runs while attempting to make an outgoing connection\n     * with a device. It runs straight through; the connection either\n     * succeeds or fails.\n     */\n    private class ConnectThread extends Thread {\n        private BluetoothSocket mmSocket;\n\n        public ConnectThread(BluetoothDevice device, UUID uuid) {\n            Log.d(TAG, &quot;ConnectThread: started.&quot;);\n            mmDevice = device;\n            deviceUUID = uuid;\n        }\n\n        public void run(){\n            BluetoothSocket tmp = null;\n            Log.i(TAG, &quot;RUN mConnectThread &quot;);\n\n            // Get a BluetoothSocket for a connection with the\n            // given BluetoothDevice\n            try {\n                Log.d(TAG, &quot;ConnectThread: Trying to create InsecureRfcommSocket using UUID: &quot;\n                        +MY_UUID_INSECURE );\n                tmp = mmDevice.createRfcommSocketToServiceRecord(deviceUUID);\n            } catch (IOException e) {\n                Log.e(TAG, &quot;ConnectThread: Could not create InsecureRfcommSocket &quot; + e.getMessage());\n            }\n\n            mmSocket = tmp;\n\n            // Always cancel discovery because it will slow down a connection\n            mBluetoothAdapter.cancelDiscovery();\n\n            // Make a connection to the BluetoothSocket\n\n            try {\n                // This is a blocking call and will only return on a\n                // successful connection or an exception\n                mmSocket.connect();\n\n                Log.d(TAG, &quot;run: ConnectThread connected.&quot;);\n            } catch (IOException e) {\n                // Close the socket\n                try {\n                    mmSocket.close();\n                    Log.d(TAG, &quot;run: Closed Socket.&quot;);\n                } catch (IOException e1) {\n                    Log.e(TAG, &quot;mConnectThread: run: Unable to close connection in socket &quot; + e1.getMessage());\n                }\n                Log.d(TAG, &quot;run: ConnectThread: Could not connect to UUID: &quot; + MY_UUID_INSECURE );\n            }\n\n            //will talk about this in the 3rd video\n            connected(mmSocket,mmDevice);\n        }\n        public void cancel() {\n            try {\n                Log.d(TAG, &quot;cancel: Closing Client Socket.&quot;);\n                mmSocket.close();\n            } catch (IOException e) {\n                Log.e(TAG, &quot;cancel: close() of mmSocket in Connectthread failed. &quot; + e.getMessage());\n            }\n        }\n    }\n\n    public synchronized void start() {\n        Log.d(TAG, &quot;start&quot;);\n\n        // Cancel any thread attempting to make a connection\n        if (mConnectThread != null) {\n            mConnectThread.cancel();\n            mConnectThread = null;\n        }\n        if (mInsecureAcceptThread == null) {\n            mInsecureAcceptThread = new AcceptThread();\n            mInsecureAcceptThread.start();\n        }\n    }\n\n    /**\n\n     AcceptThread starts and sits waiting for a connection.\n     Then ConnectThread starts and attempts to make a connection with the other devices AcceptThread.\n     **/\n\n    public void startClient(BluetoothDevice device,UUID uuid){\n        Log.d(TAG, &quot;startClient: Started.&quot;);\n\n        //initprogress dialog\n        mProgressDialog = ProgressDialog.show(mContext,&quot;Connecting Bluetooth&quot;\n                ,&quot;Please Wait...&quot;,true);\n\n        mConnectThread = new ConnectThread(device, uuid);\n        mConnectThread.start();\n    }\n\n    private class ConnectedThread extends Thread {\n        private final BluetoothSocket mmSocket;\n        private final InputStream mmInStream;\n        private final OutputStream mmOutStream;\n\n        public ConnectedThread(BluetoothSocket socket) {\n            Log.d(TAG, &quot;ConnectedThread: Starting.&quot;);\n\n            mmSocket = socket;\n            InputStream tmpIn = null;\n            OutputStream tmpOut = null;\n\n            //dismiss the progressdialog when connection is established\n            try{\n                mProgressDialog.dismiss();\n            }catch (NullPointerException e){\n                e.printStackTrace();\n            }\n\n\n            try {\n                tmpIn = mmSocket.getInputStream();\n                tmpOut = mmSocket.getOutputStream();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n            mmInStream = tmpIn;\n            mmOutStream = tmpOut;\n        }\n\n        public void run(){\n            byte[] buffer = new byte[1024];  // buffer store for the stream\n\n            int bytes; // bytes returned from read()\n\n            // Keep listening to the InputStream until an exception occurs\n            while (true) {\n                // Read from the InputStream\n                try {\n                    bytes = mmInStream.read(buffer);\n                    String incomingMessage = new String(buffer, 0, bytes);\n                    Log.d(TAG, &quot;InputStream: &quot; + incomingMessage);\n                    Intent incomingMessageIntent = new Intent(&quot;incomingMessage&quot;);\n                    incomingMessageIntent.putExtra(&quot;incomingMessage&quot;, incomingMessage);\n\n                } catch (IOException e) {\n                    Log.e(TAG, &quot;write: Error reading Input Stream. &quot; + e.getMessage() );\n                    break;\n                }\n            }\n        }\n\n        //Call this from the main activity to send data to the remote device\n        public void write(byte[] bytes) {\n            String text = new String(bytes, Charset.defaultCharset());\n            Log.d(TAG, &quot;write: Writing to outputstream: &quot; + text);\n            try {\n                mmOutStream.write(bytes);\n            } catch (IOException e) {\n                Log.e(TAG, &quot;write: Error writing to output stream. &quot; + e.getMessage() );\n            }\n        }\n\n        /* Call this from the main activity to shutdown the connection */\n        public void cancel() {\n            try {\n                mmSocket.close();\n            } catch (IOException e) { }\n        }\n    }\n\n    private void connected(BluetoothSocket mmSocket, BluetoothDevice mmDevice) {\n        Log.d(TAG, &quot;connected: Starting.&quot;);\n\n        // Start the thread to manage the connection and perform transmissions\n        mConnectedThread = new ConnectedThread(mmSocket);\n        mConnectedThread.start();\n    }\n\n    /**\n     * Write to the ConnectedThread in an unsynchronized manner\n     *\n     * @param out The bytes to write\n     * @see ConnectedThread#write(byte[])\n     */\n    public void write(byte[] out) {\n        // Create temporary object\n        ConnectedThread r;\n\n        // Synchronize a copy of the ConnectedThread\n        Log.d(TAG, &quot;write: Write Called.&quot;);\n        //perform the write\n        mConnectedThread.write(out);\n    }\n\n    public final BroadcastReceiver mBroadcastReceiver1 = new BroadcastReceiver() {\n        public void onReceive(Context context, Intent intent) {\n            String action = intent.getAction();\n            // When discovery finds a device\n            if (action.equals(mBluetoothAdapter.ACTION_STATE_CHANGED)) {\n                final int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, mBluetoothAdapter.ERROR);\n\n                switch(state){\n                    case BluetoothAdapter.STATE_OFF:\n                        Log.d(TAG, &quot;onReceive: STATE OFF&quot;);\n                        break;\n                    case BluetoothAdapter.STATE_TURNING_OFF:\n                        Log.d(TAG, &quot;mBroadcastReceiver1: STATE TURNING OFF&quot;);\n                        break;\n                    case BluetoothAdapter.STATE_ON:\n                        Log.d(TAG, &quot;mBroadcastReceiver1: STATE ON&quot;);\n                        break;\n                    case BluetoothAdapter.STATE_TURNING_ON:\n                        Log.d(TAG, &quot;mBroadcastReceiver1: STATE TURNING ON&quot;);\n                        break;\n                }\n            }\n        }\n    };\n    public final BroadcastReceiver mBroadcastReceiver2 = new BroadcastReceiver() {\n\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n\n            if (action.equals(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED)) {\n\n                int mode = intent.getIntExtra(BluetoothAdapter.EXTRA_SCAN_MODE, BluetoothAdapter.ERROR);\n\n                switch (mode) {\n                    //Device is in Discoverable Mode\n                    case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                        Log.d(TAG, &quot;mBroadcastReceiver2: Discoverability Enabled.&quot;);\n                        break;\n                    //Device not in discoverable mode\n                    case BluetoothAdapter.SCAN_MODE_CONNECTABLE:\n                        Log.d(TAG, &quot;mBroadcastReceiver2: Discoverability Disabled. Able to receive connections.&quot;);\n                        break;\n                    case BluetoothAdapter.SCAN_MODE_NONE:\n                        Log.d(TAG, &quot;mBroadcastReceiver2: Discoverability Disabled. Not able to receive connections.&quot;);\n                        break;\n                    case BluetoothAdapter.STATE_CONNECTING:\n                        Log.d(TAG, &quot;mBroadcastReceiver2: Connecting....&quot;);\n                        break;\n                    case BluetoothAdapter.STATE_CONNECTED:\n                        Log.d(TAG, &quot;mBroadcastReceiver2: Connected.&quot;);\n                        break;\n                }\n\n            }\n        }\n    };\n\n\n\n\n    /**\n     * Broadcast Receiver for listing devices that are not yet paired\n     * -Executed by btnDiscover() method.\n     */\n    public BroadcastReceiver mBroadcastReceiver3 = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n            Log.d(TAG, &quot;onReceive: ACTION FOUND.&quot;);\n\n            if (action.equals(BluetoothDevice.ACTION_FOUND)){\n                BluetoothDevice device = intent.getParcelableExtra (BluetoothDevice.EXTRA_DEVICE);\n                mBTDevices.add(device);\n                Log.d(TAG, &quot;onReceive: &quot; + device.getName() + &quot;: &quot; + device.getAddress());\n                mDeviceListAdapter = new DeviceListAdapter(context, R.layout.device_adapter_view, mBTDevices);\n                lvNewDevices.setAdapter(mDeviceListAdapter);\n            }\n        }\n    };\n\n    /**\n     * Broadcast Receiver that detects bond state changes (Pairing status changes)\n     */\n    public final BroadcastReceiver mBroadcastReceiver4 = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            final String action = intent.getAction();\n\n            if(action.equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED)){\n                BluetoothDevice mDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);\n                //3 cases:\n                //case1: bonded already\n                if (mDevice.getBondState() == BluetoothDevice.BOND_BONDED){\n                    Log.d(TAG, &quot;BroadcastReceiver: BOND_BONDED.&quot;);\n                    //inside BroadcastReceiver4\n                    mBTDevice = mDevice;\n                }\n                //case2: creating a bone\n                if (mDevice.getBondState() == BluetoothDevice.BOND_BONDING) {\n                    Log.d(TAG, &quot;BroadcastReceiver: BOND_BONDING.&quot;);\n                }\n                //case3: breaking a bond\n                if (mDevice.getBondState() == BluetoothDevice.BOND_NONE) {\n                    Log.d(TAG, &quot;BroadcastReceiver: BOND_NONE.&quot;);\n                }\n            }\n        }\n    };\n    public class LocalBinder extends Binder{\n        public void startConnection(){\n            startBTConnection(mBTDevice,MY_UUID_INSECURE);\n        }\n\n        /**\n         * starting chat service method\n         */\n        public void startBTConnection(BluetoothDevice device, UUID uuid){\n            Log.d(TAG, &quot;startBTConnection: Initializing RFCOM Bluetooth Connection.&quot;);\n\n            startClient(device,uuid);\n        }\n\n\n\n        public void enableDisableBT(){\n            if(mBluetoothAdapter == null){\n                Log.d(TAG, &quot;enableDisableBT: Does not have BT capabilities.&quot;);\n            }\n            if(!mBluetoothAdapter.isEnabled()){\n                Log.d(TAG, &quot;enableDisableBT: enabling BT.&quot;);\n                Intent enableBTIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);\n                startActivity(enableBTIntent);\n\n                IntentFilter BTIntent = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);\n                registerReceiver(mBroadcastReceiver1, BTIntent);\n            }\n            if(mBluetoothAdapter.isEnabled()){\n                Log.d(TAG, &quot;enableDisableBT: disabling BT.&quot;);\n                mBluetoothAdapter.disable();\n\n                IntentFilter BTIntent = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);\n                registerReceiver(mBroadcastReceiver1, BTIntent);\n            }\n\n        }\n        public void enableDisc(){\n            Intent discoverableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);\n            discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300);\n            startActivity(discoverableIntent);\n\n            IntentFilter intentFilter = new IntentFilter(mBluetoothAdapter.ACTION_SCAN_MODE_CHANGED);\n            registerReceiver(mBroadcastReceiver2,intentFilter);\n        }\n\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        unregisterReceiver(mBroadcastReceiver1);\n        unregisterReceiver(mBroadcastReceiver2);\n        unregisterReceiver(mBroadcastReceiver3);\n        unregisterReceiver(mBroadcastReceiver4);\n    }\n\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        return START_STICKY;\n    }\n\n    @Nullable\n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n\n\n}\n</code></pre>\n<p>And my activity interacting with the service looks like this:</p>\n<pre><code>public class BTconnect2 extends AppCompatActivity implements AdapterView.OnItemClickListener{\n\n    private static final String TAG = &quot;BTconnect&quot;;\n    BluetoothAdapter mBluetoothAdapter;\n    Button btnEnableDisable_Discoverable;\n\n\n    BTservice.LocalBinder mBTserviceLocalBinder;\n    BTservice mBTservice;\n\n    Button btnStartConnection;\n    Button btnSend;\n    Button backbtn;\n    Button test2;\n\n    EditText etSend;\n    String text = &quot;this is a test&quot;;\n\n    private static final UUID MY_UUID_INSECURE =\n            UUID.fromString(&quot;8ce255c0-200a-11e0-ac64-0800200c9a66&quot;);\n\n    BluetoothDevice mBTDevice;\n\n    public ArrayList&lt;BluetoothDevice&gt; mBTDevices = new ArrayList&lt;&gt;();\n\n    public DeviceListAdapter mDeviceListAdapter;\n\n    ListView lvNewDevices;\n\n\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        startService(new Intent(this, BTservice.class));\n\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.btconnect);\n        Button btnONOFF = (Button) findViewById(R.id.btnONOFF);\n        btnEnableDisable_Discoverable = (Button) findViewById(R.id.btnDiscoverable_on_off);\n        lvNewDevices = (ListView) findViewById(R.id.lvNewDevices);\n        mBTDevices = new ArrayList&lt;&gt;();\n\n        btnStartConnection = (Button) findViewById(R.id.btnStartConnection);\n        btnSend = (Button) findViewById(R.id.btnSend);\n        etSend = (EditText) findViewById(R.id.editText);\n        backbtn = (Button) findViewById(R.id.backbtn);\n        test2 = (Button) findViewById(R.id.testbutton2);\n\n        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();\n\n        lvNewDevices.setOnItemClickListener(BTconnect2.this);\n\n\n        btnONOFF.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                Log.d(TAG, &quot;onClick: enabling/disabling bluetooth.&quot;);\n                mBTserviceLocalBinder.enableDisableBT();\n            }\n        });\n\n        btnStartConnection.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                mBTserviceLocalBinder.startConnection();\n            }\n        });\n\n        btnSend.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                byte[] bytes = etSend.getText().toString().getBytes(Charset.defaultCharset());\n                mBTservice.write(bytes);\n            }\n        });\n\n        backbtn.setOnClickListener((new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                startActivity(new Intent(BTconnect2.this, MainActivity.class));\n            }\n        }));\n\n        test2.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                byte[] bytes = text.getBytes(Charset.defaultCharset());\n                mBTservice.write(bytes);\n            }\n        });\n    }\n\n    public void btnEnableDisable_Discoverable(View view) {\n        Log.d(TAG, &quot;btnEnableDisable_Discoverable: Making device discoverable for 300 seconds.&quot;);\n        mBTserviceLocalBinder.enableDisc();\n\n    }\n\n    public void btnDiscover(View view) {\n        Log.d(TAG, &quot;btnDiscover: Looking for unpaired devices.&quot;);\n\n        if(mBluetoothAdapter.isDiscovering()){\n            mBluetoothAdapter.cancelDiscovery();\n            Log.d(TAG, &quot;btnDiscover: Canceling discovery.&quot;);\n\n            //check BT permissions in manifest\n            checkBTPermissions();\n\n            mBluetoothAdapter.startDiscovery();\n            IntentFilter discoverDevicesIntent = new IntentFilter(BluetoothDevice.ACTION_FOUND);\n            registerReceiver(mBTservice.mBroadcastReceiver3, discoverDevicesIntent);\n        }\n        if(!mBluetoothAdapter.isDiscovering()){\n\n            //check BT permissions in manifest\n            checkBTPermissions();\n\n            mBluetoothAdapter.startDiscovery();\n            IntentFilter discoverDevicesIntent = new IntentFilter(BluetoothDevice.ACTION_FOUND);\n            registerReceiver(mBTservice.mBroadcastReceiver3, discoverDevicesIntent);\n        }\n    }\n\n    /**\n     * This method is required for all devices running API23+\n     * Android must programmatically check the permissions for bluetooth. Putting the proper permissions\n     * in the manifest is not enough.\n     *\n     * NOTE: This will only execute on versions &gt; LOLLIPOP because it is not needed otherwise.\n     */\n    private void checkBTPermissions(){\n        if(Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.LOLLIPOP){\n            int permissionCheck = this.checkSelfPermission(&quot;Manifest.permission.ACCESS_FINE_LOCATION&quot;);\n            permissionCheck += this.checkSelfPermission(&quot;Manifest.permission.ACCESS_COARSE_LOCATION&quot;);\n            if (permissionCheck != 0) {\n\n                this.requestPermissions(new String[]{Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION}, 1001); //Any number\n            }\n        }else{\n            Log.d(TAG, &quot;checkBTPermissions: No need to check permissions. SDK version &lt; LOLLIPOP.&quot;);\n        }\n    }\n\n\n\n\n\n\n\n\n    @Override\n    public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l){\n        //first cancel discovery because its very memory intensive.\n        mBluetoothAdapter.cancelDiscovery();\n\n        Log.d(TAG, &quot;onItemClick: You Clicked on a device.&quot;);\n        String deviceName = mBTDevices.get(i).getName();\n        String deviceAddress = mBTDevices.get(i).getAddress();\n\n        Log.d(TAG, &quot;onItemClick: deviceName = &quot; + deviceName);\n        Log.d(TAG, &quot;onItemClick: deviceAddress = &quot; + deviceAddress);\n\n        //create the bond.\n        //NOTE: Requires API 17+? I think this is JellyBean\n        if(Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN_MR2){\n            Log.d(TAG, &quot;Trying to pair with &quot; + deviceName);\n            mBTDevices.get(i).createBond();\n\n            mBTDevice = mBTDevices.get(i);\n            mBTservice= new BTservice(BTconnect2.this);\n        }\n    }\n\n\n\n\n}\n</code></pre>\n<p>However, whenever i try to use any of the buttons i get an error about a null object reference for example trying to enable bluetooth:</p>\n<pre><code>2024-11-13 19:20:34.590 20202-20202/com.example.bluetooth E/AndroidRuntime: FATAL EXCEPTION: main\n    Process: com.example.bluetooth, PID: 20202\n    java.lang.NullPointerException: Attempt to invoke virtual method 'void com.example.bluetooth.BTservice$LocalBinder.enableDisableBT()' on a null object reference\n        at com.example.bluetooth.BTconnect2$1.onClick(BTconnect2.java:86)\n        at android.view.View.performClick(View.java:5205)\n        at com.google.android.material.button.MaterialButton.performClick(MaterialButton.java:1119)\n        at android.view.View$PerformClick.run(View.java:21164)\n        at android.os.Handler.handleCallback(Handler.java:739)\n        at android.os.Handler.dispatchMessage(Handler.java:95)\n        at android.os.Looper.loop(Looper.java:148)\n        at android.app.ActivityThread.main(ActivityThread.java:5417)\n        at java.lang.reflect.Method.invoke(Native Method)\n        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\n\n</code></pre>\n<p>this is essentially the same error with all the buttons. Am i missing an object that needs to be parsed or why do i get this error?</p>\n<p>I have tried implementing the functionality of the buttons in both the service and the interacting part of the app but neither works and returns the error about a null object reference.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}