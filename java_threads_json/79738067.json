{
  "question": {
    "tags": [
      "java",
      "multithreading",
      "algorithm",
      "optimization"
    ],
    "owner": {
      "account_id": 15839337,
      "reputation": 515,
      "user_id": 11428287,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/8d555921e5e180565f61ac9a2ac7a678?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "MC From Scratch",
      "link": "https://stackoverflow.com/users/11428287/mc-from-scratch"
    },
    "is_answered": false,
    "view_count": 258,
    "answer_count": 0,
    "score": 3,
    "last_activity_date": 1755621325,
    "creation_date": 1755459492,
    "last_edit_date": 1755462390,
    "question_id": 79738067,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79738067/iterating-over-special-semiprimes",
    "title": "Iterating over special semiprimes",
    "body": "<p>For a project of mine related to prime counting, I am interested in iterating over special kind of semiprimes.</p>\n<p>For a given <code>n</code>, I want to iterate over semiprimes <code>k=pq</code> with the following properties/demands:</p>\n<ol>\n<li><code>k &lt;= n^(2/3)</code></li>\n<li><code>p,q</code> primes</li>\n<li><code>p&lt;q</code></li>\n<li><code>q &lt;= sqrt(n/p)</code></li>\n<li><code>p &lt;= cbrt(n)</code></li>\n<li>It is essential to be able to reconstruct <code>k,p,q</code> in constant time</li>\n</ol>\n<p>I want to emphasize that I am not interested in counting them, but rather to iterate over them/generate them, for some use.</p>\n<p>The best approach I could think of is a variation of the sieve of Eratosthenes. I am aiming for very large <code>n</code>, around <code>10^18</code> and possibly beyond after translating to <code>c++</code>, so it has to be a segmented sieve. It's also favorable in terms of space.</p>\n<p>With 13900k processor, the following code completes the task for <code>n=10^15</code> in 57 seconds while finding there are <code>144611615</code> such <code>k</code>:</p>\n<pre><code>import java.util.*;\n\npublic class Result {\n\n    static final int SEGMENT_SIZE = 1 &lt;&lt; 16;\n    \n    public static void main(String[] args) \n    {\n        long start = System.nanoTime();\n        \n        long n = (long) 1e15;\n        \n        System.out.println(S(n));\n        \n        long end = System.nanoTime();\n        System.out.println(&quot;Iteration complete in: &quot;+(end - start) / (1000000L) + &quot; ms&quot;);\n    }\n\n    static long S (long n)\n    {\n        long limit = n;\n        \n        long [] basePrimes = SoE((long) Math.cbrt(limit));\n        \n        long segstart = 0;\n        long seglim = (long) Math.pow(n , 2/3d);\n        \n        long [][] sieve = new long [2][SEGMENT_SIZE];\n        long count = 0;\n        \n        long low = segstart;\n        while (low &lt;= seglim)\n        {\n            long high = Math.min(low + SEGMENT_SIZE - 1, seglim);\n            long segLen = (int) (high - low + 1);\n            \n            Arrays.fill(sieve[0] , 1L);\n            Arrays.fill(sieve[1] , 0);\n            \n            long localsqrt = (long) Math.sqrt(high);\n\n            for (long p : basePrimes) \n            {\n                if (p &gt; localsqrt) break;\n\n                // mark multiples of p\n                long start = Math.max(((low + p - 1) / p) * p, p * p);\n                for (long m = start; m &lt;= high; m += p) {\n                    int idx = (int) (m - low);\n                    sieve[0][idx] *= p;\n                    sieve[1][idx] += 1;\n                }\n\n                // mark multiples of p^2 as non-squarefree\n                long p2 = p * p;\n                long start2 = ((low + p2 - 1) / p2) * p2;\n                for (long m = start2; m &lt;= high; m += p2)\n                {\n                    int idx = (int) (m - low);\n                    sieve[0][idx] = 0;\n                }\n            }\n            \n            // scan segment for semiprimes\n            for (int i = 0; i &lt; segLen ; i++) \n            {\n                long k = low + i;\n                if (sieve[1][i] != 1 || sieve[0][i] &lt;= 1) continue; // squarefree and exactly one small prime\n                long p = sieve[0][i];\n                long q = k / p;\n                if (q &gt; Math.sqrt(limit / p)) continue;\n\n                count++;\n            }\n            \n            low = high + 1;\n        }\n        \n        return count;\n    }\n    \n    \n    public static long [] SoE (long n)\n    {\n        if (n &lt; 2) return new long[0];\n\n        boolean[] isPrime = new boolean[(int)n + 1];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n\n        for (int i = 2; i * i &lt;= n; i++) {\n            if (!isPrime[i]) continue;\n            for (int j = i * i; j &lt;= n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n\n        int count = 0;\n        for (int i = 2; i &lt;= n; i++) if (isPrime[i]) count++;\n\n        long[] primes = new long[count];\n        int idx = 0;\n        for (int i = 2; i &lt;= n; i++) {\n            if (isPrime[i]) primes[idx++] = i;\n        }\n        return primes;\n    }\n    \n    \n}\n</code></pre>\n<p><strong>Explanation of the code:</strong></p>\n<ol>\n<li>For this task we're running a segmented sieve with a 2D array containing 2 rows. We initialize the first row with <code>1</code>'s and the second row with <code>0</code>s.</li>\n<li>The first row will indicate a running product of primes in the relevant integer's prime factorization</li>\n<li>The second row will be an indicator of the count of said primes in the above bullet</li>\n<li>For ever prime <code>p &lt;= cbrt(n)</code>, we start by marking multiples of all <code>p</code> that are <code>&gt;= p^2</code>, updating the above rows of the sieve.</li>\n<li>We then mark multiples of <code>p^2</code>: if an integer is a multiple of <code>p^2</code>, it will be irrelevant to us, so we mark the first row with <code>0</code>.</li>\n<li>At the end of this process, we have the following cases:</li>\n</ol>\n<ul>\n<li>If the first row is filled with <code>0</code>, this is not a suitable <code>k</code></li>\n<li>If the first row is filled with <code>1</code>, it means it's an integer whose smallest prime factor is <code>&gt; cbrt(n)</code>. This indicates it's not a valid <code>k</code> either.</li>\n<li>If the second row has a count <code>&gt; 2</code>, then it already has at least 3 prime factors, uninteresting either.</li>\n<li>What we're left with is integers with the second row <code>&lt;= 2</code>. The case of it equal to <code>0</code> is already omitted in the second case. So we're looking at the second row <code>=1 or 2</code>. If it's exactly <code>2</code>, we can check the first row to see the product of these <code>2</code> primes. If the first row is <strong>NOT</strong> equal to the current integer indicated by this column, this indicates that these <code>2</code> primes are not a complete factorization, and therefore it's not a valid <code>k</code>, because there is at least <code>1</code> more prime factor, so it's not a semiprime. If on the other hand it is equal, then we've found a valid <code>k</code>. However, with some math gymnastics it's possible to show that if it's equal to <code>2</code> at this point, this can't be a valid <code>k</code>: it must have additional factors.</li>\n<li>We're left with integers that have exactly <code>1</code> prime factor <code>p &lt;= cbrt(n)</code>, just like we wanted, because we've omitted the case of <code>0</code> and <code>&gt;= 2</code>. Note that primes have not been marked as well, because we've started marking multiples of primes <code>p</code> starting from <code>p^2</code>. This means that any prime will have its second row with <code>0</code>. And that's the last filter we needed. We now only have integers that have been marked with exactly <code>1</code> prime factor <code>p&lt;=cbrt(n)</code>, and they're not prime. Additionally, remember we're only iterating over integers <code>&lt;=n^(2/3)</code>, so they can't possibly have <code>2</code> or more prime factors <code>&gt;= cbrt(n)</code>. This means the integer we're currently on has exactly one additional prime factor <code>q</code>. So if we're iterating over such integer <code>k</code>, we can know <code>p</code> from the first row that was the running product. So we can easily deduce that <code>q = k / p</code>.</li>\n</ul>\n<p>With all this logic, we've successfully iterated over all such valid triplets of <code>k,p,q</code>. Note that we haven't checked the primality of <code>q</code>, so we've extracted it in <code>O(1)</code>.</p>\n<p><strong>What I am after:</strong></p>\n<p>I am posting this here because I am interested in suggestions about how to improve this code. Ideally, I want to perform this iteration much faster. I can parallelize it but multithreading is what I want to do last - first I want to improve the actual logic or come up with better schemes and algorithms for iteration.</p>\n<p>I have tried consulting some LLM's but they weren't even able to come up with any algorithm at all that actually copes with these demands. And really no useful insights.</p>\n<p>The end result is a highly optimized code for this iterating process, including parallelization. I am interested in any suggestions and recommendations of course. But ideally, I'd really love to see code (c++ / Java are favorable): in the end, the code I want to produce needs to run and faster than what I have. So if you suggest anything, I'd greatly appreciate if you actually checked it before recommending it, to not throw me in the wrong direction.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}