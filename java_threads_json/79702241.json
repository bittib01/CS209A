{
  "question": {
    "tags": [
      "java",
      "mysql",
      "multithreading",
      "vert.x",
      "abstractverticle"
    ],
    "owner": {
      "account_id": 12889364,
      "reputation": 11,
      "user_id": 9321849,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/03854c80d7365b300427db77a3fa3368?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Blesson",
      "link": "https://stackoverflow.com/users/9321849/blesson"
    },
    "is_answered": false,
    "view_count": 76,
    "answer_count": 0,
    "score": 0,
    "last_activity_date": 1752590142,
    "creation_date": 1752590142,
    "question_id": 79702241,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79702241/vert-x-mysql-timeouts",
    "title": "Vert.x mysql timeouts",
    "body": "<p>I have these 2 verticles in my java application in vert.x that are supposed to be running in multiple batches.</p>\n<pre><code>public class TestVerticle4   extends AbstractVerticle{\n    private static final Logger logger = LoggerFactory.getLogger(TestVerticle4.class);\n    \n    @Override\n    public void start(Promise&lt;Void&gt; startPromise) {\n        try {\n            MySQLConnectOptions connectOptions = new MySQLConnectOptions()\n                    .setPort(Integer.parseInt(config().getString(&quot;sqlPort&quot;)))\n                    .setHost(config().getString(&quot;host&quot;))\n                    .setDatabase(config().getString(&quot;database&quot;))\n                    .setUser(config().getString(&quot;user&quot;))\n                    .setPassword(config().getString(&quot;password&quot;))\n                    .setConnectTimeout(30000) // timeout if more than 30 second query\n                    .setIdleTimeout(300)\n                    .setConnectTimeout(5000)\n                    .setReconnectInterval(2000)\n                    ;\n            \n            PoolOptions poolOptions = new PoolOptions().setMaxSize(60);\n            MySQLPool client = MySQLPool.pool(vertx,connectOptions,poolOptions);\n            \n            CircuitBreakerOptions cbOptions = new CircuitBreakerOptions()\n                    .setMaxRetries(3) // Retry 3 times\n                    .setResetTimeout(5000) // Reset timeout (ms) after success\n                    .setTimeout(1000) // Operation timeout (ms)\n                    .setFallbackOnFailure(true); // Enable fallback on failure\n            CircuitBreaker breaker = CircuitBreaker.create(&quot;TestVerticle7&quot;, vertx, cbOptions);\n\n\n            \n            \n            logger.info(&quot;Step3:------------ Recieving at Verticle4 &quot;);\n            logger.info(&quot;Recieving at task.runVerticle4....&quot;);\n            EventBus bus =vertx.eventBus();\n            bus.&lt;JsonObject&gt;consumer(&quot;task.runVerticle4&quot;,msg-&gt;{\n                JsonObject bodyCon = msg.body();\n                //String symbol = bodyCon.getString(&quot;symbol&quot;);\n                Long hashcode=bodyCon.getLong(&quot;hashcode&quot;);\n                Long minId= bodyCon.getLong(&quot;minId&quot;);\n                Long maxId= bodyCon.getLong(&quot;maxId&quot;);\n                Long prodId=bodyCon.getLong(&quot;prodId&quot;);\n                breaker.execute(promise -&gt; {\n                client.getConnection(\n                        ar-&gt;{\n                            if(ar.succeeded()) {\n                                SqlConnection conn =ar.result();\n                                conn.preparedQuery(insertQueryEvent())\n                                .execute(Tuple.of(hashcode,prodId,minId,maxId),res-&gt;{\n                                    if(res.succeeded()) {\n                                        logger.info(&quot;Successfully Inserted Batch for custIds {} to {} for product {} for hashcode {}&quot;,minId,maxId,prodId,hashcode);\n                                    }else {\n                                        logger.error(&quot;Failed to execute &quot;+res.cause().getMessage());\n                                    }\n                                    conn.close();\n                                });\n                                \n                            }else {\n                                logger.error(&quot;Failed to connect to db&quot;+ ar.cause().getMessage());\n                            }\n                        }\n                ); //\n                }).onComplete(ar -&gt; {\n                    if (ar.succeeded()) {\n                        // Handle the result after successful execution or fallback\n                        System.out.println(&quot;Query executed successfully (or fallback used)&quot;);\n                    } else {\n                        System.err.println(&quot;Query failed after retries: &quot; + ar.cause().getMessage());\n                    }\n                });\n                \n            });         \n            \n            startPromise.complete();\n        }catch(Exception e) {\n            e.printStackTrace();\n            startPromise.fail(e);\n        }\n    }\n    \n    public static String insertQueryEvent() {\n        return &quot;  INSERT IGNORE INTO ResearchCall_HashQueue(Customer_Id,Product_Id,HashCode)  SELECT Customer_Id,Reco_Product_1, ?  FROM  RankedPickList_Stories WHERE Reco_Product_1= ?  AND Customer_Id BETWEEN  ? AND ?  AND Story_Id=3;&quot;;\n    }\n}\n\n</code></pre>\n<p>and</p>\n<pre><code>public class TestVerticle7  extends AbstractVerticle{\nprivate static final Logger logger = LoggerFactory.getLogger(TestVerticle7.class);\n    \n    @Override\n    public void start(Promise&lt;Void&gt; startPromise) {\n        try {\n            MySQLConnectOptions connectOptions = new MySQLConnectOptions()\n                    .setPort(Integer.parseInt(config().getString(&quot;sqlPort&quot;)))\n                    .setHost(config().getString(&quot;host&quot;))\n                    .setDatabase(config().getString(&quot;database&quot;))\n                    .setUser(config().getString(&quot;user&quot;))\n                    .setPassword(config().getString(&quot;password&quot;))\n                    .setConnectTimeout(30000)\n                    .setIdleTimeout(300)\n                    .setConnectTimeout(5000)\n                    .setReconnectInterval(2000)\n                    ;\n            \n            \n            PoolOptions poolOptions = new PoolOptions().setMaxSize(60);\n            MySQLPool client = MySQLPool.pool(vertx,connectOptions,poolOptions);\n            \n            CircuitBreakerOptions cbOptions = new CircuitBreakerOptions()\n                    .setMaxRetries(3) // Retry 3 times\n                    .setResetTimeout(5000) // Reset timeout (ms) after success\n                    .setTimeout(1000) // Operation timeout (ms)\n                    .setFallbackOnFailure(true); // Enable fallback on failure\n            CircuitBreaker breaker = CircuitBreaker.create(&quot;TestVerticle7&quot;, vertx, cbOptions);\n\n            \n            \n            logger.info(&quot;Recieving to task.runVerticle7....&quot;);\n            EventBus bus =vertx.eventBus();\n            bus.&lt;JsonObject&gt;consumer(&quot;task.runVerticle7&quot;,msg-&gt;{\n                JsonObject msg_body = msg.body();\n                Long minId= msg_body.getLong(&quot;minId&quot;);\n                Long maxId= msg_body.getLong(&quot;maxId&quot;);\n                Long prodId= msg_body.getLong(&quot;prodId&quot;);\n                Long hashcode= msg_body.getLong(&quot;hashcode&quot;);\n                breaker.execute(promise -&gt; {\n                client.getConnection(\n                        ar-&gt;{\n                            if(ar.succeeded()) {\n                                SqlConnection conn =ar.result();\n                                \n                                conn.preparedQuery(updateProductArray())\n                                .execute(Tuple.of(minId,maxId,prodId,hashcode),res-&gt;{\n                                    if(res.succeeded()) {\n                                        logger.info(&quot;Successfull Updated product array to Customer_ResearchCall_Master for Cust_Ids between {} and {}&quot;,minId,maxId);\n                                    }else {\n                                        logger.error(&quot;Failed to  update product array to Customer_ResearchCall_Master for Cust_Ids between {} and {}&quot;,minId,maxId+res.cause().getMessage());\n                                    }\n                                    conn.close();\n                                });\n                                \n                                // Run ResearchCall_ProductResearchCallMapping\n                                \n                                conn.preparedQuery(updateProductJson())\n                                .execute(Tuple.of(minId,maxId),res-&gt;{\n                                    if(res.succeeded()) {\n                                        logger.info(&quot;Successfull Updated product_Json  to Customer_ResearchCall_Master&quot;);\n                                    }else {\n                                        logger.error(&quot;Failed to  update product_json to Customer_ResearchCall_Master&quot;+res.cause().getMessage());\n                                    }\n                                    conn.close();\n                                });\n                                \n                            }else {\n                                logger.error(&quot;Failed to connect to db&quot;+ ar.cause().getMessage());\n                            }\n                        }\n                        );  //\n                }).onComplete(ar -&gt; {\n                    if (ar.succeeded()) {\n                        // Handle the result after successful execution or fallback\n                        System.out.println(&quot;Query executed successfully (or fallback used)&quot;);\n                    } else {\n                        System.err.println(&quot;Query failed after retries: &quot; + ar.cause().getMessage());\n                    }\n                });\n            });\n            \n            startPromise.complete();\n        }catch(Exception e) {\n            startPromise.fail(e);\n        }\n    }\n    \n    \n    public static String updateProductArray() {\n        return &quot;CALL  ResearchCall_UpdateProductArray(?,?,?,?);&quot;;\n    }\n    \n    public static String updateProductJson() {\n        return &quot;CALL  ResearchCall_UpdateProductJson(?,?);&quot;;\n    }\n}\n\n</code></pre>\n<p>Both verticles have MySQL queries/procedures that are supposed to execute.</p>\n<p>I have put up a circuit breaker is supposed to do multiple tries of this SQL query even when it fails.</p>\n<p>The issue with this is that the logs I am getting following errors in the logs like below</p>\n<pre><code>2025-07-15 19:18:27 [vert.x-eventloop-thread-3] ERROR jarBot.TestVerticle4 - Failed to connect to dbTimeout\n2025-07-15 19:18:27 [vert.x-eventloop-thread-3] ERROR jarBot.TestVerticle4 - Failed to connect to dbTimeout\n2025-07-15 19:18:27 [vert.x-eventloop-thread-3] ERROR jarBot.TestVerticle4 - Failed to connect to dbTimeout\n2025-07-15 19:18:27 [vert.x-eventloop-thread-3] ERROR jarBot.TestVerticle4 - Failed to connect to dbTimeout\n2025-07-15 19:18:46 [vert.x-eventloop-thread-6] ERROR jarBot.TestVerticle7 - Failed to  update product array to Customer_ResearchCall_Master for Cust_Ids between 1 and 100000{errorMessage=Lock wait timeout exceeded; try restarting transaction, errorCode=1205, sqlState=HY000}\n2025-07-15 19:18:47 [vert.x-eventloop-thread-3] ERROR jarBot.TestVerticle4 - Failed to execute{errorMessage=Lock wait timeout exceeded; try restarting transaction, errorCode=1205, sqlState=HY000}\n2025-07-15 19:18:47 [vert.x-eventloop-thread-3] ERROR jarBot.TestVerticle4 - Failed to execute{errorMessage=Lock wait timeout exceeded; try restarting transaction, errorCode=1205, sqlState=HY000}\n2025-07-15 19:19:37 [vert.x-eventloop-thread-6] ERROR jarBot.TestVerticle7 - Failed to  update product_json to Customer_ResearchCall_Master{errorMessage=Lock wait timeout exceeded; try restarting transaction, errorCode=1205, sqlState=HY000}\n2025-07-15 19:19:48 [vert.x-eventloop-thread-6] ERROR jarBot.TestVerticle7 - Failed to  update product array to Customer_ResearchCall_Master for Cust_Ids between 400001 and 500000{errorMessage=Lock wait timeout exceeded; try restarting transaction, errorCode=1205, sqlState=HY000}\n2025-07-15 19:19:57 [vert.x-eventloop-thread-6] ERROR jarBot.TestVerticle7 - Failed to  update product_json to Customer_ResearchCall_Master{errorMessage=Lock wait timeout exceeded; try restarting transaction, errorCode=1205, sqlState=HY000}\n2025-07-15 19:19:57 [vert.x-eventloop-thread-6] ERROR jarBot.TestVerticle7 - Failed to  update product_json to Customer_ResearchCall_Master{errorMessage=Lock wait timeout exceeded; try restarting transaction, errorCode=1205, sqlState=HY000}\n</code></pre>\n<p>My MySQL DB Details look like following :</p>\n<p><strong>MAX_CONNECTIONS=1000</strong></p>\n<p><strong>innodb_buffer_pool_size=107374182400</strong></p>\n<p><strong>max_connections=1000</strong></p>\n<p><strong>max_allowed_packet=1073741824</strong></p>\n<p><strong>wait_timeout=28800</strong></p>\n<p><strong>interactive_timeout=28800</strong></p>\n<p><strong>net_read_timeout=30</strong></p>\n<p><strong>net_write_timeout=60</strong></p>\n<p>MySQL tables are indexed and have keys and partitioned for 100k which is also the batch size of insertion and updates , but this should not be a problem since I am trying multiple retries</p>\n<p>What am I doing wrong to cause so many timeouts despite retries.</p>\n<p>Any help is appreciated</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}