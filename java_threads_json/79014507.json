{
  "question": {
    "tags": [
      "java",
      "spring",
      "spring-boot",
      "jwt",
      "backend"
    ],
    "owner": {
      "account_id": 35823126,
      "reputation": 1,
      "user_id": 27420093,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/f1e01f3b869b117201f28f46e4893b8a?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Арсений Горягин",
      "link": "https://stackoverflow.com/users/27420093/%d0%90%d1%80%d1%81%d0%b5%d0%bd%d0%b8%d0%b9-%d0%93%d0%be%d1%80%d1%8f%d0%b3%d0%b8%d0%bd"
    },
    "is_answered": false,
    "view_count": 55,
    "answer_count": 0,
    "score": 0,
    "last_activity_date": 1727092876,
    "creation_date": 1727092876,
    "question_id": 79014507,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79014507/spring-security-always-throws-insufficientauthenticationexception-even-when-the",
    "title": "Spring Security Always Throws InsufficientAuthenticationException even when the SecuirtyContext is authetnicated",
    "body": "<p>so i have been trying to make a jwt filter that &quot;authenticates&quot; the request.</p>\n<p>JWTFilter.java:</p>\n<pre><code>`@RequiredArgsConstructor\n@Slf4j\npublic class JWTFilter extends OncePerRequestFilter {\n\nprivate final JWTService jwtService;\nprivate final UserDetailsService userService;\n\nprivate Optional&lt;String&gt; getTokenFromHeader(HttpServletRequest request){\n    final String authHeader = request.getHeader(&quot;Authorization&quot;);\n    if(authHeader == null || !authHeader.startsWith(&quot;Bearer &quot;)){\n        return Optional.empty();\n    }\n    return Optional.of(authHeader.substring(7));\n}\n\n@Override\nprotected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,\n   FilterChain filterChain) throws ServletException, IOException {\n    log.error(&quot;Running filter...&quot;);\n\n    Optional&lt;String&gt; rawToken = getTokenFromHeader(request);\n\n    if(rawToken.isEmpty()){\n        filterChain.doFilter(request, response);\n        return;\n    }\n\n    // TODO handle all the exception\n    try {\n        String token = rawToken.get();\n\n        // Validate\n        jwtService.validateToken(token);\n\n        /*\n        if(SecurityContextHolder.getContext().getAuthentication() != null){\n            filterChain.doFilter(request, response);\n            return;\n        }*/\n\n        String username = jwtService.getUserId(token);\n        log.info(&quot;\\n\\nUsername &quot; + username);\n\n        UserDetails userDetails = userService.loadUserByUsername(username);\n\n        log.info(&quot;\\n\\nuserdetails &quot; + userDetails.toString());\n\n        if(userDetails.getUsername() == null){\n            filterChain.doFilter(request, response);\n            return;\n        }\n\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());\n        authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n        SecurityContextHolder.getContext().setAuthentication(authenticationToken);\n\n        log.error(&quot;Doing last full auth is good &quot; + SecurityContextHolder.getContext().getAuthentication().isAuthenticated());\n        filterChain.doFilter(request, response);\n\n        log.error(&quot;AFTER DO FILTER CHECK  &quot; + SecurityContextHolder.getContext().getAuthentication().isAuthenticated());\n\n    } catch (JwtException e) {\n        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n        response.getWriter().write(&quot;Invalid token &quot; + e.getLocalizedMessage());\n    }\n}\n\n}\n</code></pre>\n<p>`</p>\n<p>and even tho by the logs is seems that the security context authentication is set to true, it still does not send the request to the controller!!</p>\n<p>this is my security chain and the whole security configuration:</p>\n<pre><code>\\`@Configuration\n @EnableWebSecurity\n@RequiredArgsConstructor\npublic class SecurityConfig {\n\nprivate final AuthorizationEntryPoint unauthorizedHandler;\nprivate final JWTService jwtService;\nprivate final UserRepository userRepository;\nprivate final UserDetailsService userService;\n\n@Bean\npublic SecurityFilterChain provideSecurityFilterChain(HttpSecurity http) throws Exception {\n\n    http.csrf(AbstractHttpConfigurer::disable);\n    http.cors(AbstractHttpConfigurer::disable);\n\n    http.authorizeHttpRequests((requests) -&gt;\n        requests\n            .requestMatchers(&quot;/auth/**&quot;).permitAll()\n            .requestMatchers(&quot;/swagger-ui/**&quot;).permitAll()\n            .requestMatchers(&quot;/v3/**&quot;).permitAll()\n            .anyRequest().authenticated()\n    )\n    .authenticationManager(provideAuthManager(http));\n\n    http.sessionManagement(sessionManagementConfigurer -&gt;\n        sessionManagementConfigurer.sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n    );\n\n    http.authenticationProvider(provideAuthenticationProvider());\n    http.addFilterBefore(new JWTFilter(jwtService, userService), UsernamePasswordAuthenticationFilter.class);\n    http.exceptionHandling(exception -&gt; exception.authenticationEntryPoint(unauthorizedHandler));\n\n    return http.build();\n}\n\n@Bean\npublic PasswordEncoder provideEncoder(){\n    return new BCryptPasswordEncoder();\n}\n\n@Bean\npublic AuthenticationProvider provideAuthenticationProvider(){\n    DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();\n    authProvider.setUserDetailsService(userService);\n    authProvider.setPasswordEncoder(provideEncoder());\n    return authProvider;\n}\n\n@Bean\npublic AuthenticationManager provideAuthManager(HttpSecurity httpSecurity) throws Exception {\n    AuthenticationManagerBuilder authenticationManagerBuilder = httpSecurity.getSharedObject(AuthenticationManagerBuilder.class);\n    authenticationManagerBuilder.userDetailsService(userService).passwordEncoder(provideEncoder());\n    return authenticationManagerBuilder.build();\n}\n\n}\n</code></pre>\n<p>`</p>\n<p>this is the controller and the endpoint is the &quot;post&quot; endpoint that i am trying to reach:</p>\n<pre><code>\\`@RestController()\n@RequestMapping(&quot;/blog_posts&quot;)\n@Slf4j\npublic class PostController {\n\nprivate final PostsService postsService;\n\npublic PostController(PostsService postsService){\n    this.postsService = postsService;\n}\n\n@GetMapping(&quot;/info&quot;)\npublic String getPosts(){\n    return &quot;Blog posts&quot;;\n}\n\n@GetMapping(&quot;/&quot;)\npublic List&lt;BlogPost&gt; getBlogPosts(@RequestParam() Long limit, @RequestParam Long offset){\n    return postsService.getBlogPosts(limit, offset);\n}\n\n@PostMapping(&quot;/&quot;)\npublic BlogPost addBlogPost(@RequestParam AddBlogPostRequest request){\n    log.error(&quot;Doing controller&quot;);\n\n    Authentication authentication  = SecurityContextHolder.getContext().getAuthentication();\n    User user = (User) authentication.getDetails();\n\n    BlogPost post = new BlogPost();\n    post.setTitle(request.getTitle());\n    post.setBody(request.getBody());\n    post.setUserId(user.getId());\n\n    return postsService.addBlogPost(post);\n}\n\n}\n</code></pre>\n<p>`</p>\n<p>this is the bean and configuration for the userdetails service:</p>\n<pre><code>\\`@Configuration\n@RequiredArgsConstructor\npublic class AppConfig {\n\nprivate final UserRepository userRepository;\n\n@Bean\npublic UserDetailsService provideUserDetailsService() throws Exception {\n    return new UserDetailsService() {\n        @Override\n        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n            return userRepository.findByUsername(username)\n                .orElseThrow(() -&gt; new UsernameNotFoundException(&quot;User not found&quot;));\n        }\n    };\n}\n\n}\n</code></pre>\n<p>`</p>\n<p>please help me have been struggling with this for a three days,I have read all the forums tortured chatgpt and cannot find a solution. I have also asked my friends looked at multiple video tutorials i just dont know what to do.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}