{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "amazon-cognito"
    ],
    "owner": {
      "account_id": 14435571,
      "reputation": 646,
      "user_id": 10427626,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/eb6cbe32ce858ef93116bbb0199f695f?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "MOSI",
      "link": "https://stackoverflow.com/users/10427626/mosi"
    },
    "is_answered": false,
    "view_count": 67,
    "answer_count": 0,
    "score": 0,
    "last_activity_date": 1740393980,
    "creation_date": 1740270519,
    "last_edit_date": 1740393980,
    "question_id": 79460505,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79460505/secrethash-does-not-match-for-the-client-xyz-aws-cognito-allow-user-srp-auth",
    "title": "SecretHash does not match for the client: xyz - AWS Cognito ALLOW_USER_SRP_AUTH (AWS Cognito - JAVA Spring Boot)",
    "body": "<p>I'm trying to implement ALLOW_USER_SRP_AUTH (authentication flow) but I'm getting the following error.</p>\n<blockquote>\n<p>SecretHash does not match for the client: xyz</p>\n</blockquote>\n<p>this is the class with the static function that I'm using to generate the SECRET_HASH value.</p>\n<pre class=\"lang-java prettyprint-override\"><code>\npublic class SecretHashGenerator {\n\n    public static String calculateSecretHash(String clientId, String clientSecret, String userName) {\n        final String HMAC_SHA256_ALGORITHM = &quot;HmacSHA256&quot;;\n\n        SecretKeySpec signingKey = new SecretKeySpec(\n                clientSecret.getBytes(StandardCharsets.UTF_8),\n                HMAC_SHA256_ALGORITHM);\n        try {\n            Mac mac = Mac.getInstance(HMAC_SHA256_ALGORITHM);\n            mac.init(signingKey);\n            mac.update(userName.getBytes(StandardCharsets.UTF_8));\n            byte[] rawHmac = mac.doFinal(clientId.getBytes(StandardCharsets.UTF_8));\n            return Base64.getEncoder().encodeToString(rawHmac);\n        } catch (Exception e) {\n            throw new RuntimeException(&quot;Error while calculating &quot;);\n        }\n    }\n\n}\n</code></pre>\n<p>I have already implemented ALLOW_USER_PASSWORD_AUTH (Authentication flow) with the same SecretHashGenerator class with no issues but I'm getting this error SecretHash does not match for the client: xyz when I use it with ALLOW_USER_SRP_AUTH (Authentication flow).</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class SRPAuthenticator {\n    private static final BigInteger N = new BigInteger(\n            &quot;FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1&quot; +\n                    &quot;29024E088A67CC74020BBEA63B139B22514A08798E3404DD&quot; +\n                    &quot;EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245&quot; +\n                    &quot;E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED&quot; +\n                    &quot;EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381&quot; +\n                    &quot;FFFFFFFFFFFFFFFF&quot;, 16);\n    private static final BigInteger g = BigInteger.valueOf(2);\n    private static final int EPHEMERAL_KEY_LENGTH = 1024;\n\n    private final SRP6Client srpClient;\n    private final SecureRandom random;\n    private final String userPoolName;\n    private final String secretHash;\n\n    public SRPAuthenticator(String userPoolName, String secretHash) {\n        this.srpClient = new SRP6Client();\n        this.random = new SecureRandom();\n        this.userPoolName = userPoolName;\n        this.secretHash = secretHash;\n    }\n\n    private String generateTimestamp() {\n        SimpleDateFormat sdf = new SimpleDateFormat(&quot;EEE MMM d HH:mm:ss z yyyy&quot;, Locale.US);\n        sdf.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));\n        return sdf.format(new Date());\n    }\n\n    private BigInteger generatePrivateValue() {\n        int bytes = EPHEMERAL_KEY_LENGTH / 8;\n        byte[] arr = new byte[bytes];\n        random.nextBytes(arr);\n        return new BigInteger(1, arr);\n    }\n\n    public AuthenticationResultType authenticate(\n            CognitoIdentityProviderClient cognitoClient,\n            String clientId,\n            String username,\n            String password) throws Exception {\n\n        // Initialize SRP6 client\n        srpClient.init(N, g, new SHA256Digest(), random);\n\n        // Generate private value 'a' and public value 'A'\n        BigInteger a = generatePrivateValue();\n        BigInteger A = g.modPow(a, N);\n\n        // Prepare authentication parameters\n        Map&lt;String, String&gt; authParams = new HashMap&lt;&gt;();\n        authParams.put(&quot;USERNAME&quot;, username);\n        authParams.put(&quot;SRP_A&quot;, A.toString(16));\n        authParams.put(&quot;SECRET_HASH&quot;, secretHash);\n        authParams.put(&quot;EMAIL&quot;, username);\n\n        // Initiate authentication request\n        InitiateAuthRequest initiateRequest = InitiateAuthRequest.builder()\n                .authFlow(AuthFlowType.USER_SRP_AUTH)\n                .clientId(clientId)\n                .authParameters(authParams)\n                .build();\n\n        InitiateAuthResponse initiateAuthResponse = cognitoClient.initiateAuth(initiateRequest);\n\n        // Extract challenge parameters\n        Map&lt;String, String&gt; challengeParams = initiateAuthResponse.challengeParameters();\n        String userIdForSrp = challengeParams.get(&quot;USER_ID_FOR_SRP&quot;);\n        String saltHex = challengeParams.get(&quot;SALT&quot;);\n        String srpBHex = challengeParams.get(&quot;SRP_B&quot;);\n        String secretBlock = challengeParams.get(&quot;SECRET_BLOCK&quot;);\n        String timestamp = challengeParams.getOrDefault(&quot;TIMESTAMP&quot;, generateTimestamp());\n\n        // Convert challenge parameters\n        byte[] serverSalt = new BigInteger(saltHex, 16).toByteArray();\n        BigInteger B = new BigInteger(srpBHex, 16);\n\n        try {\n            // Set the client's credentials\n            srpClient.generateClientCredentials(\n                    serverSalt,\n                    userIdForSrp.getBytes(StandardCharsets.UTF_8),\n                    password.getBytes(StandardCharsets.UTF_8)\n            );\n\n            // Calculate client evidence message\n            BigInteger S = srpClient.calculateSecret(B);\n            BigInteger M1 = srpClient.calculateClientEvidenceMessage();\n\n            // Calculate session key\n            SHA256Digest digest = new SHA256Digest();\n            byte[] sessionKey = new byte[digest.getDigestSize()];\n            digest.update(S.toByteArray(), 0, S.toByteArray().length);\n            digest.doFinal(sessionKey, 0);\n\n            // Generate signature\n            byte[] signature = calculateSignature(\n                    sessionKey,\n                    timestamp,\n                    userIdForSrp,\n                    secretBlock);\n\n\n            // Create challenge response parameters\n            Map&lt;String, String&gt; challengeResponses = new HashMap&lt;&gt;();\n            challengeResponses.put(&quot;USERNAME&quot;, userIdForSrp);\n            challengeResponses.put(&quot;PASSWORD_CLAIM_SECRET_BLOCK&quot;, secretBlock);\n            challengeResponses.put(&quot;TIMESTAMP&quot;, timestamp);\n            challengeResponses.put(&quot;EMAIL&quot;, username);\n            challengeResponses.put(&quot;PASSWORD_CLAIM_SIGNATURE&quot;,\n                    Base64.getEncoder().encodeToString(signature));\n            challengeResponses.put(&quot;SECRET_HASH&quot;, secretHash);\n            challengeResponses.put(&quot;PROOF&quot;, M1.toString(16));\n\n            // Respond to authentication challenge\n            RespondToAuthChallengeRequest challengeRequest = RespondToAuthChallengeRequest.builder()\n                    .challengeName(ChallengeNameType.PASSWORD_VERIFIER)\n                    .clientId(clientId)\n                    .challengeResponses(challengeResponses)\n                    .build();\n\n            RespondToAuthChallengeResponse challengeResponse =\n                    cognitoClient.respondToAuthChallenge(challengeRequest);\n\n            return challengeResponse.authenticationResult();\n        } catch (CryptoException e) {\n            throw new RuntimeException(&quot;Failed to calculate SRP authentication values&quot;, e);\n        }\n    }\n\n    private byte[] calculateSignature(\n            byte[] key,\n            String timestamp,\n            String username,\n            String secretBlock) throws Exception {\n\n        Mac mac = Mac.getInstance(&quot;HmacSHA256&quot;);\n        SecretKeySpec keySpec = new SecretKeySpec(key, &quot;HmacSHA256&quot;);\n        mac.init(keySpec);\n\n        mac.update(userPoolName.getBytes(StandardCharsets.UTF_8));\n        mac.update(username.getBytes(StandardCharsets.UTF_8));\n        mac.update(Base64.getDecoder().decode(secretBlock));\n        mac.update(timestamp.getBytes(StandardCharsets.UTF_8));\n\n        return mac.doFinal();\n    }\n}\n</code></pre>\n<pre class=\"lang-xml prettyprint-override\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;software.amazon.awssdk&lt;/groupId&gt;\n    &lt;artifactId&gt;cognitoidentityprovider&lt;/artifactId&gt;\n    &lt;version&gt;2.30.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;\n    &lt;artifactId&gt;bcprov-jdk18on&lt;/artifactId&gt;\n    &lt;version&gt;1.80&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>I appreciate your help. Thank you</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}