{
  "question": {
    "tags": [
      "java",
      "data-structures",
      "heap",
      "verify",
      "heapsort"
    ],
    "owner": {
      "account_id": 36075978,
      "reputation": 21,
      "user_id": 27551774,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/9ce21f579696e7a22fce675df29e6771?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Djd Bdbd",
      "link": "https://stackoverflow.com/users/27551774/djd-bdbd"
    },
    "is_answered": true,
    "view_count": 130,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1735333529,
    "creation_date": 1727704797,
    "last_edit_date": 1727705097,
    "question_id": 79039701,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79039701/heapsort-implementation-using-a-min-heap-ternary-heap-feedback-on-correctnes",
    "title": "Heapsort Implementation Using a Min-Heap (Ternary Heap) — Feedback on Correctness and Optimization",
    "body": "<p>I’m working on implementing a heapsort algorithm using a min-heap, specifically a ternary heap, where each node can have up to three children. I know that my solution is inefficient, and I'm looking for feedback on whether my implementation is correct, as well as suggestions for optimizing it.\nProblem Statement:</p>\n<blockquote>\n<p>In our course, we discussed a binary heap. Analogously, a ternary heap\ncan be implemented, where each node has up to three children. The\nchildren of the node at position i are located at the positions 3<em>i +\n1, 3</em>i + 2, and 3*i + 3 in the array. The task is to implement\nheapsort using such a ternary heap, ensuring that the algorithm works\nin-place.</p>\n<p>Implement heapsort using a ternary heap. Your algorithm should work\nin-place. You should extend the HeapTernary class from Moodle. The\nmain method should not be altered, but helper methods can be added.</p>\n<p>What is the worst-case runtime in O-notation for your algorithm?\nJustify your answer.</p>\n</blockquote>\n<p>My Solution:</p>\n<p>Here’s my code implementation:</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Random;\n\nclass HeapTernary {\n\n    public static void main(String[] args) {\n        Random random = new Random(42);\n        int[] a = new int[17];\n        for (int i = 0; i &lt; a.length; ++i) {\n            a[i] = random.nextInt(100);\n        }\n        System.out.println(Arrays.toString(a));\n\n        heapsort(a);\n\n        System.out.println(Arrays.toString(a));\n    }\n\n    public static void heapsort(int[] a) {\n\n        for (int i = 0; i &lt; a.length; i++) {\n            for (int j = i * 3 + 1; j &lt; i * 3 + 4; j++) {\n                if (j &lt; a.length) {\n                    if (a[j] &lt; a[i]) {\n                        switchPos(a, i, j);\n                        heapsort(a);\n                    }\n                }\n            }\n        }\n    }\n\n    private static void switchPos(int[] a, int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n}\n</code></pre>\n<p>I iterated through the entire array, comparing each node with its children. If a child node was smaller than its parent, I performed a swap to switch their positions. After the swap, I used recursion to verify whether the new parent node was smaller than its updated parent. This recursive check ensures that the min-heap property is maintained throughout the heap structure.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}