{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "spring-webflux",
      "project-reactor",
      "reactor-netty"
    ],
    "owner": {
      "account_id": 17703336,
      "reputation": 159,
      "user_id": 12852531,
      "user_type": "registered",
      "profile_image": "https://i.sstatic.net/v8RANiFo.webp?s=256",
      "display_name": "benjaminv2",
      "link": "https://stackoverflow.com/users/12852531/benjaminv2"
    },
    "is_answered": true,
    "view_count": 11382,
    "accepted_answer_id": 78389329,
    "answer_count": 2,
    "score": 4,
    "last_activity_date": 1725604847,
    "creation_date": 1713542645,
    "question_id": 78354966,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78354966/reactor-netty-connection-prematurely-closed-before-response-with-webclient",
    "title": "Reactor Netty: Connection prematurely closed BEFORE response with WebClient",
    "body": "<p>When trying to process data retrieved from the WebClient at a random point in time I get the &quot;Connection prematurely closed BEFORE response&quot; error. The pages contain quite a lot of data that is processed afterwards (mostly DB updates and inserts). After a random amount of time, I get the error:</p>\n<p>**Reactor Netty: Connection prematurely closed BEFORE response with WebClient.**</p>\n<p>The method in question is the following:</p>\n<pre><code>  private Mono&lt;String&gt; migrateSomeData() {\n    return getAllPages()\n        .flatMapIterable(Page::getItems)\n        .filter(this::isValidItem)\n        .doOnNext(item -&gt; doSomeLogging())\n        .filter(item-&gt; this.checkIfAlreadyProcessed(item))\n        .flatMap(this::mapToDto)\n        .flatMap(this::persist)\n        .doOnNext(this::saveAsProcessed)\n        .collectList()\n        .map(this::getTotalAmountOfProcessed);\n  }\n</code></pre>\n<p>The code has had certain parts omitted for brewity. getAllPages utilizes the Flux .expand method to recursively call the next pages. This is verified and works correctly. One more important thing to note is that all database operations are blocking as we have not implemented reactive jdbc.</p>\n<p>I've tried updating the webclient configuration:</p>\n<pre><code>@Bean\n  public WebClient someClient(\n      ReactiveOAuth2AuthorizedClientManager clientAuthorizedClientManager) {\n\n    ServerOAuth2AuthorizedClientExchangeFilterFunction oauth =\n        new ServerOAuth2AuthorizedClientExchangeFilterFunction(clientAuthorizedClientManager);\n    oauth.setDefaultClientRegistrationId(&quot;clientId&quot;);\n\n    final int size = 16 * 1024 * 1024;\n    final ExchangeStrategies strategies = buildClientWithExtendedResponseSize(size);\n\n    return WebClient.builder()\n        .defaultHeader(&quot;Accept&quot;, MediaType.APPLICATION_JSON_VALUE)\n        .defaultHeader(&quot;subscription-key&quot;, someKeyValue)\n        .clientConnector(createWiretappedClientHttpConnector(this.getClass()))\n        .filter(oauth)\n        .exchangeStrategies(strategies)\n        .build();\n  }\n\n  private static ExchangeStrategies buildClientWithExtendedResponseSize(int size) {\n    return ExchangeStrategies.builder()\n        .codecs(codecs -&gt; codecs.defaultCodecs().maxInMemorySize(size))\n        .build();\n  }\n\nprivate ClientHttpConnector createWiretappedClientHttpConnector(Class&lt;?&gt; invokedClass) {\n    HttpClient httpClient =\n        HttpClient.create()\n            .option(ChannelOption.SO_KEEPALIVE, true)\n            .responseTimeout(Duration.ofMinutes(5))\n            .doOnConnected(\n                conn -&gt;\n                    conn.addHandlerLast(new ReadTimeoutHandler(5 * 60))\n                        .addHandlerLast(new WriteTimeoutHandler(5 * 60)))\n            .compress(true)\n            .wiretap(\n                invokedClass.getCanonicalName(), LogLevel.TRACE, AdvancedByteBufFormat.TEXTUAL);\n    return new ReactorClientHttpConnector(httpClient);\n  }\n</code></pre>\n<p>I've also tried to narrow this code down as much as possible so forgive me for any structural mistakes.</p>\n<p>I've tested this against a local mocked instance of the API in wiremock and the issue still persists so that should rule out server configuration issues.</p>\n<p>Can it be possible that my processing code is too slow and that the WebClients returned response is not consumed in time and the webclient decides to close the connection?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}