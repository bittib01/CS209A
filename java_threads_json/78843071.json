{
  "question": {
    "tags": [
      "java",
      "spring",
      "spring-boot",
      "properties"
    ],
    "owner": {
      "account_id": 7484981,
      "reputation": 459,
      "user_id": 5688552,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/58a36b95f515521d64787026756bb814?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Loginus",
      "link": "https://stackoverflow.com/users/5688552/loginus"
    },
    "is_answered": false,
    "view_count": 150,
    "answer_count": 1,
    "score": -1,
    "last_activity_date": 1724750824,
    "creation_date": 1723025145,
    "last_edit_date": 1724750824,
    "question_id": 78843071,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78843071/spring-configuration-properties-with-types-and-fallback",
    "title": "Spring configuration properties with types and fallback",
    "body": "<h1>Problem</h1>\n<p>I have following spring properties</p>\n<pre class=\"lang-yaml prettyprint-override\"><code>myservice:\n domains:\n  domain1:\n    supplier:\n      baseUrl:\n      getEndpoint:\n    customer:\n      postEndpoint:\n  domain2:\n    supplier:\n      baseUrl:\n      getEndpoint:\n      retryCount:\n    customer:\n      baseUrl:\n      postEndpoint:\n  fallbackDomain:\n    supplier:\n      baseUrl:\n      getEndpoint:\n      retryCount:\n    customer:\n      baseUrl:\n      postEndpoint:\n</code></pre>\n<p>The idea is that there is constant configuration for multiple domains, can be &quot;domain1&quot;, &quot;domain2&quot;, &quot;domain3&quot; etc. And in addition there is fallback domain.\nIf property cannot be found on specific domain, then uses fallback value.\nExample:</p>\n<ul>\n<li>get customer post endpoint for domain1 -&gt; &quot;myservice.domains.domain1.customer.postEndpoint&quot;</li>\n<li>get supplier retry count for domain1 -&gt; &quot;myservice.domains.fallbackDomain.supplier.retryCount&quot; as it does not exist for domain1.</li>\n</ul>\n<h1>Important</h1>\n<p>The domain comes form the HTTP request/thread context, may change for each request and basically cannot be set on application startup.</p>\n<p>I am using spring boot 2.3.3 and spring 5.2.8, but considering upgrade if needed.</p>\n<h1>Solution 1</h1>\n<p>One of options is to get properties from org.springframework.core.env.Environment, like</p>\n<pre class=\"lang-java prettyprint-override\"><code>public &lt;T&gt; T getPropertyWithFallback(String nameTemplate, String domain, Class&lt;T&gt; clazz){\n  return Optional.ofNullable(environment.getProperty(nameTemaplte.format(domain), clazz))\n  .orElse(environment.getProperty(nameTemplate.format(&quot;fallbackDomain&quot;), clazz));\n}\nint count = getPropertyValueWithFallback(&quot;myservice.domains.%s.supplier.retryCount&quot;, &quot;domain1&quot;, Integer.class);\n</code></pre>\n<p>But then:</p>\n<ul>\n<li>I need to deal with string names and it's easy to make a typo in property name</li>\n<li>I need to remember the convention with template using &quot;%s&quot;, not a big deal, but still could be better</li>\n<li>I need to remember type for each property</li>\n<li>It's hard to remove property as it requires to find all the references in the code, which may not be straightforward.</li>\n</ul>\n<h1>Solution 2</h1>\n<p>I can use spring Configuration properties feature like:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Component\n@ConfigurationProperties(prefix = &quot;myservice&quot;)\npublic class MyServiceConfigurationProperties {\n  // skipping gettters and setters for readability\n  private Map&lt;String, Domain&gt; domains;\n\n  public static class Domain {\n    private Supplier supplier;\n    private Customer customer;\n  }\n  public static class Supplier {\n    private String baseUrl;\n    private String getEndpoint;\n    private Integer retryCount;\n  }\n  public static class Customer {\n    private String baseUrl;\n    private String postEndpoint;\n  }\n}\n</code></pre>\n<p>This works fine, I do not need to remember property names once they are configured, types are already assigned. It's easy to browse/list all properties for the domain.</p>\n<ul>\n<li>There is slightly less flexibility in defining properties - it assumes common structure for each domain - but that helps avoiding mess.</li>\n<li>There a bit more work when adding/removing properties, but for the cost of easier maintenance.</li>\n<li>There is one problem - implementing fallback becomes complex for nested objects.</li>\n</ul>\n<p>I tried to implement it using proxies</p>\n<pre class=\"lang-java prettyprint-override\"><code>    private static class FallbackInvocationHandler implements InvocationHandler {\n        private final Object primary;\n        private final Object fallback;\n\n        public FallbackInvocationHandler(Object primary, Object fallback) {\n            this.primary = primary;\n            this.fallback = fallback;\n        }\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            Object result = method.invoke(primary, args);\n            if (result == null) {\n                result = method.invoke(fallback, args);\n            }\n            if (result != null &amp;&amp; result.getClass().getPackage().getName().startsWith(&quot;no.eg.apps.pda6k.server.config&quot;)) {\n                return Proxy.newProxyInstance(\n                        result.getClass().getClassLoader(),\n                        new Class[]{result.getClass()},\n                        new FallbackInvocationHandler(result, method.invoke(fallback, args))\n                );\n            }\n            return result;\n        }\n    }\n\n  private &lt;T&gt; T getWithFallback(T value, T fallbackValue){\n    if (value==null){\n      return fallbackValue;\n    }\n    return (T) Proxy.newProxyInstance(\n            value.getClass().getClassLoader(),\n            new Class[]{value.getClass()},\n            new FallbackInvocationHandler(value, fallbackValue)\n  }\n// and then each getter implement in such way\n  public Domain getDomainWithFallback(String domain){\n     Domain value = domains.get(domain);\n     Domain fallbackValue = domains.get(&quot;fallbackDomain&quot;);\n     return getWithFallback(value, fallbackValue);\n  }\n</code></pre>\n<p>It becomes more complex/error prone for nested properties. &quot;Optimistic&quot; implementation may look like:</p>\n<pre class=\"lang-java prettyprint-override\"><code>// witin Supplier class\npublic Integer getRetryCountWithFallback(){\n    return getWithFallback(this.retryCount, domains.get(&quot;fallbackValue&quot;).getSupplier().getRetryCount());\n}\n</code></pre>\n<p>But what if <strong>fallbackDomain</strong> has no/empty <strong>supplier</strong> property - some extra null checks are needed and that complicates code for all simple thing.\nAlso adding new property becomes more complex.\nIs it even possible to reuse config structure if there are repeating properties e.g. customer and supplier have the same structure and I want to use same java object for them?</p>\n<h2>Question</h2>\n<p>Do you see any better solution than those presented above that allows me to solve the problem? I prefer not to change structure of properties, but it's an option if needed.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}