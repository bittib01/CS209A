{
  "question": {
    "tags": [
      "java",
      "algorithm"
    ],
    "owner": {
      "account_id": 187570,
      "reputation": 5316,
      "user_id": 425722,
      "user_type": "registered",
      "accept_rate": 83,
      "profile_image": "https://i.sstatic.net/346yd.jpg?s=256",
      "display_name": "Andrew Rueckert",
      "link": "https://stackoverflow.com/users/425722/andrew-rueckert"
    },
    "is_answered": true,
    "view_count": 150,
    "closed_date": 1757212755,
    "accepted_answer_id": 79756148,
    "answer_count": 2,
    "score": -2,
    "last_activity_date": 1757187872,
    "creation_date": 1757012818,
    "question_id": 79756132,
    "link": "https://stackoverflow.com/questions/79756132/performance-of-frequently-reordering-a-short-list",
    "closed_reason": "Opinion-based",
    "title": "Performance of frequently reordering a short list",
    "body": "<p>I have an application where I have a <code>Rule</code> object that has a list of <code>Filter</code> predicates. I will be comparing many <code>Events</code> to the predicates, and want to know if they <em>all</em> match. Most Events will not match against the Rule, so I want to fail as fast as possible.</p>\n<p>I figure, if I reorder the list so that the most-recently failing Filter is first, the Filters that are low-value will naturally sink down to the bottom of the list. Each Filter will hold a task roughly equivalent to a case-insensitive string comparison, so I <em>think</em> reordering the list will be more performant than doing an unnecessary test.</p>\n<p>I know from studying Big-O complexity that a Linked List is the correct solution here for <em>algorithmic complexity.</em> However, given the fact that I expect this list to be somewhere in the range of 5-50 elements long, I have a suspicion that storing the Filters in an ArrayList will <em>actually</em> be the most performant, as that forces the list to be stored in one  block of physical memory, instead of spread across the heap.</p>\n<p>Is there some other data structure that would be even more performant for this task?</p>\n<pre><code>public class Rule {\n  private List&lt;Predicate&lt;Event&gt;&gt; filters;\n\n  public boolean doesEventMatch(final Event event) {\n    for (int i = 0; i &lt; filters.size(); i++) {\n      if (!filter.test(event)) {\n        // remove the active filter and insert it at the front of the list\n        if (i != 0) {\n          final Predicate&lt;Event&gt; activeFilter = filters.remove(i);\n          filters.add(0, activeFilter);\n        }\n\n        return false;\n      }\n    }\n    return true;\n  }\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}