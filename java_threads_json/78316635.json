{
  "question": {
    "tags": [
      "java",
      "keycloak",
      "openid-connect",
      "spring-oauth2"
    ],
    "owner": {
      "account_id": 1509736,
      "reputation": 712,
      "user_id": 1412161,
      "user_type": "registered",
      "accept_rate": 86,
      "profile_image": "https://www.gravatar.com/avatar/7c1f4a477237b0347c332481e157744e?s=256&d=identicon&r=PG",
      "display_name": "grange",
      "link": "https://stackoverflow.com/users/1412161/grange"
    },
    "is_answered": true,
    "view_count": 3267,
    "accepted_answer_id": 78418065,
    "answer_count": 1,
    "score": 2,
    "last_activity_date": 1714651320,
    "creation_date": 1712929052,
    "last_edit_date": 1713005902,
    "question_id": 78316635,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78316635/refresh-token-not-used-by-spring-oauth2-when-access-token-expires",
    "title": "Refresh token not used by Spring OAuth2 when access token expires",
    "body": "<p>Hello fellow developers!\nI'm struggling for a couple of days now to find out why Spring OAuth2 is not using the refresh token returned for the authorization_code grant when the access token expires.</p>\n<p><strong>Setup</strong></p>\n<p>Basically, I was following <a href=\"https://www.baeldung.com/spring-boot-keycloak\" rel=\"nofollow noreferrer\">this tutorial</a> to setup everything needed. My Keycloak is running on localhost:8090 and I've configured it like this:</p>\n<pre><code>package com.my.project.config.security;\n\nimport com.my.project.security.authentication.CustomOidcClientInitiatedLogoutSuccessHandler;\nimport jakarta.servlet.http.Cookie;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.security.config.Customizer;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.core.authority.mapping.GrantedAuthoritiesMapper;\nimport org.springframework.security.oauth2.client.OAuth2AuthorizedClientManager;\nimport org.springframework.security.oauth2.client.OAuth2AuthorizedClientProvider;\nimport org.springframework.security.oauth2.client.OAuth2AuthorizedClientProviderBuilder;\nimport org.springframework.security.oauth2.client.endpoint.DefaultRefreshTokenTokenResponseClient;\nimport org.springframework.security.oauth2.client.registration.ClientRegistrationRepository;\nimport org.springframework.security.oauth2.client.web.*;\nimport org.springframework.security.web.SecurityFilterChain;\nimport org.springframework.security.web.authentication.AnonymousAuthenticationFilter;\nimport org.springframework.security.web.server.authentication.RedirectServerAuthenticationEntryPoint;\n\n@Configuration\npublic class WebSecurityConfig {\n\n    public static String[] PUBLIC_PATHS = {\n            &quot;/api/csrf&quot;,\n            &quot;/oauth2/login&quot;,\n            &quot;/oauth2/logout&quot;,\n            &quot;/oauth2/error&quot;,\n            &quot;/api/contact-form&quot;\n    };\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(final HttpSecurity http,\n                                                   @SuppressWarnings(&quot;SpringJavaInjectionPointsAutowiringInspection&quot;)\n                                                   final ClientRegistrationRepository clientRegistrationRepository) throws Exception {\n\n        final CustomOidcClientInitiatedLogoutSuccessHandler clientInitiatedLogoutSuccessHandler =\n                new CustomOidcClientInitiatedLogoutSuccessHandler(clientRegistrationRepository);\n        clientInitiatedLogoutSuccessHandler.setPostLogoutRedirectUri(&quot;{baseUrl}/oauth2/login?redirect=true&quot;);\n\n        final DefaultOAuth2AuthorizationRequestResolver oAuth2AuthorizationRequestResolver =\n                new DefaultOAuth2AuthorizationRequestResolver(clientRegistrationRepository,\n                        OAuth2AuthorizationRequestRedirectFilter.DEFAULT_AUTHORIZATION_REQUEST_BASE_URI);\n        oAuth2AuthorizationRequestResolver.setAuthorizationRequestCustomizer(OAuth2AuthorizationRequestCustomizers.withPkce());\n\n\n        return http\n                .csrf(Customizer.withDefaults())\n                .cors(Customizer.withDefaults())\n                .authorizeHttpRequests((customizer) -&gt; customizer\n                                .requestMatchers(PUBLIC_PATHS).permitAll()\n                                .anyRequest().authenticated())\n\n                .oauth2ResourceServer((oauth2) -&gt; oauth2\n                    .jwt(Customizer.withDefaults()))\n                .oauth2Client(configurer -&gt; {\n                    //override behaviour of authentication: don't redirect but change status and add location header.\n                    //it's a bit hacky, but otherwise we get CORS errors on client side, because through the redirect we're running into cross-origin issues\n                    //and keycloak is just not setting correct CORS headers :/\n\n                    //delete this hack when bug https://github.com/keycloak/keycloak/pull/27334 is fixed\n                \n\n                    configurer.authorizationCodeGrant(customizer -&gt; {\n                        customizer.authorizationRedirectStrategy((request, response, url) -&gt; {\n                            response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS, HttpHeaders.LOCATION);\n                            response.setHeader(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, HttpHeaders.LOCATION);\n                            response.addCookie(new Cookie(&quot;test&quot;, System.currentTimeMillis() + &quot;&quot;));\n                            response.setHeader(HttpHeaders.LOCATION, url);\n                            if (&quot;true&quot;.equals(request.getParameter(&quot;redirect&quot;))) {\n                                response.setStatus(302);\n                            } else {\n                                response.setStatus(201);\n                            }\n\n\n                        });\n\n                        customizer.authorizationRequestResolver(oAuth2AuthorizationRequestResolver);\n                    });\n                })\n\n                .oauth2Login(configurer -&gt; {\n\n                    configurer.userInfoEndpoint(customizer -&gt; customizer.userAuthoritiesMapper(customGrantedAuthoritiesMapper()));\n                    configurer.loginPage(&quot;/oauth2/login&quot;);\n                    configurer.defaultSuccessUrl(&quot;/oauth2/success&quot;);\n                    configurer.failureUrl(&quot;/oauth2/error&quot;);\n                })\n\n                .logout(configurer -&gt; {\n                    configurer.invalidateHttpSession(true);\n                    configurer.clearAuthentication(true);\n                    configurer.deleteCookies(&quot;JSESSIONID&quot;);\n                    configurer.logoutUrl(&quot;/oauth2/logout&quot;);\n                    configurer.logoutSuccessHandler(clientInitiatedLogoutSuccessHandler);\n                })\n\n                //.addFilterBefore(new TokenExpiredFilter(), AnonymousAuthenticationFilter.class)\n                .build();\n    }\n\n    @Bean\n    public GrantedAuthoritiesMapper customGrantedAuthoritiesMapper() {\n        return new CustomGrantedAuthoritiesMapper();\n    }\n\n}\n</code></pre>\n<p>I needed a couple of customizations, because I had a hard time with Keycloak not setting any ACCESS-CONTROL-ALLOW_ORIGIN headers. So I followed a suggestion to change the default redirect (HTTP 302) to a 2xx code while setting the location header. In the frontend code (React) I then do a window.location to the value of that location header. For the custom logout handler I'm doing the same. Otherwise it's a copy of SimpleUrlLogoutSuccessHandler.</p>\n<p>My application.yml looks like this:</p>\n<pre><code>service:\n  mock: false\n\nkeycloak:\n  realm-id: my-realm-id\n  base-uri: http://localhost:8090\n  base-rest-uri: ${keycloak.base-uri}/admin/realms/${keycloak.realm-id}\n  token-uri: ${keycloak.base-uri}/realms/${keycloak.realm-id}/protocol/openid-connect/token\n\nlogging:\n  level:\n    root: INFO\n\n\nserver:\n  port: 8080\n  servlet:\n    session:\n      timeout: 15s\n      cookie:\n        same-site: none\n        http-only: true\n        secure: true\n\n  error:\n    include-message: never\n    include-binding-errors: never\n    include-stacktrace: never\n    include-exception: false\n\nspring:\n  datasource:\n    url: jdbc:postgresql://localhost:5432/db-name\n    driverClassName: org.postgresql.Driver\n    username: my-user\n    password: my-password\n  jpa:\n    open-in-view: false\n    hibernate:\n      ddl-auto: none\n    properties:\n      database-platform: org.hibernate.dialect.PostgreSQL10Dialect\n    show-sql: false\n\n  security:\n    oauth2:\n      client:\n        registration:\n          keycloak:\n            client_id: my-client-id\n            client_secret: my-client-secret\n            authorization-grant-type: authorization_code\n            scope: openid\n        provider:\n          keycloak:\n            issuerUri: ${keycloak.base-uri}/realms/${keycloak.realm-id}\n            user-name-attribute: preferred_username\n      resourceserver:\n        jwt:\n          issuer-uri: ${keycloak.base-uri}/realms/${keycloak.realm-id}\n\n  flyway:\n    url: ${spring.datasource.url}\n    user: ${spring.datasource.username}\n    password: ${spring.datasource.password}\n    locations: classpath:/db/migration/ddl \n</code></pre>\n<p><strong>Behaviour / Problem description</strong></p>\n<p>When I try to request a protected resource in my Spring backend, I get a redirect to /oauth2/login which redirects to /oauth2/authorization/keycloak which finally &quot;redirect&quot; to Keycloak's login page. This works nicely, I never get in touch with any user credentials and the frontend knows only a JSESSIONID. Also logout works fine, the session in the Keycloak realm is destroyed successfully and the Spring session gets destroyed too.</p>\n<p>My struggles start when it comes to an expired access token. For testing purposes I've set the access token lifespan to 10 seconds in Keycloak and Spring's session lifespan to 15 seconds. Whenever I request something from my protected backend and the session is expired, the login process starts again, redirecting to /oauth2/login, which redirects to /oauth2/authorization/keycloak and finally to the oauth2 login success url configured, without seeing a login form again. In the Keycloak's user events I see another user login and code to token event with a new access token as the result.</p>\n<p>When I debug Spring's code, I see that the authorization_code grant is returning both access token and refresh token correctly, but it seems that the refresh token is never used again. Unfortunately, I cannot find out what is wrong, but I've read that Spring should handle the renewal of the access token using a refresh token out of the box. But</p>\n<blockquote>\n<p>org.springframework.security.oauth2.client.RefreshTokenOAuth2AuthorizedClientProvider#authorize</p>\n</blockquote>\n<p>is never called, nor is</p>\n<blockquote>\n<p>org.springframework.security.oauth2.client.endpoint.DefaultRefreshTokenTokenResponseClient#getTokenResponse</p>\n</blockquote>\n<p>I can see that</p>\n<blockquote>\n<p>org.springframework.security.oauth2.client.web.OAuth2LoginAuthenticationFilter#attemptAuthentication</p>\n</blockquote>\n<p>is calling</p>\n<blockquote>\n<p>this.authorizedClientRepository.saveAuthorizedClient(authorizedClient,\noauth2Authentication, request, response)</p>\n</blockquote>\n<p>This seems to be the last trail of the refresh token, as it does not exist in the OAuth2AuthenticationToken returned from that method.</p>\n<p>Unfortunately, no breakpoint in any implementation of</p>\n<blockquote>\n<p>org.springframework.security.oauth2.client.web.OAuth2AuthorizedClientRepository#loadAuthorizedClient</p>\n</blockquote>\n<p>is ever called to retrieve the refresh token again.</p>\n<p>Any help is appreciated, as I'm really stuck here. Thank you very much for any response, questions and help!</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}