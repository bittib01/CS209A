{
  "question": {
    "tags": [
      "java",
      "jvm",
      "malloc",
      "glibc"
    ],
    "owner": {
      "account_id": 18013206,
      "reputation": 41,
      "user_id": 13092300,
      "user_type": "registered",
      "profile_image": "https://lh3.googleusercontent.com/a-/AOh14Giu1KJ_vCxpaOfrJC1r0V8N10S6191xRiOB_6P2pg=k-s256",
      "display_name": "Forever",
      "link": "https://stackoverflow.com/users/13092300/forever"
    },
    "is_answered": true,
    "view_count": 89,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1762994649,
    "creation_date": 1762957258,
    "last_edit_date": 1762994649,
    "question_id": 79817835,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79817835/returning-memory-from-glibc-malloc-non-main-arenas-to-the-operating-system",
    "title": "Returning memory from glibc malloc non-main arenas to the operating system",
    "body": "<p>I simulated a scenario in Java that leads to severe glibc memory fragmentation.</p>\n<ul>\n<li>Step one: simulate a multithreaded environment with 600 threads.</li>\n<li>Step two: every second, start two new threads that read a large file via <code>java.nio.channels.FileChannel</code>.</li>\n<li>Step three: after 10 seconds, terminate automatically and let GC perform the cleanup.</li>\n</ul>\n<p>This program will keep using memory from the non-main arena regions until the maximum number of arenas is reached, at which point memory usage stabilizes. If you then stop all threads and leave only the main thread sleeping, you’ll find that the process’s RSS metric does not decrease and remains high.</p>\n<ul>\n<li>According to the NMT report, you’ll find that the JVM’s accounting does not show using that much memory.</li>\n<li>From the Linux pmap and smaps information, you’ll see that each 64 MB block in the non-main arena regions has about 8 MB touched in physical memory. If you try to read the binary data from memory, you’ll find that all of it is content from your file.</li>\n</ul>\n<p>The most fascinating part is glibc’s parameter behavior. When I try using the <code>MALLOC_TRIM_THRESHOLD_</code> environment variable, regardless of the value I set, RSS reclamation begins to occur. Since the <code>DirectBuffer</code> used to read the file is 8 MB, I tried 52,428,800 (50 MB) and 8,388,608 (8 MB). Each time, the process’s RSS would reclaim around 16 MB. I once used gdb to inspect the process’s ptmalloc2 allocator trim_threshold parameter, the default value exists and is around 48 MB. After configuring the <code>MALLOC_TRIM_THRESHOLD_</code> variable, the reclamation behavior changes completely, especially for memory in the non-main arena regions.</p>\n<p>By the way, the JDK version I used is 21-openjdk, and the glibc version is 2.39.</p>\n<p>On each file read, the process calls <code>malloc</code> to request off-heap memory, and after the thread dies, the GC thread initiates the free operation. Therefore, in the JVM dump you can observe that all objects, including off-heap <code>DirectBuffer</code>s, are being destroyed in order.</p>\n<p>My main questions are twofold: <strong>why does this parameter affect the drop in memory usage?</strong> In addition, when it is set to 50 MB, even before theoretically reaching the 50 MB reclaimable threshold, glibc also returns memory from the non-main arena to the OS. <strong>It seems that after this parameter is set, glibc’s free behavior has changed?</strong></p>\n<p>To add: this is a JVM runtime parameter, and it’s simple.</p>\n<p><em><em>-Xms6g -Xmx6g -XX:MaxDirectMemorySize=5g -XX:+AlwaysPreTouch -XX:+UseG1GC -Xlog:gc</em>:file=gc.log:time,uptime,level,tags:filecount=5,filesize=100M</em>*</p>\n<pre><code>import java.io.RandomAccessFile;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FileRead1 {\n\n    private static volatile boolean stop = false;\n\n    public static void main(String[] args) throws InterruptedException {\n\n        liveThreadLoopWithoutMemory();\n        \n\n        int count = 0;\n        while (true) {\n            if (count &gt; (Integer.MAX_VALUE -1) ) {\n                break;\n            }\n            count++;\n            try {\n                for (int i = 0; i &lt; 2; i++) {\n                    newThread();\n                }\n\n                for (int i = 0; i &lt; 5; i++) {\n                    Thread.sleep(1000L);\n                }\n            } catch (InterruptedException e) {\n            }\n        }\n\n        stop = true;\n\n        while (true) {\n            for (int i = 0; i &lt; 5; i++) {\n                Thread.sleep(1000L);\n            }\n        }\n    }\n\n    private static void liveThreadLoopWithoutMemory() {\n        for (int i = 0; i &lt; 600; i++) {\n            new Thread(() -&gt; {\n                while (true) {\n                    try {\n                        Thread.sleep(100L);\n                    } catch (InterruptedException e) {\n                        throw new RuntimeException(e);\n                    }\n                    if (stop) {\n                        break;\n                    }\n                }\n            }).start();\n        }\n    }\n\n    private static void newThread() {\n        Thread thread = new Thread(new Runnable() {\n\n            private final List&lt;String&gt; strings = new ArrayList&lt;&gt;();\n\n            @Override\n            public void run() {\n\n                test(strings, &quot;test.txt&quot;, &quot;UTF-8&quot;, false);\n\n                strings.clear();\n            }\n        });\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    private static void test(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test1(strings, src, encoding, hasTitle);\n    }\n\n    private static void test1(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test2(strings, src, encoding, hasTitle);\n\n    }\n\n    private static void test2(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test3(strings, src, encoding, hasTitle);\n    }\n\n    private static void test3(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test4(strings, src, encoding, hasTitle);\n\n    }\n\n    private static void test4(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test5(strings, src, encoding, hasTitle);\n    }\n\n    private static void test5(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test6(strings, src, encoding, hasTitle);\n\n    }\n\n\n    private static void test6(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test7(strings, src, encoding, hasTitle);\n    }\n\n    private static void test7(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test8(strings, src, encoding, hasTitle);\n    }\n\n    private static void test8(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test9(strings, src, encoding, hasTitle);\n    }\n\n    private static void test9(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test10(strings, src, encoding, hasTitle);\n    }\n\n    private static void test10(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        new TaskReadFile() {\n            @Override\n            public void process(String str) {\n                super.process(str + &quot;swk&quot;);\n            }\n        }.readFile(strings, src, encoding, hasTitle);\n    }\n\n\n    static class TaskReadFile implements ReadFileInterface {\n\n\n        private final List&lt;String&gt; stringList = new ArrayList&lt;&gt;();\n\n        @Override\n        public void process(String str) {\n            stringList.add(str + &quot;123&quot;);\n        }\n\n        @Override\n        public void clear() {\n            stringList.clear();\n        }\n    }\n\n    interface ReadFileInterface {\n\n        void process(String str);\n\n        void clear();\n\n        default void readFile(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n            int readLimit = 8 * 1024 * 1024;\n            int startIndex = 0;\n\n            try (RandomAccessFile raf = new RandomAccessFile(src, &quot;r&quot;);) {\n                FileChannel channel = raf.getChannel();\n                ByteBuffer rbuf = ByteBuffer.allocate(readLimit);\n\n                synchronized (rbuf) {\n                    channel.position(startIndex);\n                    \n                    byte[] temp = new byte[0];\n                    int LF = 10;\n                    long lineCount = 0;\n\n                    while (channel.read(rbuf) != -1) {\n                        int position = rbuf.position();\n                        byte[] rbyte = new byte[position];\n                        rbuf.flip();\n                        rbuf.get(rbyte);\n                        int startnum = 0;\n\n                        for (int i = 0; i &lt; rbyte.length; i++) {\n                            if (rbyte[i] == LF) {\n                                if (channel.position() == startIndex) {\n                                    startnum = i + 1;\n                                } else {\n                                    if (hasTitle &amp;&amp; 0 == lineCount) {\n                                        startnum = i + 1;\n                                        lineCount++;\n                                        continue;\n                                    }\n                                    int lineLen = i - startnum + 1;\n                                    byte[] line = new byte[temp.length + lineLen];\n                                    System.arraycopy(temp, 0, line, 0, temp.length);\n                                    System.arraycopy(rbyte, startnum, line, temp.length, lineLen);\n                                    startnum = i + 1;\n                                    temp = new byte[0];\n                                    String str = trimEndingCRLF(line, encoding);\n                                    strings.add(str);\n                                    process(str);\n                                }\n                            }\n                        }\n\n\n                        if (startnum &lt; rbyte.length) {\n                            byte[] temp2 = new byte[temp.length + rbyte.length - startnum];\n                            System.arraycopy(temp, 0, temp2, 0, temp.length);\n                            System.arraycopy(rbyte, startnum, temp2, temp.length, rbyte.length - startnum);\n                            temp = temp2;\n                        }\n                        rbuf.clear();\n                    }\n                }\n\n                rbuf.clear();\n\n                try {\n                    Thread.sleep(10000L);\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n\n                clear();\n\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n\n        default String trimEndingCRLF(byte[] line, String encoding) throws UnsupportedEncodingException {\n            if (line.length != 0 &amp;&amp; line[0] != 10) {\n                int lastIdx = line.length - 1;\n                if (line[lastIdx] != 10) {\n                    ++lastIdx;\n                } else if (line[lastIdx - 1] == 13) {\n                    --lastIdx;\n                }\n\n                return new String(line, 0, lastIdx, encoding);\n            } else {\n                return &quot;&quot;;\n            }\n        }\n    }\n}\n\n```java\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}