{
  "question": {
    "tags": [
      "python",
      "java",
      "arrays",
      "performance",
      "hashmap"
    ],
    "owner": {
      "account_id": 21416883,
      "reputation": 23,
      "user_id": 15775974,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/edc26098f0fb2c9de97886d594db3007?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "James",
      "link": "https://stackoverflow.com/users/15775974/james"
    },
    "is_answered": true,
    "view_count": 151,
    "accepted_answer_id": 79594899,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1749224770,
    "creation_date": 1745734983,
    "last_edit_date": 1745746725,
    "question_id": 79594738,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79594738/why-the-performance-is-bad-if-i-use-hashmap-to-solve-codility-problem-minabssum",
    "title": "Why the performance is bad if I use HashMap to solve Codility problem MinAbsSum?",
    "body": "<p>Regarding the Codility problem MinAbsSum at <a href=\"https://app.codility.com/programmers/lessons/17-dynamic_programming/min_abs_sum/\" rel=\"nofollow noreferrer\">https://app.codility.com/programmers/lessons/17-dynamic_programming/min_abs_sum/</a>, the performance is bad if I use HashMap to solve the problem. I expect the performance to be similar to Array. I prefer to use HashMap because Array wastes a lot of memory if the number range is too large. Any idea why the HashMap is much slower than the Array?</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.util.*;\n\npublic class MinAbsSumUsingHashMap {\n    // Total score = 54%\n    // Detected time complexity: O(N**2 * max(abs(A)))\n    public int solution(int[] A) {\n        // 1. Convert all numbers to absolute numbers\n        // 2. Sum all the converted absolute numbers\n        // 3. Count the occurrence of all the converted absolute numbers\n        int sum = 0;\n        Map&lt;Integer, Integer&gt; numberCountMap = new TreeMap&lt;&gt;();\n        for (int num : A) {\n            int absNum = Math.abs(num);\n            sum += absNum;\n            numberCountMap.merge(absNum, 1, Integer::sum);\n        }\n\n        AllPossibleSumNumbers allPossibleSumNumbers = new AllPossibleSumNumbers(sum);\n        for (Map.Entry&lt;Integer, Integer&gt; entry : numberCountMap.entrySet()) {\n            int absNum = entry.getKey();\n            int count = entry.getValue();\n            allPossibleSumNumbers.addPossibleSumNumber(absNum, count);\n        }\n\n        float halfSum = sum / 2f;\n        int halfSumFloor = (int) Math.floor(halfSum);\n        for (int bestPossibleHalfSum = halfSumFloor; bestPossibleHalfSum &gt;= 0; bestPossibleHalfSum--) {\n            if (allPossibleSumNumbers.isPossibleSumNumber(bestPossibleHalfSum)) {\n                float halfDifference = halfSum - bestPossibleHalfSum;\n                float fullDifference = halfDifference * 2;\n                return (int) fullDifference;\n            }\n        }\n        return -1; // Ideally, it will not return -1.\n    }\n\n    class AllPossibleSumNumbers {\n        private final Map&lt;Integer, Integer&gt; allPossibleSumCounts = new HashMap&lt;&gt;();\n        private final int expectedSum;\n\n        public AllPossibleSumNumbers(int expectedSum) {\n            this.expectedSum = expectedSum;\n\n            // Sum 0 can be achieved without any number\n            int possibleSumNumber = 0;\n            int count = 0;\n            allPossibleSumCounts.put(possibleSumNumber, count);\n        }\n\n        public void addPossibleSumNumber(int num, int count) {\n            for (int possibleSum = 0; possibleSum &lt;= expectedSum; possibleSum++) {\n                if (isPossibleSumNumber(possibleSum)) {\n                    // we can set like this because no value num is needed to obtain the possibleSum\n                    allPossibleSumCounts.put(possibleSum, count);\n                } else if (possibleSum &gt;= num) {\n                    // It is not a possible sum number, check the previous one\n                    int prevPossibleSum = possibleSum - num;\n                    Integer prevCount = allPossibleSumCounts.get(prevPossibleSum);\n                    if (prevCount != null) {\n                        // previous one is a possible sum number\n                        int currCount = prevCount - 1; // currCount should be reduced by 1 because the num has been used once to achieve the current sum\n                        if (currCount &gt;= 0) {\n                            // Is currCount &gt;= 0 necessary? Got the same score after adding currCount &gt;= 0 condition :(\n                            allPossibleSumCounts.put(possibleSum, currCount);\n                        }\n                    }\n                }\n            }\n        }\n\n        public boolean isPossibleSumNumber(int num) {\n            Integer count = allPossibleSumCounts.get(num);\n            if (count == null) {\n                return false;\n            } else {\n                return count &gt;= 0;\n            }\n        }\n    }\n}\n</code></pre>\n<p>A similar code uses array can achieve a 100% score.</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.util.*;\n\npublic class MinAbsSumUsingArray {\n    // Total score = 100%\n    // Detected time complexity: O(N * max(abs(A))**2)\n    public int solution(int[] A) {\n        // 1. Convert all numbers to absolute numbers\n        // 2. Sum all the converted absolute numbers\n        // 3. Count the occurrence of all the converted absolute numbers\n        int sum = 0;\n        Map&lt;Integer, Integer&gt; numberCountMap = new TreeMap&lt;&gt;();\n        for (int num : A) {\n            int absNum = Math.abs(num);\n            sum += absNum;\n            numberCountMap.merge(absNum, 1, Integer::sum);\n        }\n\n        AllPossibleSumNumbers allPossibleSumNumbers = new AllPossibleSumNumbers(sum);\n        for (Map.Entry&lt;Integer, Integer&gt; entry : numberCountMap.entrySet()) {\n            int absNum = entry.getKey();\n            int count = entry.getValue();\n            allPossibleSumNumbers.addPossibleSumNumber(absNum, count);\n        }\n\n        float halfSum = sum / 2f;\n        int halfSumFloor = (int) Math.floor(halfSum);\n        for (int bestPossibleHalfSum = halfSumFloor; bestPossibleHalfSum &gt;= 0; bestPossibleHalfSum--) {\n            if (allPossibleSumNumbers.isPossibleSumNumber(bestPossibleHalfSum)) {\n                float halfDifference = halfSum - bestPossibleHalfSum;\n                float fullDifference = halfDifference * 2;\n                return (int) fullDifference;\n            }\n        }\n        return -1; // Ideally, it will not return -1.\n    }\n\n    class AllPossibleSumNumbers {\n        private final int[] allPossibleSumCounts;\n\n        public AllPossibleSumNumbers(int expectedSum) {\n            allPossibleSumCounts = new int[expectedSum + 1];\n\n            // first one is 0. the rest are -1\n            for (int i = 1; i &lt; allPossibleSumCounts.length; i++) {\n                allPossibleSumCounts[i] = -1;\n            }\n        }\n\n        public void addPossibleSumNumber(int num, int count) {\n            for (int possibleSum = 0; possibleSum &lt; allPossibleSumCounts.length; possibleSum++) {\n                if (isPossibleSumNumber(possibleSum)) {\n                    // we can set like this because no value num is needed to obtain the possibleSum\n                    allPossibleSumCounts[possibleSum] = count;\n                } else if (possibleSum &gt;= num) {\n                    // It is not a possible sum number, check the previous one\n                    int prevPossibleSum = possibleSum - num;\n                    int prevCount = allPossibleSumCounts[prevPossibleSum];\n                    int currCount = prevCount - 1; // currCount should be reduced by 1 because the num has been used once to achieve the current sum\n                    allPossibleSumCounts[possibleSum] = currCount;\n                }\n            }\n        }\n\n        public boolean isPossibleSumNumber(int num) {\n            return allPossibleSumCounts[num] &gt;= 0;\n        }\n    }\n}\n</code></pre>\n<p>Interestingly, I just tried the same in Python, and both work fine. I assume the Python dictionary is equivalent to the Java HashMap. Please let me know if I am wrong.</p>\n<pre class=\"lang-py prettyprint-override\"><code>def solution(A):\n    array_length = len(A)\n    # 1. Convert all numbers to absolute numbers\n    for best_possible_half_sum in range(array_length):\n        A[best_possible_half_sum] = abs(A[best_possible_half_sum])\n    # 2. Sum all the converted absolute numbers\n    abs_sum = sum(A)\n    # 3. Count the occurrence of all the converted absolute numbers\n    num_counts = {}\n    for num in A:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n\n    # Sum 0 can be achieved without any number\n    all_possible_sum_counts = {0: 0}\n\n    for num, count in num_counts.items():\n        for possible_sum in range(abs_sum):\n            if possible_sum in all_possible_sum_counts and all_possible_sum_counts[possible_sum] &gt;= 0:\n                # we can set like this because no value num is needed to obtain the possible_sum\n                all_possible_sum_counts[possible_sum] = count\n            elif (possible_sum &gt;= num):\n                # It is not a possible sum number, check the previous one\n                prev_possible_sum = possible_sum - num\n                if prev_possible_sum in all_possible_sum_counts:\n                    # previous one is a possible sum number\n                    prev_count = all_possible_sum_counts[prev_possible_sum]\n                    curr_count = prev_count - 1 # currCount should be reduced by 1 because the num has been used once to achieve the current sum\n                    all_possible_sum_counts[possible_sum] = curr_count\n    \n    half_sum = abs_sum / 2\n    half_sum_floor = abs_sum // 2\n    for best_possible_half_sum in range(half_sum_floor, -1, -1):\n        if best_possible_half_sum in all_possible_sum_counts and all_possible_sum_counts[best_possible_half_sum] &gt;= 0:\n            half_difference = half_sum - best_possible_half_sum\n            full_difference = half_difference * 2\n            return int(full_difference)\n</code></pre>\n<p>Below is the array version</p>\n<pre class=\"lang-py prettyprint-override\"><code>def solution(A):\n    array_length = len(A)\n    # 1. Convert all numbers to absolute numbers\n    for best_possible_half_sum in range(array_length):\n        A[best_possible_half_sum] = abs(A[best_possible_half_sum])\n    # 2. Sum all the converted absolute numbers\n    abs_sum = sum(A)\n    # 3. Count the occurrence of all the converted absolute numbers\n    num_counts = {}\n    for num in A:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n\n    # first one is 0. the rest are -1\n    all_possible_sum_counts = [-1] * (abs_sum + 1)\n    all_possible_sum_counts[0] = 0\n\n    for num, count in num_counts.items():\n        for possible_sum in range(abs_sum):\n            if all_possible_sum_counts[possible_sum] &gt;= 0:\n                # we can set like this because no value num is needed to obtain the possible_sum\n                all_possible_sum_counts[possible_sum] = count\n            elif (possible_sum &gt;= num):\n                # It is not a possible sum number, check the previous one\n                prev_possible_sum = possible_sum - num\n                prev_count = all_possible_sum_counts[prev_possible_sum]\n                curr_count = prev_count - 1 # currCount should be reduced by 1 because the num has been used once to achieve the current sum\n                all_possible_sum_counts[possible_sum] = curr_count\n    \n    half_sum = abs_sum / 2\n    half_sum_floor = abs_sum // 2\n    for best_possible_half_sum in range(half_sum_floor, -1, -1):\n        if all_possible_sum_counts[best_possible_half_sum] &gt;= 0:\n            half_difference = half_sum - best_possible_half_sum\n            full_difference = half_difference * 2\n            return int(full_difference)\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}