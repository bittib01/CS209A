{
  "question": {
    "tags": [
      "java",
      "algorithm",
      "quicksort",
      "partition"
    ],
    "owner": {
      "account_id": 26204274,
      "reputation": 3,
      "user_id": 19884099,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/e73a64b87637843e99a75aadb63a1d30?s=256&d=identicon&r=PG",
      "display_name": "santa_claus",
      "link": "https://stackoverflow.com/users/19884099/santa-claus"
    },
    "is_answered": true,
    "view_count": 93,
    "accepted_answer_id": 78903485,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1724395972,
    "creation_date": 1724268398,
    "last_edit_date": 1724395972,
    "question_id": 78898693,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78898693/why-is-one-stopping-condition-for-quicksorts-partitioning-step-with-two-pointer",
    "title": "Why is one stopping condition for quicksort&#39;s partitioning step with two pointers L and R, while (L &lt;= R)? Can it be while (L &lt; R)?",
    "body": "<p>I'm trying to understand the difference between these two conditions for the partition step of quicksort. While writing this out, I'm capitalizing single letter variable names so it's more readable.<br />\nIn this implementation of quicksort, for simplicity's sake, let's say the <code>pivot_idx = (L + R) // 2</code>, and <code>arr[high]</code> and <code>arr[pivot]</code> are swapped before partitioning. So the <code>L</code> pointer starts at the low index, while the <code>R</code> pointer starts at the <code>high - 1</code> index. Let's also say the <code>L</code> pointer is incremented until it finds an element that is &gt; pivot, and the next loop decrements the <code>R</code> pointer until it finds an element &lt;= pivot.</p>\n<p>If the condition is <code>while (L &lt; R)</code>, and we increment the <code>L</code> pointer until it finds an element &gt; pivot, then in the final iteration, <code>L</code> moves forward until it meets <code>R</code>. <code>arr[R]</code> already points to an element that is &gt; pivot, as <code>arr[L]</code> and <code>arr[R]</code> were swapped in the previous step.  So the pivot should correctly be placed where <code>L</code> points to at the end.</p>\n<p>My function signature is <code>partition(int[] arr, int low, int high)</code>. Here is some sample code I wrote.</p>\n<pre><code>int pivotIdx = (low + high) / 2;\nint pivotElem = arr[pivotIdx];\n\nint r = high - 1;\nint l = low;\n// Swap pivot and final elem\narr[pivotIdx] = arr[high];\narr[high] = pivotElem;\n\nwhile (l &lt;= r) {\n    while (l &lt;= r &amp;&amp; arr[l] &lt;= pivotElem) {\n        l++;\n    }\n    while (l &lt;= r &amp;&amp; arr[r] &gt; pivotElem) {\n        r--;\n    }\n    if (l &lt; r) {\n        int tmp = arr[l]; // bigger element\n        arr[l] = arr[r]; // assign smaller element to left idx\n        arr[r] = tmp; // assign bigger element to right idx\n    }\n}\narr[high] = arr[l];\narr[l] = pivotElem;\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}