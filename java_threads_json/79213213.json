{
  "question": {
    "tags": [
      "java",
      "spring",
      "spring-boot",
      "spring-mvc",
      "spring-security"
    ],
    "owner": {
      "account_id": 20164200,
      "reputation": 1,
      "user_id": 14788551,
      "user_type": "registered",
      "profile_image": "https://lh3.googleusercontent.com/a-/AOh14GgJWWK75wcgT-IJzjcvPXCcj2XBNtvM-iuy2quZEA=k-s256",
      "display_name": "devan5hu",
      "link": "https://stackoverflow.com/users/14788551/devan5hu"
    },
    "is_answered": false,
    "view_count": 94,
    "answer_count": 1,
    "score": -1,
    "last_activity_date": 1732260122,
    "creation_date": 1732232426,
    "last_edit_date": 1732232551,
    "question_id": 79213213,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79213213/forbidden-error-when-i-include-async-to-a-method",
    "title": "Forbidden Error when I include @Async to a method",
    "body": "<p>I am relatively new to java and was working on a personal project of mine. I was successfully able to build it synchoronously. Just for learning more I wanted to start making it asynchronous. It's an order management system featuring Customer, Order and OrderItems entity. The first method I started to make synchronous was the 'createOrder'</p>\n<p>My Controller:</p>\n<pre><code>@PostMapping(&quot;/place&quot;)\npublic CompletableFuture&lt;ResponseEntity&lt;OrderStatusResponse&gt;&gt;\ncreateOrder(@RequestBody OrderRequest orderRequest) {    \nString username = getAuthenticatedUsername();\n        return orderService.createOrder(orderRequest , username)\n                .thenApply(order -&gt; {\n                    OrderStatusResponse orderResponse = new OrderStatusResponse(ORDER_PLACED, order.getOrderId());\n                    return new ResponseEntity&lt;&gt;(orderResponse, HttpStatus.OK);\n                })\n                .exceptionally(ex -&gt; {\n                    System.out.println(ex.getMessage());\n                    return new ResponseEntity&lt;&gt;(HttpStatus.INTERNAL_SERVER_ERROR);\n                });\n    }\n</code></pre>\n<p>My Service :</p>\n<pre><code>public CompletableFuture&lt;Orders&gt; createOrder(OrderRequest orderRequest) {\n        try {\n            String username = SecurityContextHolder.getContext().getAuthentication().getName();\n            Customer authenticatedCustomer = customerRepository.findByUsername(username)\n                    .orElseThrow(() -&gt; new CustomerNotFoundException(&quot;Authenticated customer not found&quot;));\n\n            validateOrderRequest(orderRequest);\n\n            Orders order = new Orders();\n            order.setCustomer(authenticatedCustomer);\n            order.setStatus(ORDER_PLACED);\n            order.setTimestamp(orderRequest.getTimestamp());\n            order.setTotalAmount(orderRequest.getTotalAmount());\n\n            List&lt;OrderItems&gt; orderItems = orderRequest.getOrderItems().stream()\n                    .map(itemRequest -&gt; new OrderItems(order, itemRequest.getProductId(),\n                            itemRequest.getQuantity(), itemRequest.getPrice()))\n                    .collect(Collectors.toList());\n\n            order.setOrderItems(orderItems);\n\n            return CompletableFuture.completedFuture(orderRepository.save(order));\n        } catch (DataIntegrityViolationException e) {\n            throw new InvalidOrder(&quot;Unable to save order. Please check the provided data.&quot;);\n        }\n    }\n</code></pre>\n<p>My Security Config:</p>\n<pre><code>@Configuration\n@EnableWebSecurity\npublic class SecurityConfig{\n\n    private final JwtAuthenticationFilter jwtAuthenticationFilter;\n\n    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {\n        this.jwtAuthenticationFilter = jwtAuthenticationFilter;\n    }\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http\n                .csrf(AbstractHttpConfigurer::disable)\n                .authorizeHttpRequests(authorize -&gt; authorize\n                        .requestMatchers(&quot;/api/login&quot; , &quot;/api/register&quot;, &quot;/error&quot;).permitAll() // Open the register endpoint\n                        .requestMatchers(&quot;/api/orders/place&quot;).hasRole(&quot;USER&quot;)\n                        .anyRequest().authenticated() // Protect all other endpoints\n                )\n                .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)\n                .exceptionHandling((exception) -&gt;exception.accessDeniedPage(&quot;/error/404&quot;));\n\n        return http.build();\n    }\n\n    @Bean\n    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {\n        return authenticationConfiguration.getAuthenticationManager();\n    }\n}\n</code></pre>\n<p>Surprisingly at first my API is getting authorised and I can see the logs of an order being placed.</p>\n<pre><code> Hibernate: select c1_0.customer_id,c1_0.email,c1_0.name,c1_0.password,c1_0.phone,c1_0.username from customer c1_0 where c1_0.username=?\nHibernate: select c1_0.customer_id,c1_0.email,c1_0.name,c1_0.password,c1_0.phone,c1_0.username from customer c1_0 where c1_0.username=?\nHibernate: insert into orders (customer_id,status,timestamp,total_amount) values (?,?,?,?)\nHibernate: insert into order_items (order_id,price,product_id,quantity) values (?,?,?,?)\nHibernate: insert into order_items (order_id,price,product_id,quantity) values (?,?,?,?)\nHibernate: insert into order_items (order_id,price,product_id,quantity) values (?,?,?,?)\nHibernate: insert into order_items (order_id,price,product_id,quantity) values (?,?,?,?)\nHibernate: insert into order_items (order_id,price,product_id,quantity) values (?,?,?,?)\nHibernate: insert into order_items (order_id,price,product_id,quantity) values (?,?,?,?)\n</code></pre>\n<p>But then the reponse is not appearing shows &quot;Empty Response Body&quot; with an error code of 403.</p>\n<pre><code>HTTP/1.1 403 \nX-Content-Type-Options: nosniff\nX-XSS-Protection: 0\nCache-Control: no-cache, no-store, max-age=0, must-revalidate\nPragma: no-cache\nExpires: 0\nX-Frame-Options: DENY\nContent-Length: 0\nDate: Thu, 21 Nov 2024 22:00:44 GMT\n\n&lt;Response body is empty&gt;\n// 5 seconds because i set a timeout. \nResponse code: 403; Time: 5442ms (5 s 442 ms); Content length: 0 bytes (0 B)\n</code></pre>\n<p>I have no idea why this is happening.</p>\n<p>I tried storing the Security Context manually in the same thread as well did not work.\nSomething like,</p>\n<pre><code>SecurityContext context = SecurityContextHolder.getContext();\nSecurityContextHolder.setContext(context);\n.\n.\n.\n.\n.\n.\n.\nSecurityContextHolder.clearContext();\n</code></pre>\n<p>Was expecting the instance of customer to be saved but that did not happen.\nI was expecting a response of</p>\n<pre><code>{\n  &quot;status&quot;: &quot;ORDER PLACED&quot;,\n  &quot;orderId&quot;: x\n}\n</code></pre>\n<p>That did not work too, any ideas what could fix this?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}