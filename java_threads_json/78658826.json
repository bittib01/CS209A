{
  "question": {
    "tags": [
      "java",
      "android",
      "image-processing",
      "android-bitmap",
      "generative-adversarial-network"
    ],
    "owner": {
      "account_id": 17910783,
      "reputation": 9,
      "user_id": 23436655,
      "user_type": "registered",
      "profile_image": "https://lh3.googleusercontent.com/a-/AOh14GgXZjegw3-cFz7SkcLp2uMLJ894MNKwAXkxop29OQ=k-s256",
      "display_name": "Doctor Pizza",
      "link": "https://stackoverflow.com/users/23436655/doctor-pizza"
    },
    "is_answered": true,
    "view_count": 77,
    "accepted_answer_id": 78659124,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1719321483,
    "creation_date": 1719149526,
    "question_id": 78658826,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78658826/blending-bitmap-tiles",
    "title": "Blending bitmap tiles",
    "body": "<p>I'm using a GAN tflite model to process a bitmap. T model only accepts images of 512 x 512 pixels, so I first crop the image into tiles and then process all tiles at once. This resulted in an image full of seams and lines, so I added a code to blend the edges together.</p>\n<pre><code> @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); imageView = findViewById(R.id.imageView); picture = findViewById(R.id.button); MIRNetConverter.initialize(MainActivity.this); uploadButton = findViewById(R.id.upload);\n\n    uploadButton.setOnClickListener(new View.OnClickListener() {\n        @RequiresApi(api = Build.VERSION_CODES.TIRAMISU)\n        @Override\n        public void onClick(View view) {\n            if (ActivityCompat.checkSelfPermission(MainActivity.this, Manifest.permission.READ_MEDIA_IMAGES) != PackageManager.PERMISSION_GRANTED) {\n                ActivityCompat.requestPermissions(MainActivity.this, new String[]{Manifest.permission.READ_MEDIA_IMAGES}, 1);\n            } else {\n                uploadImage();\n            }\n        }\n    });\n\n  \n    processingDialog = new Dialog(this);\n    processingDialog.requestWindowFeature(Window.FEATURE_NO_TITLE);\n    processingDialog.setCancelable(false);\n    processingDialog.setContentView(R.layout.processing_screen);\n    executorService = Executors.newFixedThreadPool(4);\n}\n\n@Override\nprotected void onDestroy() {\n    super.onDestroy();\n    if (executorService != null) {\n        executorService.shutdown();\n    }\n}\n\nprivate void showProcessingDialog() {\n    if (processingDialog != null &amp;&amp; !processingDialog.isShowing()) {\n        ProgressBar progressBar = processingDialog.findViewById(R.id.progressBar);\n        TextView textView = processingDialog.findViewById(R.id.textView);\n        if (progressBar != null &amp;&amp; textView != null) {\n            progressBar.setIndeterminate(true);\n            textView.setText(&quot;Processing...&quot;);\n        }\n        processingDialog.show();\n    }\n}\n\nprivate void uploadImage() {\n    Intent galleryIntent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);\n    startActivityForResult(galleryIntent, 2);\n}\n\nprivate void hideProcessingDialog() {\n    if (processingDialog != null &amp;&amp; processingDialog.isShowing()) {\n        processingDialog.dismiss();\n    }\n}\n\n@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    super.onActivityResult(requestCode, resultCode, data);\n    if (resultCode == RESULT_OK) {\n        if (requestCode == 1 &amp;&amp; data != null) {\n            Bitmap image = (Bitmap) data.getExtras().get(&quot;data&quot;);\n            imageView.setImageBitmap(image);\n            showProcessingDialog();\n            processImage(image);\n        } else if (requestCode == 2 &amp;&amp; data != null) {\n            try {\n                Bitmap image = MediaStore.Images.Media.getBitmap(this.getContentResolver(), data.getData());\n                imageView.setImageBitmap(image);\n                showProcessingDialog();\n                processImage(image);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\nprivate void processImage(Bitmap image) {\n    executorService.execute(new Runnable() {\n        @Override\n        public void run() {\n            int width = image.getWidth();\n            int height = image.getHeight();\n            Bitmap resultBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n            int numTilesX = (int) Math.ceil((float) width / (TILE_SIZE - OVERLAP));\n            int numTilesY = (int) Math.ceil((float) height / (TILE_SIZE - OVERLAP));\n\n            for (int y = 0; y &lt; numTilesY; y++) {\n                for (int x = 0; x &lt; numTilesX; x++) {\n                    int startX = x * (TILE_SIZE - OVERLAP);\n                    int startY = y * (TILE_SIZE - OVERLAP);\n                    int endX = Math.min(startX + TILE_SIZE, width);\n                    int endY = Math.min(startY + TILE_SIZE, height);\n\n                    startX = Math.max(startX, 0);\n                    startY = Math.max(startY, 0);\n\n                    Bitmap tileBitmap = Bitmap.createBitmap(image, startX, startY, endX - startX, endY - startY);\n                    Bitmap processedTile = processTile(tileBitmap);\n\n                    int drawX = x * (TILE_SIZE - OVERLAP);\n                    int drawY = y * (TILE_SIZE - OVERLAP);\n\n                    blendTiles(resultBitmap, processedTile, drawX, drawY, startX, startY, endX, endY);\n                }\n            }\n\n            runOnUiThread(new Runnable() {\n                @Override\n                public void run() {\n                    imageView.setImageBitmap(resultBitmap);\n                    hideProcessingDialog();\n                }\n            });\n        }\n    });\n}\n\nprivate void blendTiles(Bitmap result, Bitmap tile, int drawX, int drawY, int startX, int startY, int endX, int endY) {\n    Canvas canvas = new Canvas(result);\n    Paint paint = new Paint();\n    paint.setAntiAlias(true);\n\n    int tileWidth = tile.getWidth();\n    int tileHeight = tile.getHeight();\n\n    for (int i = 0; i &lt; tileWidth; i++) {\n        for (int j = 0; j &lt; tileHeight; j++) {\n            int tilePixel = tile.getPixel(i, j);\n            int resultPixelX = drawX + i;\n            int resultPixelY = drawY + j;\n\n            if (resultPixelX &lt; endX &amp;&amp; resultPixelY &lt; endY) {\n                int resultPixel = result.getPixel(resultPixelX, resultPixelY);\n\n                float alpha = calculateAlpha(i, j, tileWidth, tileHeight);\n                int blendedPixel = blendPixels(resultPixel, tilePixel, alpha);\n\n                result.setPixel(resultPixelX, resultPixelY, blendedPixel);\n            }\n        }\n    }\n}\n\nprivate float calculateAlpha(int x, int y, int width, int height) {\n    float edgeX = (x &lt; OVERLAP) ? (x / (float) OVERLAP) : ((width - x - 1) &lt; OVERLAP) ? ((width - x - 1) / (float) OVERLAP) : 1.0f;\n    float edgeY = (y &lt; OVERLAP) ? (y / (float) OVERLAP) : ((height - y - 1) &lt; OVERLAP) ? ((height - y - 1) / (float) OVERLAP) : 1.0f;\n    return Math.min(edgeX, edgeY);\n}\n\nprivate int blendPixels(int basePixel, int topPixel, float alpha) {\n    int baseAlpha = Color.alpha(basePixel);\n    int baseRed = Color.red(basePixel);\n    int baseGreen = Color.green(basePixel);\n    int baseBlue = Color.blue(basePixel);\n\n    int topAlpha = Color.alpha(topPixel);\n    int topRed = Color.red(topPixel);\n    int topGreen = Color.green(topPixel);\n    int topBlue = Color.blue(topPixel);\n\n    int blendedAlpha = (int) (baseAlpha * (1 - alpha) + topAlpha * alpha);\n    int blendedRed = (int) (baseRed * (1 - alpha) + topRed * alpha);\n    int blendedGreen = (int) (baseGreen * (1 - alpha) + topGreen * alpha);\n    int blendedBlue = (int) (baseBlue * (1 - alpha) + topBlue * alpha);\n\n    return Color.argb(blendedAlpha, blendedRed, blendedGreen, blendedBlue);\n}\n\nprivate Bitmap processTile(Bitmap tile) {\n    Bitmap resizedTile = Bitmap.createScaledBitmap(tile, TILE_SIZE, TILE_SIZE, true);\n    Bitmap normalTile = MIRNetConverter.convertToNormal(MainActivity.this, resizedTile);\n    return Bitmap.createScaledBitmap(normalTile, tile.getWidth(), tile.getHeight(), true);\n}\n@Override\npublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n    super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n    if (requestCode == 100) {\n        if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n            startCamera();\n        }\n    } else if (requestCode == 1) {\n        if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n            uploadImage();\n        } else {\n            Toast.makeText(this, &quot;Permission denied to read images from media storage&quot;, Toast.LENGTH_SHORT).show();\n        }\n    }\n}\n</code></pre>\n<p>My code kind of works, but the edges are now extremely dark. Any opinion on why it's the case?</p>\n<p><img src=\"https://i.sstatic.net/y8DhMW0w.png\" alt=\"example result\" /></p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}