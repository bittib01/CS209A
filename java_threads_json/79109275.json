{
  "question": {
    "tags": [
      "java",
      "rounding",
      "integer-division"
    ],
    "owner": {
      "account_id": 6734881,
      "reputation": 2365,
      "user_id": 5190019,
      "user_type": "registered",
      "accept_rate": 91,
      "profile_image": "https://www.gravatar.com/avatar/4251265c261510501ce3ea76bd7b7dbe?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "arso",
      "link": "https://stackoverflow.com/users/5190019/arso"
    },
    "is_answered": false,
    "view_count": 111,
    "closed_date": 1729500812,
    "answer_count": 0,
    "score": 1,
    "last_activity_date": 1729847464,
    "creation_date": 1729500523,
    "last_edit_date": 1729847464,
    "question_id": 79109275,
    "link": "https://stackoverflow.com/questions/79109275/why-javas-int-division-rounds-to-zero",
    "closed_reason": "Duplicate",
    "title": "Why Java&#39;s int division rounds to zero?",
    "body": "<p>I've found that the rule for rounding two int in Java is to get the value closer to 0.</p>\n<p>Which mean that if you divide two positive numbers, you get the &quot;floor&quot; value e.g <code>7/3=2</code>.\nAnd if you divide one negative value by a positive one (or vice versa), you get the &quot;ceiling&quot; value: <code>-7/3 = -2</code>.</p>\n<p>I would expect to be either both floor or ceiling value.</p>\n<ul>\n<li><p>Is it because the &quot;negative&quot; is evaluated after the division ?</p>\n</li>\n<li><p>It it some legacy over C ?</p>\n</li>\n<li><p>Is it to stay consistant with some transitive operation of the remainder (% operator) ?\n(i.e <code>(a+(a%b)/b = ceiling(a/b)</code> and <code>(a-(a%b)/b = floor(a/b)</code> )</p>\n</li>\n</ul>\n<hr />\n<p>One of the comment has the definitive answer I was looking for: it is specified in Java's official documentation: <a href=\"https://docs.oracle.com/javase/specs/jls/se23/html/jls-15.html#jls-15.17.2-200\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/specs/jls/se23/html/jls-15.html#jls-15.17.2-200</a></p>\n<blockquote>\n<p>Integer division rounds toward 0.</p>\n</blockquote>\n<hr />\n<p>As a lot of people also commented: it most likely comes from C, which comes from CPU implementation of integer division.</p>\n<p>The C norm is described here: <a href=\"https://stackoverflow.com/a/3604984/5190019\">https://stackoverflow.com/a/3604984/5190019</a> and it also says that C did it that way because Fortran also did.</p>\n<p>The linked question ( <a href=\"https://stackoverflow.com/questions/5682625/why-do-integer-div-and-mod-round-towards-zero\">Why do integer div and mod round towards zero?</a>) explains how usual division with negative number occurs: division is made as if both number were positive, then it's transformed to the equivalent negative number.</p>\n<p>Originally, it certainly comes from the easiest way to perform integer division with a CPU (with negative numbers using &quot;two's complement&quot; representation).</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}