{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "apache-kafka",
      "spring-kafka",
      "apache-kafka-streams"
    ],
    "owner": {
      "account_id": 26032801,
      "reputation": 43,
      "user_id": 19738740,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/5adc5ae16e07a2b7d5f42d19dbc7186f?s=256&d=identicon&r=PG",
      "display_name": "Misa",
      "link": "https://stackoverflow.com/users/19738740/misa"
    },
    "is_answered": false,
    "view_count": 148,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1735497060,
    "creation_date": 1728901344,
    "last_edit_date": 1728993097,
    "question_id": 79085747,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79085747/how-to-access-headers-in-a-globalktable-in-kafka-streams",
    "title": "How to Access Headers in a GlobalKTable in Kafka Streams",
    "body": "<p>I am trying to use a GlobalKTable to store data from a Kafka topic during the startup of my application. Both the GlobalKTable and KStream consume the same topic, I need to access headers in the GlobalKTable for processing. After the initial data load, my KStream will handle real-time records. these realtime record may be new record or exist in GlobalKTable. The challenge is that I can't access the Kafka headers in the GlobalKTable configuration. Here's a summary of my setup:</p>\n<p>Two configuration classes: one for GlobalKTable and one for KStream.\nI need to initialize KStream after GlobalKTable is fully loaded.\nHereâ€™s the GlobalKTableConfig class where I want to access the headers:</p>\n<pre><code>@Bean(name = &quot;createGlobalKTable&quot;)\npublic GlobalKTable&lt;String, GenericRecord&gt; createGlobalKTable(@Qualifier(&quot;globalKTableStreamsBuilder&quot;) StreamsBuilderFactoryBean globalKTableStreamsBuilderFactoryBean) throws Exception {\n    StreamsBuilder streamsBuilder = globalKTableStreamsBuilderFactoryBean.getObject();\n    Map&lt;String, String&gt; serdeConfig = new HashMap&lt;&gt;();\n    serdeConfig.put(&quot;schema.registry.url&quot;, schemaRegistryUrl);\n    serdeConfig.put(&quot;schema.registry.basic.auth.user.info&quot;, basicAuthUserInfo);\n    serdeConfig.put(&quot;schema.registry.basic.auth.credentials.source&quot;, basicAuthCredentialsSource);\n\n    final Serde&lt;GenericRecord&gt; valueGenericAvroSerde = new GenericAvroSerde();\n    valueGenericAvroSerde.configure(serdeConfig, false);\n\n    return streamsBuilder.globalTable(ediLegTopic,\n         Materialized.&lt;String, GenericRecord, KeyValueStore&lt;Bytes, byte[]&gt;&gt;as(storeName + &quot;-global&quot;)\n             .withKeySerde(Serdes.String())\n             .withValueSerde(valueGenericAvroSerde));\n\n}\n</code></pre>\n<p>an this is KstreamConfig Class:</p>\n<pre><code>    @Bean\n    public StreamsBuilderFactoryBean kStreamBuilder(\n        @Qualifier(&quot;kafkaStreamsConfig&quot;) KafkaStreamsConfiguration config,\n        GlobalKTableService globalKTableService) {\n        StreamsBuilderFactoryBean factoryBean = new StreamsBuilderFactoryBean(config, new CleanupConfig(false, false));\n        factoryBean.setKafkaStreamsCustomizer(kafkaStreams -&gt; {\n            kafkaStreams.setStateListener((newState, oldState) -&gt; {\n                log.info(&quot;State changed from &quot; + oldState + &quot; to &quot; + newState);\n                if (newState == KafkaStreams.State.RUNNING) {\n                    KeyValueIterator&lt;String, GenericRecord&gt; keyValueIterator = globalKTableService.getAllValuesFromGlobalKTable();\n                   // process each record regarding the logic\n                }\n            });\n        });\n        return factoryBean;\n    }\n\n    @Bean\n    public KStream&lt;String, GenericRecord&gt; createKStream(\n        @Qualifier(&quot;kStreamBuilder&quot;) StreamsBuilderFactoryBean kStreamsBuilderFactoryBean) throws Exception {\n        StreamsBuilder kStreamBuilder = kStreamsBuilderFactoryBean.getObject();\n\n        Map&lt;String, String&gt; serdeConfig = new HashMap&lt;&gt;();\n        serdeConfig.put(&quot;schema.registry.url&quot;, schemaRegistryUrl);\n        serdeConfig.put(&quot;schema.registry.basic.auth.user.info&quot;, basicAuthUserInfo);\n        serdeConfig.put(&quot;schema.registry.basic.auth.credentials.source&quot;, basicAuthCredentialsSource);\n\n        final Serde&lt;GenericRecord&gt; valueGenericAvroSerde = new GenericAvroSerde();\n        valueGenericAvroSerde.configure(serdeConfig, false);\n        KStream&lt;String, GenericRecord&gt; kStream = kStreamBuilder.stream(ediLegTopic, Consumed.with(Serdes.String(), valueGenericAvroSerde));\n\n        StoreBuilder&lt;KeyValueStore&lt;String, GenericRecord&gt;&gt; storeBuilder = Stores.keyValueStoreBuilder(\n            Stores.persistentKeyValueStore(storeName + &quot;-global&quot;),\n            Serdes.String(),\n            valueGenericAvroSerde\n        );\n        kStreamBuilder.addStateStore(storeBuilder);\n\n        KStream&lt;String, GenericRecord&gt; processedStream = kStream.process(() -&gt; new CustomProcessor(globalKTableService, logicProvider), storeName + &quot;-global&quot;);\n        return processedStream;\n    }\n}\n</code></pre>\n<p>I have a processor to apply the logic for each realtime record:</p>\n<pre><code>\npublic class CustomProcessor implements Processor&lt;String, GenericRecord, String, GenericRecord&gt; {\n    private ProcessorContext&lt;String, GenericRecord&gt; context;\n    private final GlobalKTableService globalKTableService;\n    private final LogicProvider logicProvider;\n\n    public CustomProcessor(GlobalKTableService globalKTableService, LogicProvider logicProvider) {\n        this.globalKTableService = globalKTableService;\n        this.logicProvider= logicProvider;\n    }\n    @Override\n    public void init(ProcessorContext&lt;String, GenericRecord&gt; context) {\n        this.context = context;\n    }\n\n    @Override\n    public void process(Record&lt;String, GenericRecord&gt; processingRecord) {\n        String key = processingRecord.key();\n        GenericRecord value = processingRecord.value();\n        Headers headers = processingRecord.headers();\n\n        GenericRecord globalTableValue = globalKTableService.getValueFromGlobalKTable(key);\n\n        if ((!value.equals(globalTableValue))) {\n            log.info(&quot;No match in GlobalKTable. Forwarding stream record with key: {}&quot;, key);\n            logicProvider.applyLogic(new KeyValue&lt;&gt;(key, value), headers);\n            context.forward(processingRecord.withValue(value));\n        } else {\n            log.info(&quot;Match found in GlobalKTable for key: {}. Skipping forward.&quot;, key);\n        }\n    }\n\n    @Override\n    public void close() {\n        log.info(&quot;Closing CustomProcessor&quot;);\n    }\n}\n</code></pre>\n<p>How can I access the Kafka headers in the GlobalKTable configuration?\nThis link <a href=\"https://stackoverflow.com/questions/66661673/kafka-streams-globalktable-and-accessing-the-record-headers/79089739#79089739\">Kafka Streams GlobalKTable and accessing the record headers</a> has a related topic, but I cannot understand what does it mean.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}