{
  "question": {
    "tags": [
      "java",
      "rate-limiting",
      "thread-synchronization",
      "concurrentmodification"
    ],
    "owner": {
      "account_id": 30790092,
      "reputation": 1,
      "user_id": 23616786,
      "user_type": "registered",
      "profile_image": "https://lh3.googleusercontent.com/a/ACg8ocL39hgihacXZk0jekxESjkZFydzPO8w_r5YjP-SCklcsR6S=k-s256",
      "display_name": "Ruhan",
      "link": "https://stackoverflow.com/users/23616786/ruhan"
    },
    "is_answered": true,
    "view_count": 94,
    "accepted_answer_id": 78479054,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1715699776,
    "creation_date": 1710436390,
    "last_edit_date": 1710441387,
    "question_id": 78162292,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78162292/rate-limitter-created-on-bucket-token-algorithm-gives-incorrect-total-requests-c",
    "title": "Rate Limitter created on Bucket Token Algorithm gives incorrect total requests consumes value when tested with Multiple Threads",
    "body": "<p>I have created a bucket token based rate limitter in Java and tested it with a single thread and a multi thread approach using Executor Service. When I run with a single thread I get 200 as total requests consumed when I set 20 requests per second as the rate. Same config when I try to run with an multi threaded approach using executors I get 220 as the total requests consumed even though I have used synchronized keyword. I run both the approaches for a total of 10s.</p>\n<p>Please find the two classes below:</p>\n<p>BucketToken.class</p>\n<pre><code>package algo.interviewquestions;\n\npublic class BucketToken {\n    private Integer maxBucketSize;\n    private Integer tokensAvailable;\n    private Long refillBucketRate;\n    private Long nextRefillTime;\n    private Long totalRequestsReceived;\n    private Long totalRequestsConsumed;\n    private Integer bucketRefillCount;\n\n    public BucketToken(Integer maxBucketSize, Long refillBucketRate) {\n        this.maxBucketSize = maxBucketSize;\n        this.refillBucketRate = refillBucketRate;\n        this.nextRefillTime = System.currentTimeMillis() + refillBucketRate;\n        this.tokensAvailable = maxBucketSize;\n        this.totalRequestsReceived = 0L;\n        this.totalRequestsConsumed = 0L;\n        this.bucketRefillCount = 0;\n        refill();\n    }\n\n    public Long getTotalRequestsConsumed() {\n        return totalRequestsConsumed;\n    }\n\n    public Integer getTokensAvailable() {\n        return tokensAvailable;\n    }\n\n    public Integer getBucketRefillCount() {\n        return bucketRefillCount;\n    }\n\n    public Long getTotalRequestsReceived() {\n        return totalRequestsReceived;\n    }\n\n     public synchronized boolean tryConsume() {\n        totalRequestsReceived++;\n        refill();\n        if (this.tokensAvailable &gt; 0) {\n            this.tokensAvailable --;\n            this.totalRequestsConsumed++;\n            return true;\n        }\n        return false;\n    }\n\n    private synchronized void refill() {\n        if (System.currentTimeMillis() &lt; this.nextRefillTime) {\n            return;\n        }\n        this.nextRefillTime = System.currentTimeMillis() + this.refillBucketRate;\n        this.tokensAvailable = Math.max(this.maxBucketSize, this.tokensAvailable);\n        this.bucketRefillCount++;\n    }\n\n}\n\n</code></pre>\n<p>BucketTokenTest.class</p>\n<pre><code>package algo.interviewquestions;\n\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.IntStream;\n\npublic class BucketTokenTest {\n    public static void main(String[] args) throws InterruptedException {\n        BucketToken bucketToken = new BucketToken(20, 1000L);\n        AtomicInteger totalRequestsConsumed1 = runInMultiThreadedApproach(bucketToken);\n\n        BucketToken bucketToken2 = new BucketToken(20, 1000L);\n        AtomicInteger totalRequestsConsumed2 = runWithSingleThread(bucketToken2);\n\n        printRequestsStats(bucketToken, totalRequestsConsumed1);\n        printRequestsStats(bucketToken2, totalRequestsConsumed2);\n    }\n\n    private static AtomicInteger runWithSingleThread(BucketToken bucketToken) {\n        AtomicInteger totalRequestsConsumed = new AtomicInteger(0);\n        long startTime = System.currentTimeMillis();\n        while (System.currentTimeMillis() - startTime &lt; 10000L) {\n            if (bucketToken.tryConsume()) {\n                totalRequestsConsumed.incrementAndGet();\n                System.out.println(Thread.currentThread().getName() + &quot; - Request Accepted&quot;);\n                continue;\n            }\n            System.out.println(Thread.currentThread().getName() + &quot; - Request Declined&quot;);\n        }\n        return totalRequestsConsumed;\n    }\n\n    private static void printRequestsStats(BucketToken bucketToken, AtomicInteger totalRequestsConsumed) {\n        System.out.println(&quot;Total Requests Received = &quot; + bucketToken.getTotalRequestsReceived());\n        System.out.println(&quot;Total Requests Accepted = &quot; + totalRequestsConsumed.get());\n        System.out.println(&quot;Total Requests Accepted = &quot; + bucketToken.getTotalRequestsConsumed());\n        System.out.println(&quot;Bucket refill count = &quot; + bucketToken.getBucketRefillCount());\n    }\n\n    private static AtomicInteger runInMultiThreadedApproach(BucketToken bucketToken) throws InterruptedException {\n        int threadCount = 5;\n        ExecutorService executorService = Executors.newFixedThreadPool(threadCount);\n        AtomicInteger totalRequestsConsumed = new AtomicInteger(0);\n        long startTime = System.currentTimeMillis();\n        CountDownLatch latch = new CountDownLatch(threadCount);\n        IntStream.rangeClosed(1,threadCount).boxed().forEach(t -&gt; executorService.submit(() -&gt; {\n            while (System.currentTimeMillis() - startTime &lt; 10000L) {\n                if (bucketToken.tryConsume()) {\n                    totalRequestsConsumed.incrementAndGet();\n                    System.out.println(Thread.currentThread().getName() + &quot; - Request Accepted&quot;);\n                    continue;\n                }\n                System.out.println(Thread.currentThread().getName() + &quot; - Request Declined&quot;);\n            }\n            latch.countDown();\n        }));\n        long startTime2 = System.currentTimeMillis();\n        latch.await();\n        System.out.println(&quot;Completed in &quot; + (System.currentTimeMillis() - startTime2) + &quot;ms&quot;);\n        executorService.shutdown();\n        return totalRequestsConsumed;\n    }\n}\n\n</code></pre>\n<p>Can someone tell me what change I need to do for handling the concurrent modification or is there something I am missing?</p>\n<p>I expect both the approaches single thread and multi-thread to give the same request consumed count in 10s which is 200.</p>\n<p>I tried using synchronized keyword on the methods where modification is done but still I am seeing different values.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}