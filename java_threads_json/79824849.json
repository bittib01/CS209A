{
  "question": {
    "tags": [
      "java",
      "checker-framework"
    ],
    "owner": {
      "account_id": 357456,
      "reputation": 111,
      "user_id": 697635,
      "user_type": "registered",
      "accept_rate": 50,
      "profile_image": "https://www.gravatar.com/avatar/0e5a7ca295e5822a87131b0a966c7482?s=256&d=identicon&r=PG",
      "display_name": "fritz",
      "link": "https://stackoverflow.com/users/697635/fritz"
    },
    "is_answered": true,
    "view_count": 53,
    "answer_count": 5,
    "score": 0,
    "last_activity_date": 1763647642,
    "creation_date": 1763579613,
    "question_id": 79824849,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79824849/using-checkerframework-or-something-else-for-detecting-easily-swappable-parame",
    "title": "Using CheckerFramework (or something else) for detecting easily-swappable-parameters on methods?",
    "body": "<p>I'm having a method that accepts, for example, two long primitives. How can I add checks to prevent the accidental swapping of parameters?</p>\n<p>Something like this should be detected.</p>\n<pre><code>    public void startSomethingElse(@AccountIdParam long accountId, @BalanceParam long balance) {\n        System.out.println(&quot;Account &quot; + accountId + &quot; balance &quot; + balance);\n    }\n\n    public void startOfSomething() {\n        @AccountIdParam long accountId = 1;\n        @BalanceParam long balance = 100;\n        startSomethingElse(balance, accountId);\n    }\n</code></pre>\n<p>Using CheckerFramework, I could create custom qualifiers like this:</p>\n<pre><code>@SubtypeOf({})\n@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\npublic @interface AccountIdParam {}\n\n@SubtypeOf({})\n@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\npublic @interface BalanceParam {}\n</code></pre>\n<p>But that won't work without creating hierarchy so I need to do something like this which also wouldn't work because of two leaf nodes:</p>\n<pre><code>@SubtypeOf({Unqualified.class})\n@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\npublic @interface AccountIdParam {}\n\n@SubtypeOf({Unqualified.class})\n@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\npublic @interface BalanceParam {}\n\n@DefaultQualifierInHierarchy\n@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\n@SubtypeOf({})\npublic @interface Unqualified {}\n</code></pre>\n<p>How would you do it?</p>\n<p>Couple of constraints:</p>\n<ul>\n<li><p>I need to use primitives so subclassing Java objects isn't a option.</p>\n</li>\n<li><p>I need to have compile time check, not run time.</p>\n</li>\n</ul>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}