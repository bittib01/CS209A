{
  "question": {
    "tags": [
      "java",
      "angular",
      "spring",
      "spring-boot",
      "websocket"
    ],
    "owner": {
      "account_id": 37858243,
      "reputation": 9,
      "user_id": 28464256,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/77287db9e383e3db14108d5a323a9cab?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Abas jama",
      "link": "https://stackoverflow.com/users/28464256/abas-jama"
    },
    "is_answered": false,
    "view_count": 180,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1752143600,
    "creation_date": 1740436701,
    "last_edit_date": 1740437642,
    "question_id": 79464970,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79464970/403-forbidden-using-websockets-with-spring-boot",
    "title": "403 forbidden using websockets with spring boot",
    "body": "<p>I have spring security with JWT implemented in my application and was trying to set up the WebSocket connection. Initially I was sending the token in the headers of the WebSocket connection with the stomp client, however I realized that spring security seems to handle authentication differently compared to HTTP requests.I then tried to test to see if I was able to get a connection up and running as I set permit All on the WebSocket connection endpoint in the filter chain, having done this I still get a 403 forbidden error. Currently if my spring security filter chain permits the handshake connection the connection should be successful considering I already set up spring security CORS configuration to accept my client as the origin. If I were to ensure WebSocket connections are permitted to users but the sending of messages requires authentication, would it  mean I need to implement a custom message interceptor to validate my token for each message or can i just extend the AbstractSecurity WebSocketMessageBroker Configurer and ensure all endpoints with /app** are authenticated.</p>\n<p>How would I authenticate  subsequent requests under the STOMP protocol? Considering the Initial WebSocket connection is sent with under a HTTP protocol, even if I was to include the Authorization header then shouldn't it automatically be used by my JWT filter?</p>\n<p>from the little documentation out there, what I've gathered is that if you include the token during the WebSocket handshake then because its under a HTTP protocol, your server will be able to validate the token. This would then set up the principal such that you can now set up subsequent messages to be authenticated by implementing the configureInbound method. However if I permit the handshake to not require authentication then I would need to implement a custom message interceptor that extracts the token from the send function on the the client side. something like</p>\n<p>this.stompClient.send(&quot;/app/chat/send&quot;, {&quot;Authorization&quot; : &quot;Bearer &quot; + this.token}, JSON.stringify(message))</p>\n<p>Below is all the code</p>\n<pre class=\"lang-java prettyprint-override\"><code>\n\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.messaging.simp.config.MessageBrokerRegistry;\nimport org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;\nimport org.springframework.web.socket.config.annotation.StompEndpointRegistry;\nimport org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;\n@Configuration\n@EnableWebSocketMessageBroker\npublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer {\n\n     /// this method initiates the web socket connection, when a client wants to upgrade their\n    /// protocol from HTTP to WebSocket\n        /// . we also define the servers that can make initiate a websocket connection\n    @Override\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\n\n        registry.addEndpoint(&quot;/ws&quot;)\n                .setAllowedOriginPatterns(&quot;http://localhost:49322&quot;)\n                .withSockJS();\n    }\n\n    /// we define the prefix of the placeholder in the url as 'app' in which this will be binded to the\n    /// MessageMapping annotation methods, similar to how requestMapping routed the endpoint to the specific method\n    /// the message broker is used to define the endpoint in which a user will be subscribed to\n    /// we set the user as the prefix\n    ///\n    @Override\n    public void configureMessageBroker(MessageBrokerRegistry registry) {\n        registry.enableSimpleBroker(&quot;/user&quot;);\n        registry.setApplicationDestinationPrefixes(&quot;/app&quot;);\n    }\n}\n\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>\npackage com.example.Dormly.websocket;\n\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.messaging.handler.annotation.MessageMapping;\nimport org.springframework.messaging.handler.annotation.Payload;\nimport org.springframework.messaging.simp.SimpMessagingTemplate;\nimport org.springframework.security.core.annotation.AuthenticationPrincipal;\nimport org.springframework.security.core.userdetails.UserDetails;\n\n@org.springframework.stereotype.Controller\n@RequiredArgsConstructor\npublic class Controller {\n\n    private final SimpMessagingTemplate simpMessagingTemplate;\n    ///\n    /// The @MessageMapping is used to route all /app/placeholder destinations to their specific methods\n    /// we use the principal to define the user who is the sender, and via a UI action\n    /// we also include recipient to define who the end user is\n    /// we create an output message object which contains a sender and the content\n    /// we then send this output message to the user\n    /// The message object just has the recipient(to whom we send to) and the content, the sender is fetched from the principal\n    @MessageMapping(&quot;/chat/send&quot;)\n    public void sendMessage(@Payload  Message message , @AuthenticationPrincipal UserDetails user){\n        OutputMessage outputMessage = new OutputMessage(\n                message.getContent(),\n                user.getUsername() /// user who sent the message - the recipient will see this\n        );\n        /// the server will send back something like '/user/james/queue/chat'\n        simpMessagingTemplate.convertAndSendToUser(message.getRecipient(),&quot;/queue/chat&quot;, outputMessage);\n\n\n    }\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>\n@Configuration\n@EnableWebSecurity\n@RequiredArgsConstructor\npublic class SecurityConfiguration {\n\n    private final AuthenticationProvider authenticationProvider;\n    private final JwtAuthFilter jwtAuthFilter;\n\n\n    /**\n     * Configuration annotation tells spring that there is more than one bean that needs to be instantiated as a singleton\n     * SecurityFilterChain applies a set of filters to our HTTP requests.\n     */\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {\n        httpSecurity.\n        cors(Customizer.withDefaults())\n                .csrf(AbstractHttpConfigurer::disable)\n                .authorizeHttpRequests(http-&gt;http.\n                        requestMatchers(&quot;/api/v1/Sign-up&quot;).permitAll()\n                        .requestMatchers(&quot;/api/v1/login&quot;).permitAll()\n                        .requestMatchers(&quot;/ws**&quot;).permitAll()\n                        .anyRequest()\n                        .authenticated()\n                )\n        /**\n         * ensure our session management remains stateless, as we authenticate once per request\n         */\n\n                        .sessionManagement(session-&gt; session\n                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n\n                )\n                /**\n                 * when spring security intercepts the login request, the usernamepasswordfilter delegates\n                 * this to the auth manager in which that uses the provider manager impl to find the auth provider.\n                 * The auth provider is called to validate the credentials as it receives an auth object\n                 * Also ensure the jwt filter gets called before the usernamepass filter\n                 * as we always need to check if a JWT is present, if not the request is passed to other filters\n                 * This way we handle requests for unauthenticated and authenticated users\n                 * not authenticated(meaning no jwt) -&gt; UsernamePassFilter gets used\n                 * authenticated(has Jwt) -&gt; jwtAuthFilter\n                 */\n\n                .authenticationProvider(authenticationProvider)\n                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);\n\n                return httpSecurity.build();\n\n\n    }\n</code></pre>\n<pre class=\"lang-js prettyprint-override\"><code>\nimport { Injectable } from '@angular/core';\nimport { TokenService } from '../auth/token/token.service';\nimport SockJS from 'sockjs-client';\nimport { Stomp } from '@stomp/stompjs';\nimport { Message } from '../models/Message';\nimport { MessagesComponent } from '../messages/messages.component';\nimport { BehaviorSubject } from 'rxjs';\n\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class WebSocketApiService {\n  //create a subject to communicate the responses back to the messages component\n  private subject = new BehaviorSubject(null)\n  messageSubscription$ = this.subject.asObservable()\n\n\n  destination:string = &quot;/user/queue/chat&quot;\n  brokerURL:string = &quot;http://localhost:8099/ws&quot;\n  stompClient:any\n  token!:string\n\n  constructor(private tokenService:TokenService) {\n    this.token = this.tokenService.token as string\n  }\n  connect(){\n    console.log(&quot;connecting to websocket...&quot;)\n    const headers = { &quot;Authorization&quot;: &quot;Bearer &quot; + this.token };\n    console.log(&quot;WebSocket headers:&quot;, headers); // Log the headers\n\n    let ws = new SockJS(this.brokerURL)\n    this.stompClient = Stomp.over(ws)\n    this.stompClient.connect({&quot;Authorization&quot; : `Bearer ${this.token}`}, () =&gt;{\n      console.log(&quot;WebSocket connected&quot;);\n\n        ///the stompclient takes 3 parameters which includes the headers and 2 callback functions,\n        ///the frames defined the handshake agreement of protocol switches, and once the event occurs we can now subscribe to the destination\n\n        this.stompClient.subscribe(this.destination, (message:any)=&gt;{\n          //the subscribe also triggers a callback which means when a user subscribes to a destination, an event of a message could be returned\n          this.onMessageRecieved(message)\n\n        })\n\n    },\n    ///error callback\n    (error:Error | any)=&gt;{\n    this.errorCallBack(error)\n    }\n  )\n\n\n\n  }\n  errorCallBack(error:Error):void{\n    console.log(error.message)\n    \n  }\n\n  disconnect(){\n    if(this.stompClient!==null){\n      this.stompClient.disconnect()\n      console.log(&quot;disconnected&quot;)\n    }\n    setTimeout(()=&gt;{\n      this.connect()\n    },\n    5000) //reconnect after 5 seconds\n    \n  }\n\n\n  onMessageRecieved(message:any) {\n    if(message){\n    ///manual deserialization with websockets. using Json.parse() to convert the json into a javascript objecy\n    console.log(&quot;message recieved &quot;, message)\n    this.subject.next(JSON.parse(message))\n    console.log(&quot;added message to the subject&quot;)\n    }\n \n\n  }\n\n\n  send(message:Message):void{\n    ///when the user sends a message, our in memory message broker in spring will automatically forward it to the destination the user is subscribed to\n    ///the user will recieve the message immediatley assuming the connection is still live - if not we persist the chat to the db\n    ///all messages are sent with the /app prefix and users are able to send messages\n    ///the message object includes the recieptent and the message itself.\n    ///websocket does not serialize the object into a json like HTTP does, hence we do it manually\n    this.stompClient.send(&quot;/app/chat/send&quot;, {&quot;Authorization&quot; : &quot;Bearer &quot; + this.token}, JSON.stringify(message))\n  }\n\n\n}\n</code></pre>\n<p>This is what shows up in the console in order</p>\n<p>[Log] calling service class to connect to websocket (main.js, line 2372)</p>\n<p>[Log] connecting to websocket... (main.js, line 2275)\n[Warning] Stomp.over did not receive a factory, auto reconnect will not work. Please see <a href=\"https://stomp-js.github.io/api-\" rel=\"nofollow noreferrer\">https://stomp-js.github.io/api-</a>\ndocs/latest/classes/Stomp.html#over (@stomp_stompjs.js, line 1534)</p>\n<p>[Log] Opening Web Socket... (@stomp_stompjs.js, line 1286)\n[Debug] [vite] connected. (client, line 859)</p>\n<p>[Error] Failed to load resource: the server responded with a status of 403 () (info, line 0)</p>\n<p>[Log] Connection closed to http://localhost:8099/ws (@stomp_stompjs.js, line 1286)</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}