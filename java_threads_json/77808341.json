{
  "question": {
    "tags": [
      "java",
      "algorithm",
      "optimization",
      "dynamic-programming",
      "lcs"
    ],
    "owner": {
      "account_id": 14713952,
      "reputation": 1,
      "user_id": 14183715,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/c2653f0418e0736b5393c64eded0849a?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Arunabh",
      "link": "https://stackoverflow.com/users/14183715/arunabh"
    },
    "is_answered": true,
    "view_count": 562,
    "accepted_answer_id": 78027594,
    "answer_count": 1,
    "score": -6,
    "last_activity_date": 1710842148,
    "creation_date": 1705080566,
    "last_edit_date": 1708691324,
    "question_id": 77808341,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/77808341/how-can-i-optimize-the-algorithm-to-find-the-longest-common-subsequence-lcs-be",
    "title": "How can I optimize the algorithm to find the longest common subsequence (LCS) between two strings?",
    "body": "<p>An algorithm used to efficiently find the LCS between two strings:</p>\n<ol>\n<li>Define two strings, string1 and string2, with lengths m and n, respectively.</li>\n<li>Create a 2D array, dp, with dimensions (m+1) x (n+1). Initialize all the elements of dp to 0.</li>\n<li>Iterate over the characters of string1 from left to right (i) and string2 from top to bottom (j).</li>\n<li>If string1[i] is equal to string2[j], increment dp[i+1][j+1] by 1. This means the current characters match, and the length of the LCS ending at this point is one more than the LCS ending at the previous characters.</li>\n<li>If string1[i] is not equal to string2[j], take the maximum value between dp[i][j+1] and dp[i+1][j] and store it in dp[i+1][j+1]. This means the current characters do not match, so the length of the LCS ending at this point is the maximum of the LCS ending at the previous characters in either string1 or string2.</li>\n<li>After iterating over all characters, the value of dp[m][n] will be the length of the LCS between string1 and string2.</li>\n<li>To retrieve the actual LCS, start from dp[m][n] and backtrack through the dp array. If string1[i-1] is equal to string2[j-1], add the character to the LCS and move diagonally to dp[i-1][j-1]. Otherwise, move to the left if dp[i][j-1] is greater than dp[i-1][j], or move upward if dp[i-1][j] is greater.</li>\n<li>Repeat step 7 until reaching the top-left corner of the dp array.</li>\n</ol>\n<p>By following this algorithm, the longest common subsequence between two strings can be found in programming.</p>\n<p>An example of Java code:</p>\n<pre><code>public static String repeatCharacter(char ch, int length) {\n    StringBuilder sb = new StringBuilder(length);\n    for (int i = 0; i &lt; length; i++) {\n        sb.append(ch);\n    }\n    return sb.toString();\n}\n\nScanner myObj = new Scanner(System.in);\nchar ch = 'X';\n\nSystem.out.println(&quot;Enter size of first string&quot;);\nint m = myObj.next();\nString string1 = repeatCharacter(ch, m);\nSystem.out.println(&quot;Enter size of first string&quot;);\nint m = myObj.next()\nString string2 = repeatCharacter(ch, n);\nString lcs = &quot;&quot;;\n\nSystem.out.println(&quot;Enter first string&quot;);\nstring1 = myObj.nextLine(); \nSystem.out.println(&quot;Enter second string&quot;);\nstring1 = myObj.nextLine(); \nint dp[m+1][n+1];\nint i, j;\n\nfor (i = 0; i &lt; m + 1; i++) {\n     for (j = 0; j &lt; n + 1; j++) {\n          dp[i][j] = 0;\n     }\n}\n\nfor (i = 0; i &lt; m; i++) {\n     for (j = 0; j &lt; n; j++) {\n          if (string1[i] = string2[j])\n              dp[i+1][j+1]++;\n          else\n              dp[i+1][j+1] = Math.max(dp[i][j+1], dp[i+1][j]);\n     }\n}\n\ni = m, j = n;\nwhile (i &gt; -1 &amp;&amp; j &gt; -1) {\n    if (string1[i-1] = string2[j-1]) {\n        lcs = lcs + string1[i-1];\n        i--;\n        j--;\n    }\n    else if (dp[i][j-1] &gt; dp[i-1][j])\n        i--;\n    else\n        j--;\n}\n</code></pre>\n<p>However, using nested for loops can take O(m n) in both time and space.</p>\n<p>How can I optimize the time complexity and the space complexity of this algorithm?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}