{
  "question": {
    "tags": [
      "java",
      "iterator"
    ],
    "owner": {
      "account_id": 6710967,
      "reputation": 18061,
      "user_id": 5174436,
      "user_type": "registered",
      "accept_rate": 50,
      "profile_image": "https://i.sstatic.net/2ox6D.jpg?s=256",
      "display_name": "Matthew McPeak",
      "link": "https://stackoverflow.com/users/5174436/matthew-mcpeak"
    },
    "is_answered": false,
    "view_count": 97,
    "answer_count": 4,
    "score": 0,
    "last_activity_date": 1762868978,
    "creation_date": 1762822680,
    "question_id": 79816153,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79816153/iterating-over-several-nested-iterators",
    "title": "Iterating over several nested iterators",
    "body": "<p>I have to implement an Iterator&lt;E&gt; that needs to internally iterate through multiple private iterators at different levels.  For example, an Iterator&lt;A&gt;, an Iterator&lt;B&gt;, and an Iterator&lt;C&gt;.  The Iterator&lt;A&gt; exists for the life of my Iterator, but the Iterator&lt;B&gt; and Iterator&lt;C&gt; instances are made from the current values for A and B, respectively.</p>\n<p>At any given iteration, the Iterator&lt;C&gt; might be exhausted and so I'll have to advance to the next() of Iterator&lt;B&gt;, from which I will establish a new Iterator&lt;C&gt;.  I hope this is clear.</p>\n<p><strong>My question is: is there any better structure than this (below)?</strong>  My real case has 5-6 levels of nested iterators and I'm finding this ugly and unsatisfying.</p>\n<pre><code>if ( this.cIterator == null || ! this.cIterator.hasNext() ) {\n    // We do not have a C iterator established, or the one we had established is exhausted\n    // We need a new one, which will come from the next B\n    if ( this.bIterator = null || !this.bIterator.hasNext() ) {\n        // We do not have a B iterator established or the one we had is exhausted.\n        // We need a new one, which will come from the next A\n        if ( this.aIterator == null || !this.aIterator.hasNext() ) {\n            // Our aIterator is non-existent or exhausted.  We are done.\n            throw new NoSuchElementException();\n    }\n        // At this point, we can move on to the next A.\n        this.currentA = this.aIterator.next();\n        this.bIterator = this.currentA.getIteratorSourceCollection().iterator();\n        // assert this.bIterator.hasNext(); // will be true in my case\n    }\n    // At this point, we are guaranteed to have a B iterator with at least one element left\n    this.currentB = bIterator.next();\n    this.cIterator = this.currentB.getIteratorSourceCollection().iterator();\n    // assert this.cIterator.hasNext();  // will be true in my case\n}\n// At this point, we are guaranteed to have a C iterator with a next element.\nreturn new E(this.currentA, this.currentB, this.cIterator.next());\n             \n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}