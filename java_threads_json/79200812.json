{
  "question": {
    "tags": [
      "java",
      "android",
      "kotlin",
      "permissions",
      "android-camera"
    ],
    "owner": {
      "account_id": 2339965,
      "reputation": 13,
      "user_id": 2051485,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/ece915e17e328bfd1c4b299fb0542f7f?s=256&d=identicon&r=PG",
      "display_name": "FranciscoRincon",
      "link": "https://stackoverflow.com/users/2051485/franciscorincon"
    },
    "is_answered": false,
    "view_count": 102,
    "answer_count": 0,
    "score": 0,
    "last_activity_date": 1732310519,
    "creation_date": 1731949904,
    "last_edit_date": 1732310519,
    "question_id": 79200812,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79200812/how-can-i-automate-video-recording-duration-and-frequency-in-kotlin-update-n",
    "title": "How can I automate video recording duration (and frequency) in Kotlin? [UPDATE Nov 22 -2024] Now permissions",
    "body": "<p>I have been working on an app used for video recording of sparring rounds (in boxing). On a more fundamental basis, it should be a loop that records automatically for as long (in minutes) and as many times (rounds) as the user inputs. Right now this is a proof-of-concept;</p>\n<p>So far, I have been able to access the user's camera, but I cannot figure out how to set the auto-recording or make the loop work. I am wondering if I am accessing the camera properly or if I need to make changes, or if this can even be done in Kotlin.</p>\n<p>There are three variables that the user inputs:</p>\n<ul>\n<li>numberOfRounds, integer</li>\n<li>lenghtOfRounds, integer</li>\n<li>breakRounds, integer</li>\n</ul>\n<p>Here is my code:</p>\n<pre><code>private fun startRecordingLoop() {\n    val handler = Handler(Looper.getMainLooper())\n    var currentRound = 1\n\n    fun recordRound() {\n        if (currentRound &lt;= numberOfRounds) {\n            Toast.makeText(this, &quot;Recording round $currentRound&quot;, Toast.LENGTH_SHORT).show()\n            startRecording()\n\n            handler.postDelayed({\n                stopRecording()\n                Toast.makeText(this, &quot;Break round $currentRound&quot;, Toast.LENGTH_SHORT).show()\n                currentRound++\n\n                handler.postDelayed({ recordRound() }, breakRounds * 60 * 1000L)\n            }, lengthOfRound * 60 * 1000L)\n        } else {\n            Toast.makeText(this, &quot;All rounds completed&quot;, Toast.LENGTH_SHORT).show()\n        }\n    }\n\n    recordRound()\n}\n\nprivate fun startRecording() {\n    try {\n        if (!::mediaRecorder.isInitialized) {\n            mediaRecorder = MediaRecorder()\n        }\n</code></pre>\n<p>These are the projects imports:</p>\n<pre><code>import android.Manifest\nimport android.content.pm.PackageManager\nimport android.media.MediaRecorder\nimport android.os.Bundle\nimport android.os.Environment\nimport android.os.Handler\nimport android.os.Looper\nimport android.util.Log\nimport android.widget.Button\nimport android.widget.EditText\nimport android.widget.Toast\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.core.app.ActivityCompat\nimport androidx.core.content.ContextCompat\nimport java.io.File\n</code></pre>\n<p>This is the code for the AndroidManifest.xml:</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;\n    &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;\n    &lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;false&quot; /&gt;\n    &lt;uses-feature android:name=&quot;android.hardware.camera.autofocus&quot; android:required=&quot;false&quot; /&gt;\n</code></pre>\n<p>[UPDATE 11/22/2024]</p>\n<p>I have updated how to access the camera (thanks Tyler!) and now there are no more deprecation problems. I made modifications to the recording loop to access the camera and I have reached the point where the camera is launching, the toasts regarding the completion of the rounds -indicates that the round has started, the round has ended, and that all the rounds have been recorded-, but it is not generating any video file. What I get out of this is: the recording loop works but is flawed. It is accessing the camera but it is not saving the file. This is the loop as of right now:</p>\n<pre><code>   private fun startRecordingLoop() {\n        var currentRound = 1\n\n        fun recordRound() {\n            if (currentRound &lt;= numberOfRounds) {\n                Toast.makeText(this, &quot;Recording round $currentRound&quot;, Toast.LENGTH_SHORT).show()\n                startRecording()\n\n                textureView.postDelayed({\n                    stopRecording()\n                    Toast.makeText(this, &quot;Break round $currentRound&quot;, Toast.LENGTH_SHORT).show()\n                    currentRound++\n\n                    textureView.postDelayed({ recordRound() }, breakRounds * 60 * 1000L)\n                }, lengthOfRound * 60 * 1000L)\n            } else {\n                Toast.makeText(this, &quot;All rounds completed&quot;, Toast.LENGTH_SHORT).show()\n                showInputs()\n            }\n        }\n\n        hideInputs()\n        recordRound()\n    }\n</code></pre>\n<p>Now the app is displayed in landscape mode, and once the user hits the start recording button, the UI hides and it &quot;returns&quot; once all the rounds have been filmed. At least, that's what should do in theory.</p>\n<p>Since I believe the problem of the camera not filming is the permissions request, I have been focusing on that path, but now the code gets stuck in a loop of request permissions, but does not ask for all of them. I will report once I make improvements on that end. Below you will see the whole code of the app, kindly let me know if you see something wrong that I may have overlooked.</p>\n<p>Thank you all again for your help and kindness!!</p>\n<p>Code, last update [11/22/2024]</p>\n<pre><code>import android.Manifest\nimport android.content.pm.PackageManager\nimport android.graphics.SurfaceTexture\nimport android.hardware.camera2.*\nimport android.media.MediaRecorder\nimport android.net.Uri\nimport android.os.Bundle\nimport android.os.Environment\nimport android.provider.Settings\nimport android.util.Log\nimport android.view.Surface\nimport android.view.TextureView\nimport android.view.View\nimport android.widget.Button\nimport android.widget.EditText\nimport android.widget.LinearLayout\nimport android.widget.Toast\nimport androidx.appcompat.app.AlertDialog\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.core.app.ActivityCompat\nimport androidx.core.content.ContextCompat\nimport java.io.File\nimport android.content.Intent\n\n\n\nclass MainActivity : AppCompatActivity(), TextureView.SurfaceTextureListener {\n\n    // Variables for user inputs\n    private var numberOfRounds: Int = 0\n    private var lengthOfRound: Int = 0\n    private var breakRounds: Int = 0\n\n    // Camera and MediaRecorder variables\n    private lateinit var mediaRecorder: MediaRecorder\n    private lateinit var textureView: TextureView\n    private lateinit var cameraDevice: CameraDevice\n    private lateinit var cameraCaptureSession: CameraCaptureSession\n    private var isRecording = false\n    private var permissionAttempts = 0 // Track permission request attempts\n\n    // Permissions required for the app\n    private val REQUIRED_PERMISSIONS = arrayOf(\n        Manifest.permission.CAMERA,\n        Manifest.permission.RECORD_AUDIO,\n        Manifest.permission.WRITE_EXTERNAL_STORAGE,\n        Manifest.permission.READ_EXTERNAL_STORAGE\n    )\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        // Initialize TextureView for the camera preview\n        textureView = findViewById(R.id.textureView)\n        textureView.surfaceTextureListener = this // Register the TextureView listener\n\n        // Check and request permissions at app launch\n        if (!allPermissionsGranted()) {\n            requestPermissions()\n        } else {\n            initializeApp() // Only initialize if all permissions are already granted\n        }\n\n        // UI elements for user input\n        val roundsInput = findViewById&lt;EditText&gt;(R.id.roundsInput)\n        val lengthInput = findViewById&lt;EditText&gt;(R.id.lengthInput)\n        val breakInput = findViewById&lt;EditText&gt;(R.id.breakInput)\n        val startButton = findViewById&lt;Button&gt;(R.id.startButton)\n\n        // Start the recording loop when the button is clicked\n        startButton.setOnClickListener {\n            if (allPermissionsGranted()) {\n                // Parse input values\n                numberOfRounds = roundsInput.text.toString().toIntOrNull() ?: 0\n                lengthOfRound = lengthInput.text.toString().toIntOrNull() ?: 0\n                breakRounds = breakInput.text.toString().toIntOrNull() ?: 0\n\n                if (numberOfRounds &gt; 0 &amp;&amp; lengthOfRound &gt; 0 &amp;&amp; breakRounds &gt; 0) {\n                    startRecordingLoop() // Begin the recording loop\n                } else {\n                    Toast.makeText(this, &quot;Please enter valid input values&quot;, Toast.LENGTH_SHORT).show()\n                }\n            } else {\n                Toast.makeText(this, &quot;Permissions are required to start recording.&quot;, Toast.LENGTH_SHORT).show()\n            }\n        }\n    }\n\n    // Initialize app functionality after permissions are granted\n    private fun initializeApp() {\n        Log.d(&quot;MainActivity&quot;, &quot;App is initializing...&quot;)\n        Toast.makeText(this, &quot;App initialized successfully!&quot;, Toast.LENGTH_SHORT).show()\n    }\n\n    // Check if all required permissions are granted\n    private fun allPermissionsGranted(): Boolean {\n        val missingPermissions = REQUIRED_PERMISSIONS.filter { permission -&gt;\n            ContextCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED\n        }\n        Log.d(&quot;MainActivity&quot;, &quot;Missing permissions: $missingPermissions&quot;)\n        return missingPermissions.isEmpty()\n    }\n\n    // Request all necessary permissions\n    private fun requestPermissions() {\n        ActivityCompat.requestPermissions(this, REQUIRED_PERMISSIONS, 102)\n    }\n\n    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults)\n\n        if (requestCode == 102) {\n            val deniedPermissions = permissions.filterIndexed { index, _ -&gt;\n                grantResults[index] != PackageManager.PERMISSION_GRANTED\n            }\n\n            if (deniedPermissions.isEmpty()) {\n                Log.d(&quot;MainActivity&quot;, &quot;All permissions granted!&quot;)\n                initializeApp() // Call initializeApp only when permissions are granted\n            } else {\n                permissionAttempts++\n                if (permissionAttempts &lt; 3) {\n                    Toast.makeText(\n                        this,\n                        &quot;Permissions denied: $deniedPermissions. Grant them to continue.&quot;,\n                        Toast.LENGTH_LONG\n                    ).show()\n                    requestPermissions()\n                } else {\n                    showPermissionExplanation(deniedPermissions)\n                }\n            }\n        }\n    }\n\n    // Show a dialog explaining why permissions are needed\n    private fun showPermissionExplanation(deniedPermissions: List&lt;String&gt;) {\n        AlertDialog.Builder(this)\n            .setTitle(&quot;Permissions Required&quot;)\n            .setMessage(&quot;The app requires the following permissions to function: $deniedPermissions. Please grant them in Settings.&quot;)\n            .setPositiveButton(&quot;Go to Settings&quot;) { _, _ -&gt;\n                val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)\n                intent.data = Uri.parse(&quot;package:$packageName&quot;)\n                startActivity(intent)\n            }\n            .setNegativeButton(&quot;Exit&quot;) { _, _ -&gt;\n                finish()\n            }\n            .show()\n    }\n\n    // Loop to handle recording rounds\n    private fun startRecordingLoop() {\n        var currentRound = 1\n\n        fun recordRound() {\n            if (currentRound &lt;= numberOfRounds) {\n                Toast.makeText(this, &quot;Recording round $currentRound&quot;, Toast.LENGTH_SHORT).show()\n                startRecording()\n\n                textureView.postDelayed({\n                    stopRecording()\n                    Toast.makeText(this, &quot;Break round $currentRound&quot;, Toast.LENGTH_SHORT).show()\n                    currentRound++\n\n                    textureView.postDelayed({ recordRound() }, breakRounds * 60 * 1000L)\n                }, lengthOfRound * 60 * 1000L)\n            } else {\n                Toast.makeText(this, &quot;All rounds completed&quot;, Toast.LENGTH_SHORT).show()\n                showInputs()\n            }\n        }\n\n        hideInputs()\n        recordRound()\n    }\n\n    // Start video recording\n    private fun startRecording() {\n        try {\n            hideInputs()\n            if (!::mediaRecorder.isInitialized) {\n                mediaRecorder = MediaRecorder()\n            }\n\n            val outputFile = getOutputFile()\n            val cameraManager = getSystemService(CAMERA_SERVICE) as CameraManager\n            val cameraId = cameraManager.cameraIdList.firstOrNull {\n                cameraManager.getCameraCharacteristics(it).get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_BACK\n            } ?: throw IllegalStateException(&quot;No back-facing camera found&quot;)\n\n            mediaRecorder.apply {\n                setAudioSource(MediaRecorder.AudioSource.CAMCORDER)\n                setVideoSource(MediaRecorder.VideoSource.SURFACE)\n                setOutputFormat(MediaRecorder.OutputFormat.MPEG_4)\n                setOutputFile(outputFile.absolutePath)\n                setVideoEncoder(MediaRecorder.VideoEncoder.H264)\n                setAudioEncoder(MediaRecorder.AudioEncoder.AAC)\n                setVideoEncodingBitRate(10000000)\n                setVideoFrameRate(30)\n                setVideoSize(1920, 1080)\n                prepare()\n                start()\n            }\n            isRecording = true\n            Toast.makeText(this, &quot;Recording started&quot;, Toast.LENGTH_SHORT).show()\n        } catch (e: Exception) {\n            Log.e(&quot;MainActivity&quot;, &quot;Error starting recording: ${e.message}&quot;)\n        }\n    }\n\n    // Stop video recording\n    private fun stopRecording() {\n        try {\n            if (isRecording) {\n                mediaRecorder.stop()\n                mediaRecorder.reset()\n                isRecording = false\n                showInputs()\n                Toast.makeText(this, &quot;Recording stopped&quot;, Toast.LENGTH_SHORT).show()\n            }\n        } catch (e: Exception) {\n            Log.e(&quot;MainActivity&quot;, &quot;Error stopping recording: ${e.message}&quot;)\n        }\n    }\n\n    // Helper functions\n    private fun hideInputs() {\n        findViewById&lt;LinearLayout&gt;(R.id.inputsLayout).visibility = View.GONE\n    }\n\n    private fun showInputs() {\n        findViewById&lt;LinearLayout&gt;(R.id.inputsLayout).visibility = View.VISIBLE\n    }\n\n    private fun getOutputFile(): File {\n        val directory = getExternalFilesDir(Environment.DIRECTORY_MOVIES)\n        if (directory != null &amp;&amp; !directory.exists()) {\n            directory.mkdirs()\n        }\n        return File(directory, &quot;video_${System.currentTimeMillis()}.mp4&quot;)\n    }\n\n    // TextureView.SurfaceTextureListener methods\n    override fun onSurfaceTextureAvailable(surface: SurfaceTexture, width: Int, height: Int) {\n        try {\n            val cameraManager = getSystemService(CAMERA_SERVICE) as CameraManager\n            val cameraId = cameraManager.cameraIdList.firstOrNull {\n                cameraManager.getCameraCharacteristics(it).get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_BACK\n            } ?: throw IllegalStateException(&quot;No back-facing camera found&quot;)\n\n            if (ActivityCompat.checkSelfPermission(\n                    this,\n                    Manifest.permission.CAMERA\n                ) != PackageManager.PERMISSION_GRANTED\n            ) {\n                // Handle missing permissions\n                return\n            }\n\n            cameraManager.openCamera(cameraId, object : CameraDevice.StateCallback() {\n                override fun onOpened(camera: CameraDevice) {\n                    cameraDevice = camera\n\n                    val previewSurface = Surface(surface)\n                    val captureRequestBuilder = camera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW)\n                    captureRequestBuilder.addTarget(previewSurface)\n\n                    camera.createCaptureSession(listOf(previewSurface), object : CameraCaptureSession.StateCallback() {\n                        override fun onConfigured(session: CameraCaptureSession) {\n                            cameraCaptureSession = session\n                            session.setRepeatingRequest(captureRequestBuilder.build(), null, null)\n                        }\n\n                        override fun onConfigureFailed(session: CameraCaptureSession) {\n                            Log.e(&quot;MainActivity&quot;, &quot;Failed to configure camera session&quot;)\n                        }\n                    }, null)\n                }\n\n                override fun onDisconnected(camera: CameraDevice) {\n                    Log.e(&quot;MainActivity&quot;, &quot;Camera disconnected&quot;)\n                }\n\n                override fun onError(camera: CameraDevice, error: Int) {\n                    Log.e(&quot;MainActivity&quot;, &quot;Error opening camera: $error&quot;)\n                }\n            }, null)\n\n        } catch (e: Exception) {\n            Log.e(&quot;MainActivity&quot;, &quot;Error initializing camera preview: ${e.message}&quot;)\n        }\n    }\n\n    override fun onSurfaceTextureSizeChanged(surface: SurfaceTexture, width: Int, height: Int) {\n        // Handle size changes if necessary\n    }\n\n    override fun onSurfaceTextureDestroyed(surface: SurfaceTexture): Boolean {\n        // Close the camera when the surface is destroyed\n        cameraDevice.close()\n        return true\n    }\n\n    override fun onSurfaceTextureUpdated(surface: SurfaceTexture) {\n        // Handle texture updates if necessary\n    }\n}\n\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}