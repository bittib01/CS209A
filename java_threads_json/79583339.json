{
  "question": {
    "tags": [
      "java",
      "multithreading",
      "javafx",
      "concurrency",
      "responsive"
    ],
    "owner": {
      "account_id": 4459325,
      "reputation": 1819,
      "user_id": 3628679,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/e9630c47c1411d5cea74ae7ee083dbf4?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Alex",
      "link": "https://stackoverflow.com/users/3628679/alex"
    },
    "is_answered": true,
    "view_count": 116,
    "answer_count": 1,
    "score": 2,
    "last_activity_date": 1745215332,
    "creation_date": 1745150665,
    "question_id": 79583339,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79583339/thread-handling-when-showing-list-of-images-in-javafx-and-pause",
    "title": "Thread handling when showing list of images in JavaFX and pause",
    "body": "<p>I have a JavaFX application. One UI element on the stage is an ImageView. I want to show a sequence of exercises, each 60 seconds, to the user. Each exercise has among other attributes, an image, which shall be shown in the imageView, and a link to a wav file, with explanation text, which shall be played once the image is shown. I want the application to remain responsive, while the image is shownin case the user presses a stop button. When reducing the real complexity, between the different exercises, and during the display time of a each exercise, there are breaks (method pause). Each break shows a new dedicted stage, which counts down the break time. During a break time the current image display shall disappear and re-appear after the break finalized.</p>\n<p>The respective runImageExercise method is called on the Java Application Thread: <code>11:58:48 [DEBUG] [JavaFX Application Thread] d.l.c.MainCtrl.runImageExercise, 1226: entering  runImageExercise: Calf left</code></p>\n<p>My problem is the Thread handling combination between showing the exercise and the pause.\nIf I put a Thread.sleep(1000) into the runImageExercise method directly, the exercise image is never shown and the explanation is played only if pause is called. This is this version:</p>\n<pre><code>protected void runImageExercise(Exercise exercise) {\n\n        debugLogger.debug(&quot;V1) entering  runImageExercise: &quot; + exercise.getName());\n\n        imageView.setVisible(true);\n        exerciseLabel.setText(exercise.getName());\n        Image image = exercise.getPreviewImage();\n        imageView.setImage(image);\n        \n        Task&lt;Void&gt; exerciseSoundTask = getExerciseSoundTask(exercise);      // Play explanation wav file\n        Thread exerciseSoundThread = new Thread(exerciseSoundTask);\n        exerciseSoundThread.start();\n\n\n        currentImageDisplayTime = 0;\n        while (currentImageDisplayTime &lt; 60) {                              // show the image for 60 secs\n            currentImageDisplayTime++;\n            \n            if(currentImageDisplayTime % 30 == 0) {                        // pause every 30 secs\n                imageView.setVisible(false);\n                pause(PauseType.EXERCISE_PAUSE, exercise.getBreakBetweenSetsInSecs(), &quot;Break&quot;, exercise, false);\n                imageView.setVisible(true);\n            }\n            \n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException interrupted) {\n                break;\n            }\n        }\n\n        imageView.setVisible(false);\n\n        pause(PauseType.EXERCISE_PAUSE, exercise.getBreakBetweenSetsInSecs(), &quot;Exercise done&quot;, exercise, false);\n}\n</code></pre>\n<p>None of my attempts with Thread.join or lock and notify to synchronize the two threads worked.\nSo, if I put the Thread.sleep(1000) into a dedicated Thread, the image is shown and the explanation played, but the pause call throws <code>java.lang.IllegalStateException: Not on FX application thread;</code> Therefore I moved the pause into a Platform.runLater() block. Now the pause opens with a little delay, but the currentImageDisplayTime loop is not interrupted and continue to count down. This is this version:</p>\n<pre><code>protected void runImageExercise(Exercise exercise, List&lt;Exercise&gt; exercises, boolean switchSide) {\n        \n        debugLogger.debug(&quot;V2) entering  runImageExercise: &quot; + exercise.getName());\n\n        imageView.setVisible(true);\n        exerciseLabel.setText(exercise.getName());\n        setLabel.setText(&quot;1&quot;);\n        Image image = exercise.getPreviewImage();\n        imageView.setImage(image);\n\n\n        Task&lt;Void&gt; exerciseSoundTask = getExerciseSoundTask(exercise, switchSide);\n        Task&lt;Void&gt; imageDisplayTask = getImageDisplayTask(exercise, exercises, switchSide);\n        repLabel.textProperty().bind(imageDisplayTask.messageProperty());\n\n        Thread imageDisplayThread = new Thread(imageDisplayTask);\n        Thread exerciseSoundThread = new Thread(exerciseSoundTask);\n\n        imageDisplayThread.start();\n        exerciseSoundThread.start();\n\n        debugLogger.debug(&quot;leaving  runImageExercise: &quot;);\n    }\n</code></pre>\n<p>Here is the Task definition:</p>\n<pre><code>protected Task&lt;Void&gt; getImageDisplayTask(Exercise exercise, List&lt;Exercise&gt; exercises, boolean switchSide) {\n        Task&lt;Void&gt; imageWaitTask = new Task&lt;Void&gt;() {\n            @Override\n            protected Void call() throws Exception {\n\n                debugLogger.debug(&quot;entering imageWaitTask: &quot; + exercise.getName());\n\n                currentImageDisplayTime = 0;\n                while (currentImageDisplayTime &lt; 60) {                              // show the image for 30 secs\n                    currentImageDisplayTime++;\n                    debugLogger.debug(&quot;------------------ imageWaitTask time:&quot; + currentImageDisplayTime);\n                    \n                    if(currentImageDisplayTime % 30 == 0) {\n                        Platform.runLater(() -&gt; {\n                            imageView.setVisible(false);\n                            pause(PauseType.EXERCISE_PAUSE, exercise.getBreakBetweenSetsInSecs(), &quot;Break&quot;, exercise, false);\n                            imageView.setVisible(true);\n                        });\n                    }\n                    \n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException interrupted) {\n                        break;\n                    }\n                }\n\n                debugLogger.debug(&quot;leaving imageWaitTask&quot;);\n                return null;\n            }\n        };\n\n        imageWaitTask.setOnSucceeded(e -&gt; {\n            debugLogger.debug(&quot;imageWaitTask succeded&quot;);\n        \n            imageView.setVisible(false);\n            pause(PauseType.EXERCISE_PAUSE, exercise.getBreakBetweenSetsInSecs(), &quot;Exercise done&quot;, exercise, false);\n        });\n\n        return imageWaitTask;\n    }\n</code></pre>\n<p>And you maybe want to have some insight into the pause method:</p>\n<pre><code>protected void pause(PauseType pauseType, int seconds, String message, Exercise exercise, boolean switchSide) {\n\n        URL url = getClass().getResource(&quot;/sifuSays/ui/PauseScene.fxml&quot;);\n        try {\n            debugLogger.debug(&quot;entering pause:&quot; + seconds + &quot; sec&quot;);\n\n            FXMLLoader fxmlLoader = new FXMLLoader(url);\n            Parent parent = fxmlLoader.load();\n            Stage stage = new Stage(StageStyle.UNDECORATED);\n            stage.initOwner(mediaPane.getScene().getWindow());\n\n            pauseCtrl = fxmlLoader.&lt;PauseCtrl&gt;getController();\n\n            debugLogger.debug(&quot;pauseType: &quot; + pauseType.toString());\n            switch (pauseType) {\n                case SESSION_START:                                                             // Beginning of session\n                    pauseCtrl.configure(stage, seconds);\n\n                    debugLogger.debug(&quot;SESSION_START: getReady&quot;);\n                    pauseCtrl.getReady();\n                    break;\n                case EXERCISE_PAUSE:                                                            // Change between exercises\n                    debugLogger.debug(&quot;EXERCISE_PAUSE: configure&quot;);\n                    pauseCtrl.configure(stage, seconds, message, exercise, switchSide);\n\n                    debugLogger.debug(&quot;EXERCISE_PAUSE: exercisePause&quot;);\n                    pauseCtrl.exercisePause();\n                    break;\n                case SESSION_END:                                                               // End of session\n                    debugLogger.debug(&quot;SESSION_END: configure&quot;);\n                    pauseCtrl.configure(stage, seconds);\n\n                    debugLogger.debug(&quot;SESSION_END: done&quot;);\n                    pauseCtrl.done();\n                    break;\n                case SETS_PAUSE:\n                    debugLogger.debug(&quot;SETS_PAUSE: configure&quot;);\n                    pauseCtrl.configure(stage, seconds, message, exercise, switchSide);\n\n                    debugLogger.debug(&quot;SETS_PAUSE: setsPause&quot;);\n                    pauseCtrl.setsPause();\n                    break;\n                default:\n                    debugLogger.debug(&quot;Uncovered case option&quot;);\n                    return;         // This should not happen\n            }\n\n            Scene scene = new Scene(parent);\n\n            if(seconds &gt; 0) {\n                stage.setScene(scene);\n                debugLogger.debug(&quot;Calling showAndWait&quot;);\n                stage.showAndWait();\n            }\n\n            pauseCtrl = null;\n\n            debugLogger.debug(&quot;Pause ended. Continue&quot;);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n</code></pre>\n<p>I am aware that one way to fix the issue would be, to add the pause duration to the image display duration in the loop counter. But since in the real algorithm the display time of the exercise plus, if there are none to multiple breaks at all and how long they will last, is much more complex, plus I would like to understand the intended design, and to learn how to setup the method(s) to get the described synchronized bahaviour of the application without violating the restrictions of JavaFX regarding threads and UI updates? Thank you in advance.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}