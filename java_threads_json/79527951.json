{
  "question": {
    "tags": [
      "java",
      "tcp",
      "tcpclient",
      "network-protocols",
      "tcpserver"
    ],
    "owner": {
      "account_id": 40910541,
      "reputation": 11,
      "user_id": 30024745,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/f841f7964b16f36536f1a04177742f6d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Chulija",
      "link": "https://stackoverflow.com/users/30024745/chulija"
    },
    "is_answered": true,
    "view_count": 109,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1742837133,
    "creation_date": 1742669840,
    "question_id": 79527951,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79527951/ping-pong-message-system-in-java-between-clients-and-a-server-over-tcp-sockets",
    "title": "Ping/Pong message system in Java between clients and a server over TCP sockets",
    "body": "<p>I need to create a connection between 4 clients and a server and they should communicate over a networkprotocol.\nI'm quite clueless and I don't know what I need to implement in which class. I managed to make a connection between the clients but when the server sends a PING-message the client doesn't register it and therefore doesn't send a PONG-message back.</p>\n<p>I would be thankful for any comments/tips concerning what I'm doing wrong or what has to be improved.</p>\n<p>This is the code in the most important classes.</p>\n<p>On the client-side I tried to establish this exchanging of messages with the following code. I expected that my Server sends the first ping-message after which my client responses by sending a pong-message back. What happened was that directly after joining the client receives &quot;PING&quot; but doesn't register it correctly and doesn't send a pong-message back, so the connection was lost after 15seconds.</p>\n<pre><code>import java.net.*;\nimport java.io.*;\n\npublic class Client {\n    public static void main(String[] args) {\n        try {\n            Socket sock = new Socket(args[0], Integer.parseInt(args[1]));\n            InputStream in = sock.getInputStream();\n            OutputStream out= sock.getOutputStream();\n\n            // create server reading thread\n            InThread th = new InThread(in);\n            Thread iT = new Thread(th);\n            iT.start();\n\n            PongThread pongThread = new PongThread(sock);\n            Thread pongT = new Thread(pongThread);\n            pongT.start();\n\n            // stream input\n            BufferedReader conin = new BufferedReader(new InputStreamReader(System.in));\n            String line = &quot; &quot;;\n            while (true) {\n                // reading input stream\n                line = conin.readLine();\n                if (line.equalsIgnoreCase(&quot;QUIT&quot;)) {\n                    //sendQuitMessage(); odr so halt eifach das vom ProtocolReaderClient\n                    break;\n                } else if (line.startsWith(&quot;/nick&quot;)){\n                    //changeNickname(line.substring(6)); oder das vom Protocol\n                } else {\n                    //sendMessage(line); oder das vom Protocol\n                }\n            }\n            // terminate program\n            System.out.println(&quot;Terminating ...&quot;);\n            in.close();\n            out.close();\n            sock.close();\n        } catch (IOException e) {\n            System.err.println(&quot;Error: &quot; + e.toString());\n        }\n    }\n}\n</code></pre>\n<pre><code>import java.io.*;\nimport java.net.Socket;\n\n/**\n * Eine Klasse, die auf PING-Nachrichten vom Server hört und PONG-Antworten sendet.\n * Diese Klasse soll in einem separaten Thread verwendet werden, um die Verbindung aufrechtzuerhalten.\n */\nclass PongThread implements Runnable {\n    private final Socket clientSocket;\n    private boolean running;\n\n    /**\n     * Konstruiert einen PongThread mit den angegebenen Input- und OutputStreams.\n     *\n     * @param clientSocket der BufferedReader von dem gelesen werden soll\n     *\n     */\n    public PongThread(Socket clientSocket) {\n        this.clientSocket = clientSocket;\n        this.running = true;\n    }\n\n    /**\n     * Hört auf PING-Nachrichten vom Server und sendet PONG-Antworten.\n     * Diese Methode läuft in einer Schleife und liest kontinuierlich Nachrichten aus dem InputStream.\n     */\n    public void run() {\n        try {\n            InputStream in = clientSocket.getInputStream();\n            OutputStream out = clientSocket.getOutputStream();\n\n            while (running) {\n                // Auf PING warten\n                long startTime = System.currentTimeMillis();\n\n                while (System.currentTimeMillis() - startTime &lt; 15000) {\n                    if (in.available() &gt; 0) {\n                        String response = readCommand(in);\n                        if (Command.PING.name().equals(response)) {\n                            System.out.println(response);\n                            sendCommand(out, Command.PONG.name()); //Senden von Pong\n                            System.out.println(&quot;PONG sent&quot;);\n                            startTime = System.currentTimeMillis(); //Restart the time setter\n                            break; //Pong empfangen, Schleife wird verlassen\n                        }\n                    }\n                }\n                if (System.currentTimeMillis() - startTime &gt;= 15000) {\n                    System.out.println(&quot;Server lost connection.&quot;);\n                    running = false;\n                    clientSocket.close();\n                }\n            }\n        } catch (IOException e) {\n            System.err.println(&quot;ERROR with server connection: &quot; + e.toString());\n        }\n    }\n    private void sendCommand(OutputStream out, String command) throws IOException {\n        out.write((command + Command.SEPARATOR).getBytes());\n    }\n\n    private String readCommand(InputStream in) throws IOException {\n        byte[] buffer = new byte[256];\n        int bytesRead = in.read(buffer);\n        return new String(buffer, 0, bytesRead).trim();\n    }\n\n    public void stopPinging() {\n        running = false;\n    }\n}\n</code></pre>\n<pre><code>import java.io.*;\n\n/**\n * Eine lauffähige Klasse, die Daten aus einem InputStream liest und sie in die Standardausgabe schreibt.\n * Diese Klasse soll in einem separaten Thread verwendet werden, um kontinuierlich von einem Netzwerksocket zu lesen.\n *\n * @author julia\n * @since 21.03.2025\n */\nclass InThread implements Runnable {\n    private InputStream in;\n\n    /**\n     * Konstruiert einen InThread mit dem angegebenen InputStream.\n     *\n     * @param in den InputStream, aus dem gelesen werden soll\n     */\n    public InThread(InputStream in) {\n        this.in = in;\n    }\n\n    /**\n     * Liest Daten aus dem InputStream und schreibt sie in die Standardausgabe.\n     * Diese Methode läuft in einer Schleife und liest kontinuierlich Bytes aus dem InputStream\n     * bis das Ende des Streams erreicht ist (angezeigt durch einen Rückgabewert von -1 von read()).\n     */\n    public void run() {\n        byte[] buffer = new byte[1024]; // Increased buffer size\n        int bytesRead;\n        try {\n            while ((bytesRead = in.read(buffer)) != -1) {\n                System.out.write(buffer, 0, bytesRead);\n                System.out.flush(); // Ensure output is flushed\n            }\n        } catch (IOException e) {\n            System.err.println(&quot;ERROR: &quot; + e.toString());\n        }\n    }\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}