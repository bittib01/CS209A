{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "tomcat",
      "jndi"
    ],
    "owner": {
      "account_id": 2215372,
      "reputation": 523,
      "user_id": 1956139,
      "user_type": "registered",
      "accept_rate": 57,
      "profile_image": "https://www.gravatar.com/avatar/42da8eb051d7f61b89e1e551b4152ecc?s=256&d=identicon&r=PG",
      "display_name": "Curtis Snowden",
      "link": "https://stackoverflow.com/users/1956139/curtis-snowden"
    },
    "is_answered": true,
    "view_count": 684,
    "accepted_answer_id": 79080083,
    "answer_count": 3,
    "score": 0,
    "last_activity_date": 1741968244,
    "creation_date": 1728574575,
    "last_edit_date": 1728578996,
    "question_id": 79075170,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79075170/spring-boot-application-not-reading-application-properties-in-tomcat",
    "title": "Spring Boot Application Not Reading Application.properties in Tomcat",
    "body": "<p>I'm trying to deploy a spring boot application as a WAR into Tomcat. When I have things hard-coded, it works just fine, and there are no problems. But after my initial testing, I tried to clean things up and go back to the properties. And I'm finding that my application.properties file is not being read by the application during deployment in Tomcat. And I'm just confused.</p>\n<p>My initial testing with Tomcat, to get the JNDI configured, was hard-coded, and everything worked just fine then:</p>\n<pre><code>@Configuration\npublic class DataSourceConfig {\n    @Bean\n    public DataSource dataSource() {\n        return (DataSource) new JndiTemplate().lookup(&quot;java:/comp/env/jdbc/myJndiLocal&quot;);\n    }\n}\n</code></pre>\n<p>My context.xml is good and my tomcat's server.xml global resources are configured. The connection was made, and everything worked. Of course, hard-coded isn't what I want, so I switched to the properties.</p>\n<p>Now, my problems are related to the org.springframework.boot.autoconfigure.jdbc.DataSourceProperties. I have my properties configured in Application.properties, which is in my resources directory:</p>\n<pre><code>spring.datasource.url=jdbc:postgresql://localhost:5432/MY_DB?currentSchema=public\nspring.datasource.username=postgresql_username\nspring.datasource.password=postgresql_password\nspring.datasource.driver-class-name=org.postgresql.Driver\nspring.datasource.jndiName=jdbc/myJndiLocal\n</code></pre>\n<p>And I created a datasource configuration that prepares my database connection:</p>\n<pre><code>@Configuration\npublic class DataSourceConfig {\n    @Bean\n    public DataSource dataSource(DataSourceProperties dataSourceProperties) {\n\n        System.out.printf(&quot; !!!!! Datasource Config !!!!! %n&quot; +\n            &quot;   url: %s%n&quot; +\n            &quot;   username: %s%n&quot; +\n            &quot;   password: %s%n&quot; +\n            &quot;   driver: %s%n&quot; +\n            &quot;   jndi: %s%n&quot; +\n            &quot;   jndi full: %s%n&quot;,\n            dataSourceProperties.getUrl(), dataSourceProperties.getUsername(), dataSourceProperties.getPassword(),\n            dataSourceProperties.getDriverClassName(), dataSourceProperties.getJndiName(),\n            String.format(&quot;java:/comp/env/%s&quot;, dataSourceProperties.getJndiName())\n        );\n\n        if (dataSourceProperties.getJndiName() != null &amp;&amp; !dataSourceProperties.getUrl().isBlank()) {\n            try {\n                return (DataSource) new JndiTemplate().lookup(String.format(&quot;java:/comp/env/%s&quot;, dataSourceProperties.getJndiName()));\n            }\n            catch (Exception e) {\n                System.out.println(&quot; !!!!! JNDI Resource could not be found! Regular JDBC Configuration will be used instead. !!!!! &quot;);\n            }\n        }\n\n        DataSourceBuilder&lt;?&gt; dataSourceBuilder = DataSourceBuilder.create();\n        dataSourceBuilder.driverClassName(dataSourceProperties.getDriverClassName());\n        dataSourceBuilder.url(dataSourceProperties.getUrl());\n        dataSourceBuilder.username(dataSourceProperties.getUsername());\n        dataSourceBuilder.password(dataSourceProperties.getPassword());\n        return dataSourceBuilder.build();\n    }\n}\n</code></pre>\n<p>The first printf statement is just for current debugging, and I'll remove it later. My goal is to default to JNDI if present, otherwise use standard JDBC configuration. When running as a JAR with the embedded tomcat via my IDE, there are no problems. Properties are read into place, and everything gets configured as I expect.</p>\n<pre><code> !!!!! Datasource Config !!!!! \n   url: jdbc:postgresql://localhost:5432/MY_DB?currentSchema=public\n   username: postgresql_username\n   password: postgresql_password\n   driver: org.postgresql.Driver\n   jndi: jdbc/myJndiLocal\n   jndi full: java:/comp/env/jdbc/myJndiLocal\n !!!!! JNDI Resource could not be found! Regular JDBC Configuration will be used instead. !!!!! \n</code></pre>\n<p>The problem now, however, is that my properties are all completely null when deployed as a WAR file into an external Tomcat.</p>\n<pre><code> !!!!! Datasource Config !!!!!\n   url: null\n   username: null\n   password: null\n   driver: null\n   jndi: null\n   jndi full: java:/comp/env/null\n</code></pre>\n<p>I'm using the SpringBootServletInitializer for the WAR deployment, so I have to assume that is causing some kind of issue, but I'm at a loss presently as to what it is.</p>\n<pre><code>@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})\n@EntityScan(basePackages = {&quot;com.mycompany.myapp.model&quot;, &quot;com.mycompany.model&quot;})\n@EnableJpaRepositories(basePackages = {&quot;com.mycompany.dao.jpa&quot;})\n@ComponentScan(basePackages = {\n    &quot;com.mycompany.myapp&quot;,\n    &quot;com.mycompany.service&quot;,\n    &quot;com.mycompany.service.impl&quot;,\n    &quot;com.mycompany.myapp.webapp.pages&quot;,\n    &quot;com.mycompany.webapp.util&quot;,\n    &quot;com.mycompany.webapp.util.migration&quot;,\n    &quot;com.mycompany.myapp.annotations.validation&quot;,\n    &quot;com.mycompany.annotations&quot;\n})\npublic class MyAppApplication extends SpringBootServletInitializer {\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {\n        return builder.sources(MyAppApplication.class);\n    }\n    \n    public static void main(String[] args) {\n        SpringApplication.run(MyAppApplication.class, args);\n    }\n}\n</code></pre>\n<p>I'm on the latest Spring Boot, 3.3.4, and am using the latest Tomcat, 10.1.31. I'm also utilizing Maven for the dependencies and builds. I have already confirmed that the Application.properties is inside the proper location in the WAR file - /WEB-INF/classes/Application.properties. Why are my properties not being read into the application, and what can I do to address this? I've been doing some reading <a href=\"https://stackoverflow.com/questions/62227916/spring-boot-application-not-reading-application-properties-in-tomcat-but-work\">and found this question</a>, which is similar, but I'm not doing anything inside of my main method. DataSourceProperties is a default Spring class, so I would have expected it would just populate. The use of it as a parameter to my configuration method I would have expected to force a jumpstart even if it wasn't prepared automatically.</p>\n<hr />\n<p>Found a resolution, although I don't really understand why it is needed, nor why it's helping. I needed to add the @PropertySource annotation to my DataSourceConfig. Once I did that, all my properties were in place, and everything loaded up perfectly, connecting to my defined JNDI.</p>\n<pre><code>@Configuration\n@PropertySource(&quot;classpath:Application.properties&quot;)\npublic class DataSourceConfig {\n    ....\n}\n</code></pre>\n<p>So, the Application.properties clearly must already have been on the classpath in order for that annotation to work properly. I'm now mainly confused as to why it wasn't being used by the application? Is there something about Tomcat deployment or my current configuration that is forcing Spring to utilize its own internal defaults and ignore my configuration files? <a href=\"https://docs.spring.io/spring-boot/reference/features/external-config.html#features.external-config.files\" rel=\"nofollow noreferrer\">The documentation is telling me that the file should be picked up automatically.</a></p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}