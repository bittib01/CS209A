{
  "question": {
    "tags": [
      "java",
      "sockets",
      "serversocket",
      "objectinputstream",
      "objectoutputstream"
    ],
    "owner": {
      "account_id": 27633463,
      "reputation": 24,
      "user_id": 21091863,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/e68fa668eef56b95deec69116af45058?s=256&d=identicon&r=PG",
      "display_name": "JavaEnthusiast27",
      "link": "https://stackoverflow.com/users/21091863/javaenthusiast27"
    },
    "is_answered": true,
    "view_count": 77,
    "accepted_answer_id": 78692410,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1719839053,
    "creation_date": 1715722699,
    "question_id": 78480752,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78480752/continuous-socket-connection-objectinputstream-eof-on-second-request",
    "title": "Continuous Socket connection, ObjectInputStream EOF on second request",
    "body": "<h5>Java 21 Sockets <br> allowing for multiple connections <br> using ObjectInputStream and ObjectOutputStream produce EOF on second request</h5>\n<p>I have a Client side, a (middleman) Bridge Server and an Inventory server. <br></p>\n<ul>\n<li>The Client refers to end users. <br></li>\n<li>The Server refers to the authorization system and a kind of gateway to the Inventory Server<br></li>\n</ul>\n<p>The sequence diagram is the following:<br>\n<a href=\"https://i.sstatic.net/MBPIWPFp.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/MBPIWPFp.png\" alt=\"Communication flow between components\" /></a></p>\n<p>Now for the problem:</p>\n<ol>\n<li>Starting <code>BridgeServer</code></li>\n<li>Starting <code>UserClient</code> <br> and observing the connection has been established.</li>\n<li>Sending any type of request <br> (object) from the options showcased in the terminal.\n<br> in my runs I sent the <code>AuthenticationRequest</code>.</li>\n<li>The <code>AuthenticationRequest</code> is processed correctly.</li>\n<li>Resend the <code>AuthenticationRequest</code> or <strong>any</strong> request.</li>\n<li><strong><code>EOFException</code></strong> is thrown by the <code>BridgeServer</code></li>\n</ol>\n<pre class=\"lang-console prettyprint-override\"><code>java.io.EOFException\n    at java.base/java.io.ObjectInputStream$PeekInputStream.readFully(ObjectInputStream.java:2933)\n    at java.base/java.io.ObjectInputStream$BlockDataInputStream.readShort(ObjectInputStream.java:3428)\n    at java.base/java.io.ObjectInputStream.readStreamHeader(ObjectInputStream.java:985)\n    at java.base/java.io.ObjectInputStream.&lt;init&gt;(ObjectInputStream.java:416)\n    at com.pe.distributed.system.bridge.BridgeServer.run(BridgeSide.java:44)\n    at com.pe.distributed.system.bridge.BridgeMain.main(BridgeMain.java:5)\n</code></pre>\n<p>For context and reproducability:</p>\n<p><strong>UserClient</strong></p>\n<pre class=\"lang-java prettyprint-override\"><code>\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.net.Socket;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic record AuthenticationRequest(String username, String password) implements Serializable {\n}\n\npublic record InventoryQuery() implements Serializable {\n}\n\npublic record ItemOrder(String itemCode, int quantity) implements Serializable {\n}\n\npublic class UserClient {\n    private static final Logger logger = Logger.getLogger(UserClient.class.getName());\n    private static final String EXCEPTION_OCCURRED = &quot;Exception occurred&quot;;\n\n    private UserClient() {\n    }\n\n    @SuppressWarnings(&quot;java:S2189&quot;)\n    public static void run() {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            try (Socket bridgeSocket = new Socket(&quot;127.0.0.1&quot;, 5550)) {\n                logger.log(Level.INFO, &quot;Connected successfully to bridge server&quot;);\n\n                while (true) {\n                    displayMainMenu();\n                    int choice = scanner.nextInt();\n                    scanner.nextLine();\n\n                    // Handle user choice\n                    switch (choice) {\n                        case 1:\n                            authenticate(scanner, bridgeSocket);\n                            break;\n                        case 2:\n                            checkInventory(bridgeSocket);\n                            break;\n                        case 3:\n                            placeOrder(scanner, bridgeSocket);\n                            break;\n                        default:\n                            logger.log(Level.WARNING, &quot;Invalid choice. Please enter a valid option.&quot;);\n                    }\n                }\n            } catch (IOException | ClassNotFoundException e) {\n                logger.log(Level.SEVERE, EXCEPTION_OCCURRED, e);\n            } finally {\n                scanner.close();\n            }\n        }\n    }\n\n    @SuppressWarnings(&quot;java:S106&quot;)\n    private static void displayMainMenu() {\n        System.out.println(&quot;What would you like to do:&quot;);\n        System.out.println(&quot;1. Authenticate&quot;);\n        System.out.println(&quot;2. Check Inventory&quot;);\n        System.out.println(&quot;3. Place an Order&quot;);\n        System.out.print(&quot;Enter your choice: &quot;);\n    }\n\n    @SuppressWarnings(&quot;java:S106&quot;)\n    private static void authenticate(Scanner scanner, Socket socket) throws IOException, ClassNotFoundException {\n        Map.Entry&lt;String, String&gt; authCreds = getUserAuthenticationInput(scanner);\n        AuthenticationRequest authenticationRequest = new AuthenticationRequest(authCreds.getKey(),\n                authCreds.getValue());\n\n        ObjectOutputStream bridgeIn = new ObjectOutputStream(socket.getOutputStream());\n        bridgeIn.writeObject(authenticationRequest);\n        bridgeIn.flush();\n\n        ObjectInputStream bridgeOut = new ObjectInputStream(socket.getInputStream());\n        Object response = bridgeOut.readObject();\n        logger.log(Level.FINE, &quot;Received response from bridge: {0}&quot;, response);\n        System.out.println(response);\n    }\n\n    @SuppressWarnings(&quot;java:S106&quot;)\n    private static Map.Entry&lt;String, String&gt; getUserAuthenticationInput(Scanner scanner) {\n        System.out.println(&quot;Please provide credentials.\\n&quot;);\n        System.out.print(&quot;Username: &quot;);\n        String username = scanner.nextLine();\n        System.out.print(&quot;Password: &quot;);\n        String password = scanner.nextLine();\n        return Map.entry(username, password);\n    }\n\n    @SuppressWarnings(&quot;java:S106&quot;)\n    private static void checkInventory(Socket socket) throws IOException, ClassNotFoundException {\n        ObjectOutputStream bridgeIn = new ObjectOutputStream(socket.getOutputStream());\n        bridgeIn.writeObject(new InventoryQuery());\n        bridgeIn.flush();\n\n        ObjectInputStream bridgeOut = new ObjectInputStream(socket.getInputStream());\n        Object response = bridgeOut.readObject();\n        logger.log(Level.FINE, &quot;Received response from bridge: {0}&quot;, response);\n        System.out.println(response);\n    }\n\n    private static void placeOrder(Scanner scanner, Socket socket) throws IOException, ClassNotFoundException {\n        Map.Entry&lt;String, Integer&gt; orderDetails = getUserOrderInput(scanner);\n        ItemOrder itemOrder = new ItemOrder(orderDetails.getKey(), orderDetails.getValue());\n\n        ObjectOutputStream bridgeIn = new ObjectOutputStream(socket.getOutputStream());\n        bridgeIn.writeObject(itemOrder);\n        bridgeIn.flush();\n\n        ObjectInputStream bridgeOut = new ObjectInputStream(socket.getInputStream());\n        Object response = bridgeOut.readObject();\n        logger.log(Level.FINE, &quot;Received response from bridge: {0}&quot;, response);\n    }\n\n    @SuppressWarnings(&quot;java:S106&quot;)\n    private static Map.Entry&lt;String, Integer&gt; getUserOrderInput(Scanner scanner) {\n        System.out.println(&quot;Place your order!\\n&quot;);\n\n        String itemCode;\n        int desiredQuantity;\n\n        // Input validation loop for item code\n        do {\n            System.out.print(&quot;Item-code: &quot;);\n            itemCode = scanner.nextLine();\n        } while (itemCode == null || itemCode.isEmpty());\n\n        // Input validation loop for quantity\n        do {\n            System.out.print(&quot;Quantity: &quot;);\n            while (!scanner.hasNextInt()) {\n                System.out.println(&quot;Invalid input. Please enter a valid number.&quot;);\n                scanner.next(); // Consume the invalid input\n            }\n            desiredQuantity = scanner.nextInt();\n            scanner.nextLine(); // Consume newline character\n        } while (desiredQuantity &lt;= 0);\n\n        return Map.entry(itemCode, desiredQuantity);\n    }\n}\n</code></pre>\n<p>and the <strong>BridgeServer</strong></p>\n<pre class=\"lang-java prettyprint-override\"><code>import lombok.Getter;\nimport lombok.Setter;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n@Getter\n@Setter\npublic class User {\n\n    String username;\n    String password;\n\n    public User(String username, String password) {\n        this.username = username;\n        this.password = password;\n    }\n}\n\npublic record AuthenticationResponse(String message, Boolean isAuthenticated) implements Serializable {\n}\n\npublic record AuthenticationRequest(String username, String password) implements Serializable {\n}\n\npublic class BridgeServer {\n    private static final Logger logger = Logger.getLogger(BridgeServer.class.getName());\n    private static final Map&lt;String, User&gt; users;\n\n    static {\n        users = new ConcurrentHashMap&lt;&gt;();\n        // Populate inventory with sample items\n        users.put(&quot;user1&quot;, new User(&quot;user1&quot;, &quot;pass1&quot;));\n        users.put(&quot;user2&quot;, new User(&quot;user2&quot;, &quot;pass2&quot;));\n        users.put(&quot;user3&quot;, new User(&quot;user3&quot;, &quot;pass3&quot;));\n    }\n\n    @SuppressWarnings(&quot;java:S2189&quot;)\n    public static void run() {\n        try (ExecutorService executorService = Executors.newCachedThreadPool();\n             ServerSocket serverSocket = new ServerSocket(5550)) {\n            logger.info(&quot;Bridge server started, waiting for connections...&quot;);\n\n            //noinspection InfiniteLoopStatement\n            while (true) {\n                Socket userSocket = serverSocket.accept();\n                String clientKey = userSocket.getInetAddress().toString() + &quot;:&quot; + userSocket.getPort();\n                logger.log(Level.INFO, &quot;User client with key {0} connected.&quot;, clientKey);\n\n                executorService.submit(new BridgeConnectionHandler(userSocket, clientKey));\n            }\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, &quot;IOException occurred&quot;, e);\n        }\n    }\n\n    @SuppressWarnings(&quot;java:S2189&quot;)\n    private record BridgeConnectionHandler(Socket userSocket, String clientKey) implements Runnable {\n        @Override\n        public void run() {\n            try (ObjectInputStream in = new ObjectInputStream(userSocket.getInputStream());\n                 ObjectOutputStream out = new ObjectOutputStream(userSocket.getOutputStream())) {\n\n                boolean isAuthenticated = false;\n                //noinspection InfiniteLoopStatement\n                while (true) {\n                    Object request = in.readObject();\n                    // If the client is authenticated, handle user requests\n                    if (isAuthenticated) {\n                        if (!(request instanceof AuthenticationRequest)) {\n                            handleUserRequest(in, out);\n                        } else {\n                            out.writeObject(new AuthenticationResponse(&quot;Client already authenticated with user &quot;\n                                    + users.get(clientKey), true));\n                            out.flush();\n                        }\n                    } else if (request instanceof AuthenticationRequest authenticationRequest) {\n                        AuthenticationResponse authenticationResponse = handleAuthenticationRequest(authenticationRequest);\n                        out.writeObject(authenticationResponse);\n                        out.flush();\n\n                        isAuthenticated = authenticationResponse.isAuthenticated();\n                    } else {\n                        out.writeObject(new AuthenticationResponse(&quot;Not authenticated&quot;, false));\n                        out.flush();\n                    }\n                }\n            } catch (IOException | ClassNotFoundException e) {\n                logger.log(Level.SEVERE, &quot;Exception occurred&quot;, e);\n            }\n        }\n\n        private AuthenticationResponse handleAuthenticationRequest(AuthenticationRequest authenticationRequest) {\n            boolean authenticated = authenticate(authenticationRequest.username(), authenticationRequest.password());\n            return new AuthenticationResponse(authenticated ? &quot;Authentication successful&quot; : &quot;Authentication failed&quot;, authenticated);\n        }\n\n        private static synchronized boolean authenticate(String username, String password) {\n            User user = users.get(username);\n            return user != null &amp;&amp; user.getPassword().equals(password);\n        }\n\n        private void handleUserRequest(ObjectInputStream bridgeIn, ObjectOutputStream userOut) throws IOException {\n            try (Socket inventorySocket = new Socket(&quot;127.0.0.1&quot;, 12346);\n                 ObjectOutputStream inventoryOut = new ObjectOutputStream(inventorySocket.getOutputStream());\n                 ObjectInputStream inventoryIn = new ObjectInputStream(inventorySocket.getInputStream())) {\n\n                Object request;\n                while ((request = bridgeIn.readObject()) != null) {\n                    logger.log(Level.INFO, &quot;Received request from user: {0}&quot;, request);\n\n                    // Forward request to inventory side\n                    inventoryOut.writeObject(request);\n                    inventoryOut.flush();\n\n                    // Receive response from inventory side\n                    Object response = inventoryIn.readObject();\n                    logger.log(Level.INFO, &quot;Received response from inventory: {0}&quot;, response);\n\n                    // Send response back to user side\n                    userOut.writeObject(response);\n                    userOut.flush();\n                }\n            } catch (ClassNotFoundException e) {\n                logger.log(Level.SEVERE, &quot;Exception occurred&quot;, e);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        run();\n    }\n\n}\n</code></pre>\n<p>Specifically I mentioned <strong>EOF</strong> being thrown in <code>BridgeServer</code> and specifically under <code>BridgeConnectionHandler</code>'s<code> &lt;br&gt; Object request = in.readObject();</code> the <strong>second</strong> time a request comes through.</p>\n<p>I've been thorough in <code>flush()</code>ing every time an object is written.<br></p>\n<ol>\n<li>Some answers say that the <strong>socket/connection is closing</strong> therefore the <code>ObjectInputStream</code> produces <code>EOFException</code> as expected. <br></li>\n<li>Others say that the <code>ObjectInputStream</code> object(s) and the actual Socket's <code>InputStream</code> may be <strong>out of sync</strong>.</li>\n</ol>\n<p>Maybe I have misunderstood the capabilities of sockets,\nbut</p>\n<ul>\n<li>I want my server to keep the connection alive till the client closes it. <br></li>\n<li>And for all of the requests to be processed correctly.</li>\n</ul>\n<p>And of course no <code>EOFException</code> errors.</p>\n<p>Would love some feedback !</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}