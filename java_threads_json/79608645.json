{
  "question": {
    "tags": [
      "java",
      "spring",
      "spring-boot",
      "oauth-2.0",
      "spring-authorization-server"
    ],
    "owner": {
      "account_id": 12296207,
      "reputation": 2560,
      "user_id": 8971773,
      "user_type": "registered",
      "accept_rate": 25,
      "profile_image": "https://i.sstatic.net/tFcJU.png?s=256",
      "display_name": "Kira Resari",
      "link": "https://stackoverflow.com/users/8971773/kira-resari"
    },
    "is_answered": true,
    "view_count": 125,
    "accepted_answer_id": 79634902,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1747979414,
    "creation_date": 1746532384,
    "last_edit_date": 1747636834,
    "question_id": 79608645,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79608645/spring-authorization-server-how-to-unregister-default-authenticationproviders",
    "title": "Spring Authorization Server ~ How to unregister default AuthenticationProviders",
    "body": "<p>I am trying to implement OAuth2 authentication for an App in a Spring Boot backend using Spring Authorization Server. My problem is that I have custom logic that uses its own AuthenticationProviders, yet Spring Authentication Server automatically adds a whole bunch of default providers which can't handle my custom logic, and then crash. What I want is to figure out how I can get rid of the default AuthenticationProviders so that no crashes will occur.</p>\n<p>Now, this is very abstract, so here's the concrete thing. In my own refresh token AuthenticationProvider, I have a bit that checks if the device_id (a custom field we use) matches the saved device_id and throws an OAuth2AuthenticationException if it doesn't.</p>\n<pre><code>        if (!providedDeviceId.equals(storedDeviceId)) {\n            String errorMessage = &quot;Provided device ID '&quot; + providedDeviceId\n                + &quot;' did not match stored device ID '&quot; + storedDeviceId\n                + &quot;' for refresh token '&quot; + refreshTokenValue + &quot;'&quot;;\n            log.warn(errorMessage);\n            throw new OAuth2AuthenticationException(\n                new OAuth2Error(OAuth2ErrorCodes.INVALID_GRANT, errorMessage, null)\n            );\n        }\n</code></pre>\n<p>That logic works just fine. However, in the framework class <code>org.springframework.security.authentication.ProviderManager</code>, the authentication method works like this:</p>\n<pre><code>    @Override\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n        [...]\n        for (AuthenticationProvider provider : getProviders()) {\n            if (!provider.supports(toTest)) {\n                continue;\n            }\n            [...]\n            try {\n                result = provider.authenticate(authentication);\n                if (result != null) {\n                    copyDetails(authentication, result);\n                    break;\n                }\n            }\n            catch (AccountStatusException | InternalAuthenticationServiceException ex) {\n                prepareException(ex, authentication);\n                // SEC-546: Avoid polling additional providers if auth failure is due to\n                // invalid account status\n                throw ex;\n            }\n            catch (AuthenticationException ex) {\n                lastException = ex;\n            }\n        }\n</code></pre>\n<p>That is, it iterates over all AuthenticationProviders that support an authentication type, and only breaks if it succeeds, or an AccountStatusException or InternalAuthenticationServiceException is thrown. Note that it does not break on an AuthenticationException, which is how I would have expected it to work. Instead, it continues iterating over the remaining AuthenticationProviders that support an authentication type. And that leads me to my problem:</p>\n<p><code>getProviders()</code> returns not one but two providers that nominally support OAuth2RefreshTokenAuthenticationToken: My own custom <code>OAuth2RefreshTokenAuthProvider</code>, and the default <code>org.springframework.security.oauth2.server.authorization.authentication.OAuth2RefreshTokenAuthenticationProvider</code>. On the plus side, my own provider is called first and correctly throws its OAuth2AuthenticationException if the device_id mismatches. Unfortunately, however, the Spring OAuth2RefreshTokenAuthenticationProvider is called next, and runs into this error:</p>\n<pre><code>java.lang.IllegalArgumentException: value cannot be null\n    at org.springframework.util.Assert.notNull(Assert.java:181)\n    at org.springframework.security.oauth2.server.authorization.token.OAuth2TokenContext$AbstractBuilder.put(OAuth2TokenContext.java:219)\n    at org.springframework.security.oauth2.server.authorization.token.OAuth2TokenContext$AbstractBuilder.principal(OAuth2TokenContext.java:152)\n    at org.springframework.security.oauth2.server.authorization.authentication.OAuth2RefreshTokenAuthenticationProvider.authenticate(OAuth2RefreshTokenAuthenticationProvider.java:171)\n    at org.springframework.security.authentication.ProviderManager.authenticate(ProviderManager.java:182)\n    at org.springframework.security.authentication.ObservationAuthenticationManager.lambda$authenticate$1(ObservationAuthenticationManager.java:54)\n    at io.micrometer.observation.Observation.observe(Observation.java:564)\n    at org.springframework.security.authentication.ObservationAuthenticationManager.authenticate(ObservationAuthenticationManager.java:53)\n</code></pre>\n<p>I could get into detail as to why this Assert.notNull fails. The short version is that the Spring OAuth2RefreshTokenAuthenticationProvider can't check the device_id because it's a custom field, and that causes issues further down the line. But really, that is not the point. The main issue in my eyes here is that the Spring OAuth2RefreshTokenAuthenticationProvider is called at all. What I want is that my custom OAuth2RefreshTokenAuthProvider is called instead, and not in addition to the default provider, since that's what I wrote it for.</p>\n<p>And that wraps us back to my initial question: How can I configure Spring Authorization Server to not add the default providers?</p>\n<hr />\n<h1>Addendum</h1>\n<p>My OAuth2Config looks like this:</p>\n<pre><code>@Configuration\npublic class OAuth2Config {\n    @Bean\n    public SecurityFilterChain oAuth2FilterChain(\n        HttpSecurity http,\n        OAuth2PasswordGrantAuthProvider passwordAuthProvider,\n        OAuth2RefreshTokenAuthProvider refreshTokenAuthProvider,\n        PasswordGrantAuthenticationConverter passwordGrantAuthenticationConverter,\n        RefreshTokenAuthenticationConverter refreshTokenAuthenticationConverter\n    ) throws Exception {\n        OAuth2AuthorizationServerConfigurer configurer =\n            new OAuth2AuthorizationServerConfigurer();\n\n        configurer.tokenEndpoint(token -&gt; token\n            .accessTokenRequestConverter(\n                new DelegatingAuthenticationConverter(List.of(\n                    passwordGrantAuthenticationConverter,\n                    refreshTokenAuthenticationConverter\n                )))\n            .authenticationProvider(passwordAuthProvider)\n            .authenticationProvider(refreshTokenAuthProvider)\n        );\n\n        http\n            .securityMatcher(&quot;/oauth2/**&quot;)\n            .with(configurer, (authorizationServer) -&gt;\n                authorizationServer.oidc(Customizer.withDefaults()))\n            .authorizeHttpRequests(\n                auth -&gt; auth\n                    .requestMatchers(&quot;/oauth2/token&quot;).permitAll()\n                    .anyRequest().authenticated())\n            .csrf(csrf -&gt; csrf.ignoringRequestMatchers(&quot;/oauth2/**&quot;));\n\n        return http.build();\n    }\n\n    @Bean\n    public RegisteredClientRepository registeredClientRepository(\n        OAuth2Properties oAuth2Properties\n    ) {\n        TokenSettings tokenSettings = TokenSettings.builder()\n            .accessTokenTimeToLive(Duration.ofMinutes(\n                oAuth2Properties.getFirstScope().getAccessTokenTimeToLiveInMinutes()))\n            .refreshTokenTimeToLive(Duration.ofDays(\n                oAuth2Properties.getFirstScope().getRefreshTokenTimeToLiveInDays()))\n            .reuseRefreshTokens(false)\n            .build();\n        RegisteredClient firstClient = RegisteredClient.withId(\n                UUID.randomUUID().toString())\n            .clientId(MyOAuth2.FIRST_CLIENT_ID)\n            .clientAuthenticationMethod(ClientAuthenticationMethod.NONE)\n            .authorizationGrantType(AuthorizationGrantType.PASSWORD)\n            .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)\n            .scope(MyOAuth2.FIRST_SCOPE)\n            .tokenSettings(tokenSettings)\n            .build();\n        return new InMemoryRegisteredClientRepository(firstClient);\n    }\n\n    @Bean\n    public OAuth2AuthorizationService authorizationService(\n        JdbcTemplate jdbcTemplate,\n        RegisteredClientRepository registeredClientRepository\n    ) {\n        return new JdbcOAuth2AuthorizationService(\n            jdbcTemplate, registeredClientRepository);\n    }\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}