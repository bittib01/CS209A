{
  "question": {
    "tags": [
      "java",
      "design-patterns"
    ],
    "owner": {
      "account_id": 3435867,
      "reputation": 359,
      "user_id": 2879021,
      "user_type": "registered",
      "profile_image": "https://graph.facebook.com/100000731128152/picture?type=large",
      "display_name": "Adriano Todaro",
      "link": "https://stackoverflow.com/users/2879021/adriano-todaro"
    },
    "is_answered": true,
    "view_count": 52,
    "answer_count": 1,
    "score": 2,
    "last_activity_date": 1732376174,
    "creation_date": 1732368598,
    "question_id": 79217925,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79217925/how-to-properly-model-the-entities-am-i-working-with",
    "title": "How to properly model the entities am i working with",
    "body": "<p>I am developing an application which, among other things, defines the following entities:</p>\n<p>There is a base class called &quot;Action&quot;, with the following inheritors:</p>\n<p>SimpleAction1, SimpleAction2 , BaseComplexAction.</p>\n<p>BaseComplexAction is inherited by ComplexAction1, ComplexAction2</p>\n<p>Then, there's is a generic interface called &quot;Technique&quot; whose generic type can be any class in the &quot;Action&quot; hierarchy.</p>\n<p>&quot;Technique&quot; defines two methods:</p>\n<p>getActions() which returns a concrete subtype of &quot;Action&quot; and matchesAction() which returns a Boolean.\nmatchesAction() is supposed to tell if a certain Action could have been generated by the concrete implementation of &quot;Technique&quot;.</p>\n<p>I'll add some example Java implementations of the classes above for reference:</p>\n<pre><code>interface Technique&lt;T extends Action&gt; {\n    T getActions();\n    boolean matchesAction(T action);\n}\n\n// Concrete Technique implementation\nclass MyTechnique implements Technique&lt;BaseComplexAction&gt; {\n    @Override\n    public BaseComplexAction getActions() {\n        // Logic to determine and return a specific ComplexAction\n        return new ComplexAction1();\n    }\n\n    @Override\n    public boolean matchesAction(BaseComplexAction action) {\n        // Logic to check if the action matches the technique's criteria\n        return action instanceof ComplexAction1;\n    }\n}\n</code></pre>\n<p>Different Techniques can yield the same concrete type of Action</p>\n<p>With this structure, I am running into issues:</p>\n<ul>\n<li>If someone wants to use the matches() method on a generic Action, it will be necessary to first cast the action to the correct type supported by the concrete Technique type.</li>\n<li>Instead if I remove the generic type  from the definition of Technique, the concrete Technique will have to check the class type of the provided generic Action, and then cast it to the concrete subtype in order to perform the check</li>\n</ul>\n<p>I would like to ask for suggestions on how to improve my class definitions to avoid casts and make the consumption of these methods smoother, if possible.</p>\n<p>I'll be happy to provide more details if needed.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}