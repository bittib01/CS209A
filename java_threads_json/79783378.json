{
  "question": {
    "tags": [
      "java",
      "gradle",
      "opengl",
      "glsl",
      "lwjgl"
    ],
    "owner": {
      "account_id": 44211914,
      "reputation": 67,
      "user_id": 31634908,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/58b9e3f6bbec08233289a36e0161e5a7?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Klaus Alles",
      "link": "https://stackoverflow.com/users/31634908/klaus-alles"
    },
    "is_answered": true,
    "view_count": 161,
    "accepted_answer_id": 79783888,
    "answer_count": 1,
    "score": 3,
    "last_activity_date": 1761386698,
    "creation_date": 1759729350,
    "last_edit_date": 1759754890,
    "question_id": 79783378,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79783378/square-not-rendered-in-opengl",
    "title": "Square not rendered in OpenGL",
    "body": "<p>I'm trying to program a simple game in java using lwjgl and OpenGL but I'm not able to render a square to the window. Can someone help?</p>\n<p>The render function in render class is called evert frame and the init function in render class is called only once at the beginnig.</p>\n<p>Error message</p>\n<pre class=\"lang-none prettyprint-override\"><code>ERROR: Vertex shader compilation failed.\nERROR: 0:1: '#version' : bad profile name; use es, core, or compatibility\nERROR: 0:1: '#version' : bad tokens following profile -- expected newline\nERROR: 0:1: '' : compilation terminated\nERROR: 3 compilation errors.  No code generated.\n\nERROR: Fragment shader compilation failed.\nERROR: 0:1: '#version' : bad profile name; use es, core, or compatibility\nERROR: 0:1: '#version' : bad tokens following profile -- expected newline\nERROR: 0:1: '' : compilation terminated \nERROR: 3 compilation errors.  No code generated.\n\nERROR: Linking of shaders failed.\n</code></pre>\n<p>Render class</p>\n<pre><code>import java.nio.FloatBuffer;\nimport java.nio.IntBuffer;\n\nimport static org.lwjgl.opengl.GL15.*;\nimport static org.lwjgl.opengl.GL20.*;\nimport static org.lwjgl.opengl.GL30.glBindVertexArray;\nimport static org.lwjgl.opengl.GL30.glGenVertexArrays;\n\npublic class Render {\n    private Shader shader;\n\n    private float[] vertexArray = {\n            0.5f, -0.5f, 0.0f,\n            -0.5f, 0.5f, 0.0f,\n            0.5f, 0.5f, 0.0f,\n            -0.5f, -0.5f, 0.0f\n    };\n\n    private int[] elementArray = {\n            2, 1, 0,\n            0, 1, 3\n    };\n\n    private int vaoID, vboID, eboID;\n\n    public Render() {\n        this.shader = new Shader(&quot;defaultVertexShader.glsl&quot;, &quot;defaultFragmentShader.glsl&quot;, &quot;src/main/resources/render/shaders/&quot;);\n    }\n\n    public void init() {\n        shader.compile();\n        shader.link();\n\n        vaoID = glGenVertexArrays();\n        glBindVertexArray(vaoID);\n\n        FloatBuffer vertexBuffer = BufferUtils.createFloatBuffer(vertexArray.length);\n        vertexBuffer.put(vertexArray).flip();\n\n        vboID = glGenBuffers();\n        glBindBuffer(GL_ARRAY_BUFFER, vboID);\n        glBufferData(GL_ARRAY_BUFFER, vertexBuffer, vboID);\n\n        IntBuffer elementBuffer = BufferUtils.createIntBuffer(elementArray.length);\n        elementBuffer.put(elementArray).flip();\n\n        eboID = glGenBuffers();\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eboID);\n        glBufferData(GL_ELEMENT_ARRAY_BUFFER, elementBuffer, eboID);\n\n        glVertexAttribPointer(0, 3, GL_FLOAT, false, 12, 0);\n        glEnableVertexAttribArray(0);\n    }\n\n    public void render() {\n        shader.use();\n        glBindVertexArray(vaoID);\n        glEnableVertexAttribArray(0);\n\n        glDrawElements(GL_TRIANGLES, elementArray.length, GL_UNSIGNED_INT, 0);\n\n        glDisableVertexAttribArray(0);\n        glBindVertexArray(0);\n        shader.detach();\n    }\n}\n</code></pre>\n<p>Shader class</p>\n<pre><code>import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\nimport static org.lwjgl.opengl.GL11.GL_FALSE;\nimport static org.lwjgl.opengl.GL20.*;\nimport static org.lwjgl.opengl.GL20.glUseProgram;\n\npublic class Shader {\n    private String vertexShaderSrc;\n    private String fragmentShaderSrc;\n\n    private int vertexID, fragmentID, shaderProgram;\n\n    public Shader(String vertexShader, String fragmentShader, String root) {\n        this.vertexShaderSrc = getShader(vertexShader, root);\n        this.fragmentShaderSrc = getShader(fragmentShader, root);\n    }\n\n    public void compile() {\n        vertexID = glCreateShader(GL_VERTEX_SHADER);\n        glShaderSource(vertexID, vertexShaderSrc);\n        glCompileShader(vertexID);\n        int success = glGetShaderi(vertexID, GL_COMPILE_STATUS);\n        if (success == GL_FALSE) {\n            int len = glGetShaderi(vertexID, GL_INFO_LOG_LENGTH);\n            System.out.println(&quot;ERROR: Vertex shader compilation failed.&quot;);\n            System.out.println(glGetShaderInfoLog(vertexID, len));\n        }\n\n        fragmentID = glCreateShader(GL_FRAGMENT_SHADER);\n        glShaderSource(fragmentID, fragmentShaderSrc);\n        glCompileShader(fragmentID);\n        success = glGetShaderi(fragmentID, GL_COMPILE_STATUS);\n        if (success == GL_FALSE) {\n            int len = glGetShaderi(fragmentID, GL_INFO_LOG_LENGTH);\n            System.out.println(&quot;ERROR: Fragment shader compilation failed.&quot;);\n            System.out.println(glGetShaderInfoLog(fragmentID, len));\n        }\n    }\n\n    public void link() {\n        shaderProgram = glCreateProgram();\n        glAttachShader(shaderProgram, vertexID);\n        glAttachShader(shaderProgram, fragmentID);\n        glLinkProgram(shaderProgram);\n        int success = glGetProgrami(shaderProgram, GL_LINK_STATUS);\n        if (success == GL_FALSE) {\n            int len = glGetProgrami(shaderProgram, GL_INFO_LOG_LENGTH);\n            System.out.println(&quot;ERROR: Linking of shaders failed.&quot;);\n            System.out.println(glGetProgramInfoLog(shaderProgram, len));\n        }\n    }\n\n    public void use() {\n        glUseProgram(shaderProgram);\n    }\n\n    public void detach() {\n        glUseProgram(0);\n    }\n\n    private String getShader(String shaderName, String root) {\n        String data = &quot;&quot;;\n        File shaderFile = new File(root + shaderName);\n\n        try (Scanner reader = new Scanner(shaderFile)) {\n            while (reader.hasNextLine()) {\n                data += reader.nextLine();\n            }\n        } catch (FileNotFoundException e) {\n            System.out.println(&quot;An error occurred.&quot;);\n            e.printStackTrace();\n        }\n\n        return data;\n    }\n}\n</code></pre>\n<p>Vertex Shader</p>\n<pre><code>#version 330 core\n\nlayout (location=0) in vec3 pos;\n\nvoid main() {\n    gl_Position = vec4(pos, 1.0f);\n}\n</code></pre>\n<p>Fragment Shader</p>\n<pre><code>#version 330 core\n\nout vec4 color;\n\nvoid main() {\n    color = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n}\n</code></pre>\n<p>Window</p>\n<pre><code>import org.lwjgl.glfw.GLFWErrorCallback;\nimport org.lwjgl.opengl.GL;\n\nimport static org.lwjgl.glfw.Callbacks.glfwFreeCallbacks;\nimport static org.lwjgl.glfw.GLFW.*;\nimport static org.lwjgl.system.MemoryUtil.NULL;\n\npublic class Window {\n    private static Window instance;\n\n    private int width, height;\n    private String title;\n    private long window;\n\n    private Window(int width, int height, String title) {\n        this.width = width;\n        this.height = height;\n        this.title = title;\n    }\n\n    public static Window get(int width, int height, String title) {\n        if (instance == null) instance = new Window(width, height, title);\n\n        return instance;\n    }\n\n    public void init() {\n        GLFWErrorCallback.createPrint(System.err).set();\n\n        if (!glfwInit()) throw new IllegalStateException(&quot;Unable to initialize GLFW&quot;);\n\n        glfwDefaultWindowHints();\n        glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE);\n        glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);\n        glfwWindowHint(GLFW_MAXIMIZED, GLFW_TRUE);\n\n        window = glfwCreateWindow(width, height, title, NULL, NULL);\n        if (window == NULL) throw new RuntimeException(&quot;Failed to create the GLFW window&quot;);\n\n        glfwMakeContextCurrent(window);\n        glfwSwapInterval(1);\n        glfwShowWindow(window);\n\n        GL.createCapabilities();\n    }\n\n    public void destroy() {\n        glfwFreeCallbacks(window);\n        glfwDestroyWindow(window);\n\n        glfwTerminate();\n        glfwSetErrorCallback(null).free();\n    }\n\n    public long getWindow() {\n        return window;\n    }\n}\n</code></pre>\n<p>Game Loop\ninput, update, render, and cleanup methonds are called in a while loop every frame.</p>\n<pre><code>import static org.lwjgl.glfw.GLFW.glfwPollEvents;\nimport static org.lwjgl.glfw.GLFW.glfwSwapBuffers;\nimport static org.lwjgl.opengl.GL11.*;\n\npublic class GameLoop implements IGameLogic {\n    private static GameLoop instance;\n\n    private GameLoop() {\n\n    }\n\n    public static GameLoop get() {\n        if (instance == null) instance = new GameLoop();\n\n        return instance;\n    }\n\n    @Override\n    public void input() {\n        glfwPollEvents();\n    }\n\n    @Override\n    public void update(Scene scene, double deltaTime) {\n        scene.update();\n    }\n\n    @Override\n    public void render(Scene scene, Render render) {\n        glClearColor(1.0f, 1.0f, 1.0f, 0.0f);\n        render.render(scene);\n    }\n\n    @Override\n    public void cleanup(Window window) {\n        glClear(GL_COLOR_BUFFER_BIT);\n        glfwSwapBuffers(window.getWindow());\n    }\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}