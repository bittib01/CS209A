{
  "question": {
    "tags": [
      "java",
      "multithreading"
    ],
    "owner": {
      "account_id": 5333747,
      "reputation": 1923,
      "user_id": 4253536,
      "user_type": "registered",
      "accept_rate": 82,
      "profile_image": "https://i.sstatic.net/Bl265.jpg?s=256",
      "display_name": "Nick Allen",
      "link": "https://stackoverflow.com/users/4253536/nick-allen"
    },
    "is_answered": true,
    "view_count": 304,
    "accepted_answer_id": 78837789,
    "answer_count": 1,
    "score": 4,
    "last_activity_date": 1725065616,
    "creation_date": 1722916316,
    "last_edit_date": 1725065616,
    "question_id": 78837170,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78837170/java-22-0-2-virtualthread-calls-datagramsocket-receive-under-heavy-load-hangs-fo",
    "title": "Java 22.0.2 VirtualThread calls DatagramSocket.receive under heavy load hangs forever",
    "body": "<p>When I use following threadpool with heavy load.</p>\n<p><code>private final ScheduledExecutorService serverExecutor2 = Executors.newScheduledThreadPool(2000, Thread.ofVirtual().name(&quot;COAP-SERVER2-&quot;, 0).factory());</code></p>\n<p>it seems to stuck:\n<code>serverExecutor2=@ScheduledThreadPoolExecutor[java.util.concurrent.ScheduledThreadPoolExecutor@327e5be5[Running, pool size = 2000, active threads = 0, queued tasks = 60000, completed tasks = 97847]],</code></p>\n<p>All the correspond virtual thread is parking:</p>\n<pre><code>#75 &quot;COAP-SERVER2-5&quot; virtual\n      java.base/java.lang.VirtualThread.park(VirtualThread.java:592)\n      java.base/java.lang.System$2.parkVirtualThread(System.java:2639)\n      java.base/jdk.internal.misc.VirtualThreads.park(VirtualThreads.java:54)\n      java.base/java.util.concurrent.locks.LockSupport.park(LockSupport.java:369)\n      java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode.block(AbstractQueuedSynchronizer.java:519)\n      java.base/java.util.concurrent.ForkJoinPool.unmanagedBlock(ForkJoinPool.java:3780)\n      java.base/java.util.concurrent.ForkJoinPool.managedBlock(ForkJoinPool.java:3725)\n      java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1707)\n      java.base/java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1177)\n      java.base/java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:899)\n      java.base/java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1070)\n      java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)\n      java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)\n      java.base/java.lang.VirtualThread.run(VirtualThread.java:311)\n</code></pre>\n<p>And it seems to be caused by blocking of <code>VirtualThread-unparker</code> while it has a tons of tasks waiting:</p>\n<pre><code>&quot;VirtualThread-unparker&quot; #92 [593799] daemon prio=5 os_prio=0 cpu=2238.28ms elapsed=373.27s tid=0x00007f1b3002fd50 nid=593799 waiting on condition  [0x00007f1e6db43000]\n   java.lang.Thread.State: TIMED_WAITING (parking)\n        at jdk.internal.misc.Unsafe.park(java.base@22.0.2/Native Method)\n        - parking to wait for  &lt;0x00001000177791b8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n        at java.util.concurrent.locks.LockSupport.parkNanos(java.base@22.0.2/LockSupport.java:269)\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(java.base@22.0.2/AbstractQueuedSynchronizer.java:1758)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(java.base@22.0.2/ScheduledThreadPoolExecutor.java:1182)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(java.base@22.0.2/ScheduledThreadPoolExecutor.java:899)\n        at java.util.concurrent.ThreadPoolExecutor.getTask(java.base@22.0.2/ThreadPoolExecutor.java:1070)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@22.0.2/ThreadPoolExecutor.java:1130)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@22.0.2/ThreadPoolExecutor.java:642)\n        at java.lang.Thread.runWith(java.base@22.0.2/Thread.java:1583)\n        at java.lang.Thread.run(java.base@22.0.2/Thread.java:1570)\n        at jdk.internal.misc.InnocuousThread.run(java.base@22.0.2/InnocuousThread.java:186)\n\n   Locked ownable synchronizers:\n        - None\n</code></pre>\n<p>I used a debug tool to get the queue of unparker. it's obvious that task at queue top should run a long time ago (it's time is 84137649857516 while current time is 84707647860354):</p>\n<pre><code>[arthas@593599]$ ognl '@java.lang.VirtualThread@UNPARKER.toString()'\n@String[java.util.concurrent.ScheduledThreadPoolExecutor@154b1210[Running, pool size = 1, active threads = 0, queued tasks = 30027, completed tasks = 413674]]\n[arthas@593599]$ ognl '@System@nanoTime()'\n@Long[84707647860354]\n[arthas@593599]$ ognl '@java.lang.VirtualThread@UNPARKER.queue.peek()'\n@ScheduledFutureTask[\n    sequenceNumber=@Long[1227676],\n    time=**@Long[84137649857516]**,\n    period=@Long[0],\n    outerTask=@ScheduledFutureTask[java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask@5d021eb6[Not completed, task = java.util.concurrent.Executors$RunnableAdapter@7d5f12fb[Wrapped task = java.lang.VirtualThread$$Lambda/0x00007f1bf357cc70@56d5ca23]]],\n    heapIndex=@Integer[0],\n    this$0=@ScheduledThreadPoolExecutor[java.util.concurrent.ScheduledThreadPoolExecutor@154b1210[Running, pool size = 1, active threads = 0, queued tasks = 30027, completed tasks = 413674]],\n    state=@Integer[0],\n    NEW=@Integer[0],\n    COMPLETING=@Integer[1],\n    NORMAL=@Integer[2],\n    EXCEPTIONAL=@Integer[3],\n    CANCELLED=@Integer[4],\n    INTERRUPTING=@Integer[5],\n    INTERRUPTED=@Integer[6],\n    callable=@RunnableAdapter[java.util.concurrent.Executors$RunnableAdapter@7d5f12fb[Wrapped task = java.lang.VirtualThread$$Lambda/0x00007f1bf357cc70@56d5ca23]],\n    outcome=null,\n    runner=null,\n    waiters=null,\n    STATE=@FieldInstanceReadWrite[VarHandle[varType=int, coord=[class java.util.concurrent.FutureTask]]],\n    RUNNER=@FieldInstanceReadWrite[VarHandle[varType=java.lang.Thread, coord=[class java.util.concurrent.FutureTask]]],\n    WAITERS=@FieldInstanceReadWrite[VarHandle[varType=java.util.concurrent.FutureTask$WaitNode, coord=[class java.util.concurrent.FutureTask]]],\n</code></pre>\n<p>Am I doing something wrong or this is a bug of jdk or os?</p>\n<p>---- update ----</p>\n<p>I find out when using DatagramChannel to receive packet, the triggertime of scheudleTask can be negative:</p>\n<pre><code>ts=2024-08-06 14:32:36;thread_name=ForkJoinPool-1-worker-1;id=97;is_daemon=true;priority=5;TCCL=jdk.internal.loader.ClassLoaders$AppClassLoader@5c647e05\n    @java.util.concurrent.ScheduledThreadPoolExecutor.triggerTime() -- get a number close to Long.MAX_VALUE as param and output nagative number.\n        at java.util.concurrent.ScheduledThreadPoolExecutor.schedule(ScheduledThreadPoolExecutor.java:560)\n        at java.lang.VirtualThread.scheduleUnpark(VirtualThread.java:705)\n        at java.lang.VirtualThread.parkNanos(VirtualThread.java:632)\n        at java.lang.System$2.parkVirtualThread(System.java:2652)\n        at jdk.internal.misc.VirtualThreads.park(VirtualThreads.java:67)\n        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:408)\n        at sun.nio.ch.Poller.pollIndirect(Poller.java:137)\n        at sun.nio.ch.Poller.poll(Poller.java:102)\n        at sun.nio.ch.Poller.poll(Poller.java:87)\n        at sun.nio.ch.DatagramChannelImpl.park(DatagramChannelImpl.java:494)\n        at sun.nio.ch.DatagramChannelImpl.tryBlockingReceive(DatagramChannelImpl.java:762)\n        at sun.nio.ch.DatagramChannelImpl.blockingReceive(DatagramChannelImpl.java:692)   ---- if nanos is zero, nanos = Long.MAX_VALUE, which caused overflow at ScheduledThreadPoolExecutor.schedule \n        at sun.nio.ch.DatagramSocketAdaptor.receive(DatagramSocketAdaptor.java:204)\n        at java.net.DatagramSocket.receive(DatagramSocket.java:714)\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}