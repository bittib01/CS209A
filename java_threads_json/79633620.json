{
  "question": {
    "tags": [
      "java",
      "gradle",
      "architecture",
      "archunit"
    ],
    "owner": {
      "account_id": 4727352,
      "reputation": 1069,
      "user_id": 3823862,
      "user_type": "registered",
      "accept_rate": 100,
      "profile_image": "https://i.sstatic.net/tGs0Z.jpg?s=256",
      "display_name": "mirzak",
      "link": "https://stackoverflow.com/users/3823862/mirzak"
    },
    "is_answered": true,
    "view_count": 120,
    "accepted_answer_id": 79641361,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1748391902,
    "creation_date": 1747912336,
    "question_id": 79633620,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79633620/how-to-restrict-visibility-between-gradle-modules-in-a-modular-monolith-spring-b",
    "title": "How to restrict visibility between Gradle modules in a modular monolith Spring Boot application",
    "body": "<p>I'm working on a large modular monolith Spring Boot application (Java) that's structured into multiple Gradle build modules. Each module represents a specific domain (e.g., user management, notification handling), and contains its own internal business logic that ideally should remain private and inaccessible from other domains.</p>\n<p>To enforce this encapsulation, I've structured each domain module into two sub-modules: api and impl. Using Gradle plugins, I’ve defined rules such that only api sub-modules can be used as dependencies by other modules. This approach generally works, but it comes with two significant drawbacks:</p>\n<p><strong>Increased Module Count</strong>: Every domain now has two modules (api and impl), which essentially doubles the number of Gradle modules and increases project complexity.</p>\n<p><strong>Dependency Cycles</strong>: It’s still possible to accidentally introduce cycles—for example, moduleA:impl depending on moduleB:api, and moduleB:impl depending on moduleA:api. These cycles are hard to detect and can easily slip through code reviews.</p>\n<p>I’m looking for better tooling or practices to:</p>\n<ul>\n<li><p>Limit what can be accessed from a Gradle module (e.g., restrict\nvisibility to only specific packages or classes).</p>\n</li>\n<li><p>Prevent cross-module access to internal implementation code.</p>\n</li>\n<li><p>Possibly define and enforce these rules globally across the codebase.</p>\n</li>\n</ul>\n<p>One idea I’ve considered is using ArchUnit tests to assert architectural boundaries. For instance, moduleA could declare it’s only allowed to access the api package of moduleB. However, this raises a few concerns:</p>\n<p>Each module would need to explicitly define what it’s allowed to see, which could be error-prone if a developer forgets to add the appropriate rule.</p>\n<p>I'm unsure whether ArchUnit can be configured in a way that allows these rules to be enforced globally across the entire project.</p>\n<p>My question is:\nAre there tools, best practices, or Gradle configurations that can help enforce strict module boundaries and encapsulation in a multi-module Java project?</p>\n<p>Any advice or examples would be greatly appreciated.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}