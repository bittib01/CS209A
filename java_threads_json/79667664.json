{
  "question": {
    "tags": [
      "java",
      "telegram",
      "telegram-bot",
      "sha256"
    ],
    "owner": {
      "account_id": 3051666,
      "reputation": 844,
      "user_id": 3073031,
      "user_type": "registered",
      "accept_rate": 82,
      "profile_image": "https://www.gravatar.com/avatar/b709db0eb28121f035681e705b4b279e?s=256&d=identicon&r=PG",
      "display_name": "eccentricCoder",
      "link": "https://stackoverflow.com/users/3073031/eccentriccoder"
    },
    "is_answered": false,
    "view_count": 136,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1750498342,
    "creation_date": 1750078519,
    "last_edit_date": 1750406213,
    "question_id": 79667664,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79667664/telegram-login-payload-hash-verification-in-java",
    "title": "Telegram login payload hash verification in Java",
    "body": "<p>I am new to using Telegram and I'm trying to validate the hash provided by Telegram's initData for a webapp mini app (not the login widget) in Java, using the steps from the official Telegram documentation and this guide: <a href=\"https://medium.com/@aleksey-tumbaev/telegram-authentication-in-spring-boot-app-f5d2017619c3\" rel=\"nofollow noreferrer\">Telegram authentication in Spring Boot app</a></p>\n<p>Despite following all guidelines, the calculated hash never matches the hash received from Telegram. According to Telegram’s official documentation, the data-check string for login is constructed by concatenating all received fields (except the hash itself), sorted in alphabetical order, with each key= pair separated by a newline (\\n) core.telegram.org, which is what I have done.</p>\n<p>What I did:</p>\n<p>Using Telegram Mini App (WebApp) via <code>window.Telegram.WebApp.initDataUnsafe</code></p>\n<p>Hash received is something like:</p>\n<pre class=\"lang-json prettyprint-override\"><code>{\n  &quot;id&quot;: 785xxxxxx,\n  &quot;first_name&quot;: &quot;xxxxxxx&quot;,\n  &quot;last_name&quot;: &quot;xxxxxx&quot;,\n  &quot;language_code&quot;: &quot;en&quot;,\n  &quot;allows_write_to_pm&quot;: true,\n  &quot;photo_url&quot;: &quot;https://t.me/i/userpic/320/abc123.svg&quot;,\n  &quot;auth_date&quot;: &quot;1750072455&quot;,\n  &quot;hash&quot;: &quot;a55cdfdexxxxxx&quot;\n}\n</code></pre>\n<p>My Java validation code:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public static boolean isValid(Map&lt;String, String&gt; authData, String botToken) {\n    String receivedHash = authData.get(&quot;hash&quot;);\n    authData.remove(&quot;hash&quot;);\n\n    // Step 1: Build data_check_string\n    Map&lt;String, String&gt; sorted = new TreeMap&lt;&gt;(authData);\n    String dataCheckString = sorted.entrySet().stream()\n        .map(e -&gt; e.getKey() + &quot;=&quot; + e.getValue())\n        .collect(Collectors.joining(&quot;\\n&quot;));\n\n    try {\n        // Step 2: Generate secret key (HMAC_SHA256 of bot token using &quot;WebAppData&quot;)\n        Mac mac1 = Mac.getInstance(&quot;HmacSHA256&quot;);\n        mac1.init(new SecretKeySpec(&quot;WebAppData&quot;.getBytes(StandardCharsets.UTF_8), &quot;HmacSHA256&quot;));\n        byte[] secretKey = mac1.doFinal(botToken.getBytes(StandardCharsets.UTF_8));\n\n        // Step 3: HMAC_SHA256 of dataCheckString using secretKey\n        Mac mac2 = Mac.getInstance(&quot;HmacSHA256&quot;);\n        mac2.init(new SecretKeySpec(secretKey, &quot;HmacSHA256&quot;));\n        byte[] hmac = mac2.doFinal(dataCheckString.getBytes(StandardCharsets.UTF_8));\n\n        String calculatedHash = bytesToHex(hmac);\n\n        System.out.println(&quot;DataCheckString: &quot; + dataCheckString);\n        System.out.println(&quot;Expected Hash: &quot; + receivedHash);\n        System.out.println(&quot;Calculated Hash: &quot; + calculatedHash);\n\n        return calculatedHash.equalsIgnoreCase(receivedHash);\n    } catch (Exception e) {\n        e.printStackTrace();\n        return false;\n    }\n}\n</code></pre>\n<p>What I’ve tried:</p>\n<ul>\n<li><p>Ensured no extra newline or space characters in dataCheckString</p>\n</li>\n<li><p>Matched PHP logic (which works fine)</p>\n</li>\n<li><p>Used both SHA256(botToken) and HMAC_SHA256(botToken, &quot;WebAppData&quot;) as secret</p>\n</li>\n<li><p>Verified same ordering of keys and value formatting</p>\n</li>\n</ul>\n<p>Still facing:</p>\n<p>Mismatch between calculated hash and Telegram's received hash for every input.</p>\n<p>How can I succesfully verify the hash from <code>initDataUnsafe</code> in Java (with Telegram webapp)? Please help me identify why I am not able to produce the same hash value.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}