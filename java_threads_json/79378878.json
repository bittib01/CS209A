{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "micrometer",
      "spring-cache",
      "caffeine-cache"
    ],
    "owner": {
      "account_id": 14482834,
      "reputation": 5478,
      "user_id": 10461625,
      "user_type": "registered",
      "profile_image": "https://i.sstatic.net/fgo5D.jpg?s=256",
      "display_name": "PatPanda",
      "link": "https://stackoverflow.com/users/10461625/patpanda"
    },
    "is_answered": true,
    "view_count": 995,
    "accepted_answer_id": 79380440,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1737647691,
    "creation_date": 1737570601,
    "question_id": 79378878,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79378878/springboot-cache-caffeine-micrometer-how-to-configure-multiple-caches-in-on",
    "title": "SpringBoot cache + caffeine + micrometer, how to configure multiple caches in one application and with observability",
    "body": "<p>My use case is fairly simple. I have a SpringBoot app that does nothing but expose one rest endpoint.</p>\n<p>The rest endpoint does nothing but call two other external services I have no control over. The network calls are expensive (the processing on each of the third-party calls is above 5 seconds)</p>\n<p>The data returned by both third-party services does not often change either.</p>\n<p>Hence, I am thinking of using a cache. I.e., using SpringBoot, Spring cache, and Caffeine.</p>\n<p>Due to production requirements, I would also like to add observability using a micrometer to the cache. Being able to see cache miss. cache hit, is a must.</p>\n<p>To achieve the above, I tried to write the following code:</p>\n<pre><code>&lt;dependencies&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt;\n            &lt;artifactId&gt;caffeine&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.opentelemetry&lt;/groupId&gt;\n            &lt;artifactId&gt;opentelemetry-exporter-otlp&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.micrometer&lt;/groupId&gt;\n            &lt;artifactId&gt;micrometer-tracing-bridge-otel&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.micrometer&lt;/groupId&gt;\n            &lt;artifactId&gt;micrometer-registry-otlp&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n</code></pre>\n<pre><code>package controller;\n\nimport com.ivoronline.model.MedicalReportDto;\nimport com.ivoronline.model.PatientInfoDto;\nimport com.ivoronline.service.InfoService;\nimport com.ivoronline.service.PersonService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class MyController {\n\n  @Autowired\n  PersonService personService;\n\n  @Autowired\n  InfoService infoService;\n\n  @GetMapping(&quot;/getAll&quot;)\n  public String getAll(@RequestParam String name) {\n    PatientInfoDto person = personService.getPatientInfo(name);\n    MedicalReportDto medical = infoService.getLatestReport(name);\n    return person.toString() + medical.toString();\n  }\n\n}\n\n</code></pre>\n<pre><code>package service;\n\nimport com.ivoronline.model.MedicalReportDto;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.client.RestClient;\n\n@Service\npublic class InfoService {\n\n    private final RestClient restClient;\n\n    public InfoService(RestClient.Builder restClientBuilder) {\n        this.restClient = restClientBuilder.build();\n    }\n\n    @Cacheable(cacheNames = &quot;ReportInfo&quot;)\n    public MedicalReportDto getLatestReport(String PatientId) {\n        System.out.println(&quot;Fetching Latest Report of Patient (but please apply cache here to see only one call per ID) : {}&quot; + PatientId);\n        ResponseEntity&lt;String&gt; response = this.restClient.get()\n                .uri(&quot;http://localhost:8083/report/getreport/&quot; + PatientId)\n                .retrieve()\n                .toEntity(String.class);\n        System.out.println(response.getBody());\n        return new MedicalReportDto(response.getBody());\n    }\n\n}\n\n</code></pre>\n<pre><code>package service;\n\nimport com.ivoronline.model.PatientInfoDto;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.client.RestClient;\n\nimport java.util.Map;\n\n@Service\npublic class PersonService {\n\n  private final RestClient restClient;\n\n  public PersonService(RestClient.Builder restClientBuilder) {\n    this.restClient = restClientBuilder.build();\n  }\n\n  @Cacheable(cacheNames = &quot;PatientInfo&quot;)\n  public PatientInfoDto getPatientInfo(String BedDeptNum) {\n    System.out.println(&quot;Fetching Patient Info (but please apply cache here to see only one call per ID): {}&quot; + BedDeptNum);\n    ResponseEntity&lt;String&gt; response = this.restClient.post()\n            .uri(&quot;http://localhost:8888/patient/&quot;)\n            .body(Map.of(&quot;BedDeptNum&quot;, BedDeptNum))\n            .retrieve()\n            .toEntity(String.class);\n    System.out.println(response.getBody());\n    return new PatientInfoDto(response.getBody());\n  }\n\n}\n\n</code></pre>\n<p>Each cache has its own configuration (time, size, eviction).</p>\n<p>Each cache needs to be observed.</p>\n<pre><code>mport com.github.benmanes.caffeine.cache.Caffeine;\nimport io.micrometer.core.instrument.MeterRegistry;\nimport io.micrometer.core.instrument.binder.cache.CaffeineCacheMetrics;\nimport org.springframework.cache.CacheManager;\nimport org.springframework.cache.annotation.EnableCaching;\nimport org.springframework.cache.caffeine.CaffeineCache;\nimport org.springframework.cache.caffeine.CaffeineCacheManager;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\n@Configuration\n@EnableCaching\npublic class CachingConfig {\n\n  @Bean\n  public CacheManager cacheManager(MeterRegistry registry) {\n    // How to construct caffeine manager for each of the two below caches, with observability?\n    return manager;\n\n  }\n\n  private CaffeineCache reportCache() {\n    return new CaffeineCache(&quot;ReportInfo&quot;, Caffeine.newBuilder()\n            .expireAfterWrite(, TimeUnit.MINUTES) // some custom time\n            .maximumSize() // some custom size\n            .recordStats()\n            .build());\n  }\n\n  private CaffeineCache patientCache() {\n    return new CaffeineCache(&quot;PatientInfo&quot;, Caffeine.newBuilder()\n            .expireAfterWrite(, TimeUnit.MINUTES) // some other custom time\n            .maximumSize() // some other custom size\n            .recordStats()\n            .build());\n  }\n\n}\n\n</code></pre>\n<p>Issue:</p>\n<p>What to put in the configuration.java file so:</p>\n<ul>\n<li><p>Both caches have their own metrics</p>\n</li>\n<li><p>each of the cache has its own configuration</p>\n</li>\n</ul>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}