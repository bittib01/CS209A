{
  "question": {
    "tags": [
      "java",
      "spring",
      "spring-boot",
      "hibernate"
    ],
    "owner": {
      "account_id": 26480257,
      "reputation": 21,
      "user_id": 20119601,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/4938befe9ce7ffeac3a1fa89cb327594?s=256&d=identicon&r=PG",
      "display_name": "AbdulmalikAlayande",
      "link": "https://stackoverflow.com/users/20119601/abdulmalikalayande"
    },
    "is_answered": false,
    "view_count": 457,
    "answer_count": 3,
    "score": 2,
    "last_activity_date": 1738182623,
    "creation_date": 1736065124,
    "last_edit_date": 1736252318,
    "question_id": 79330401,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79330401/spring-boot-org-hibernate-staleobjectstateexception-row-was-updated-or-delete",
    "title": "Spring Boot: org.hibernate.StaleObjectStateException - Row was updated or deleted by another transaction",
    "body": "<p>I am encountering an <strong>ObjectOptimisticLockingFailureException</strong> which was caused by a <strong>StaleObjectStateException</strong> when trying to save a FlightInstance entity in my Spring Boot application. The full stack trace is as follows:</p>\n<pre><code>rg.springframework.orm.ObjectOptimisticLockingFailureException: Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect): [app.bola.flywell.data.model.flight.FlightInstance#16f60701-d478-45ca-bbd4-59fc53aa4ca3]\n\n    at org.springframework.orm.jpa.vendor.HibernateJpaDialect.convertHibernateAccessException(HibernateJpaDialect.java:325)\n    at org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:244)\n    at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.translateExceptionIfPossible(AbstractEntityManagerFactoryBean.java:560)\n    at org.springframework.dao.support.ChainedPersistenceExceptionTranslator.translateExceptionIfPossible(ChainedPersistenceExceptionTranslator.java:61)\n    at org.springframework.dao.support.DataAccessUtils.translateIfNecessary(DataAccessUtils.java:343)\n    at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:160)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)\n    at org.springframework.data.jpa.repository.support.CrudMethodMetadataPostProcessor$CrudMethodMetadataPopulatingMethodInterceptor.invoke(CrudMethodMetadataPostProcessor.java:165)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)\n    at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:223)\n    at jdk.proxy2/jdk.proxy2.$Proxy193.save(Unknown Source)\n    at app.bola.flywell.services.flightservice.FlyWellFlightInstanceService.createNew(FlyWellFlightInstanceService.java:52)\n    at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)\n    at java.base/java.lang.reflect.Method.invoke(Method.java:580)\n    at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:359)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:196)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\n    at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:380)\n    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)\n    at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:727)\n    at app.bola.flywell.services.flightservice.FlyWellFlightInstanceService$$SpringCGLIB$$0.createNew(&lt;generated&gt;)\n    at app.bola.flywell.services.flightservice.FlightInstanceServiceTest.createNewFlightInstance_NewFlightIsCreatedTest(FlightInstanceServiceTest.java:41)\n    at java.base/java.lang.reflect.Method.invoke(Method.java:580)\n    at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)\n    at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)\nCaused by: org.hibernate.StaleObjectStateException: Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect): [app.bola.flywell.data.model.flight.FlightInstance#16f60701-d478-45ca-bbd4-59fc53aa4ca3]\n    at org.hibernate.event.internal.DefaultMergeEventListener.entityIsDetached(DefaultMergeEventListener.java:426)\n    at org.hibernate.event.internal.DefaultMergeEventListener.merge(DefaultMergeEventListener.java:214)\n    at org.hibernate.event.internal.DefaultMergeEventListener.doMerge(DefaultMergeEventListener.java:152)\n    at org.hibernate.event.internal.DefaultMergeEventListener.onMerge(DefaultMergeEventListener.java:136)\n    at org.hibernate.event.service.internal.EventListenerGroupImpl.fireEventOnEachListener(EventListenerGroupImpl.java:138)\n    at org.hibernate.internal.SessionImpl.fireMerge(SessionImpl.java:875)\n    at org.hibernate.internal.SessionImpl.merge(SessionImpl.java:846)\n    at org.hibernate.engine.spi.CascadingActions$6.cascade(CascadingActions.java:258)\n    at org.hibernate.engine.spi.CascadingActions$6.cascade(CascadingActions.java:248)\n    at org.hibernate.engine.internal.Cascade.cascadeToOne(Cascade.java:570)\n    at org.hibernate.engine.internal.Cascade.cascadeAssociation(Cascade.java:492)\n    at org.hibernate.engine.internal.Cascade.cascadeProperty(Cascade.java:253)\n    at org.hibernate.engine.internal.Cascade.cascadeCollectionElements(Cascade.java:604)\n    at org.hibernate.engine.internal.Cascade.cascadeCollection(Cascade.java:534)\n    at org.hibernate.engine.internal.Cascade.cascadeAssociation(Cascade.java:495)\n    at org.hibernate.engine.internal.Cascade.cascadeProperty(Cascade.java:253)\n    at org.hibernate.engine.internal.Cascade.cascade(Cascade.java:192)\n    at org.hibernate.event.internal.DefaultMergeEventListener.cascadeOnMerge(DefaultMergeEventListener.java:667)\n    at org.hibernate.event.internal.DefaultMergeEventListener.entityIsPersistent(DefaultMergeEventListener.java:285)\n    at org.hibernate.event.internal.DefaultMergeEventListener.merge(DefaultMergeEventListener.java:220)\n    at org.hibernate.event.internal.DefaultMergeEventListener.doMerge(DefaultMergeEventListener.java:152)\n    at org.hibernate.event.internal.DefaultMergeEventListener.onMerge(DefaultMergeEventListener.java:136)\n    at org.hibernate.event.internal.DefaultMergeEventListener.onMerge(DefaultMergeEventListener.java:89)\n    at org.hibernate.event.service.internal.EventListenerGroupImpl.fireEventOnEachListener(EventListenerGroupImpl.java:127)\n    at org.hibernate.internal.SessionImpl.fireMerge(SessionImpl.java:854)\n    at org.hibernate.internal.SessionImpl.merge(SessionImpl.java:840)\n    at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)\n    at java.base/java.lang.reflect.Method.invoke(Method.java:580)\n    at org.springframework.orm.jpa.SharedEntityManagerCreator$SharedEntityManagerInvocationHandler.invoke(SharedEntityManagerCreator.java:320)\n    at jdk.proxy2/jdk.proxy2.$Proxy181.merge(Unknown Source)\n    at org.springframework.data.jpa.repository.support.SimpleJpaRepository.save(SimpleJpaRepository.java:630)\n    at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)\n    at java.base/java.lang.reflect.Method.invoke(Method.java:580)\n    at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:359)\n    at org.springframework.data.repository.core.support.RepositoryMethodInvoker$RepositoryFragmentMethodInvoker.lambda$new$0(RepositoryMethodInvoker.java:277)\n    at org.springframework.data.repository.core.support.RepositoryMethodInvoker.doInvoke(RepositoryMethodInvoker.java:170)\n    at org.springframework.data.repository.core.support.RepositoryMethodInvoker.invoke(RepositoryMethodInvoker.java:158)\n    at org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments.invoke(RepositoryComposition.java:515)\n    at org.springframework.data.repository.core.support.RepositoryComposition.invoke(RepositoryComposition.java:284)\n    at org.springframework.data.repository.core.support.RepositoryFactorySupport$ImplementationMethodExecutionInterceptor.invoke(RepositoryFactorySupport.java:752)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)\n    at org.springframework.data.repository.core.support.QueryExecutorMethodInterceptor.doInvoke(QueryExecutorMethodInterceptor.java:174)\n    at org.springframework.data.repository.core.support.QueryExecutorMethodInterceptor.invoke(QueryExecutorMethodInterceptor.java:149)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)\n    at org.springframework.data.projection.DefaultMethodInvokingMethodInterceptor.invoke(DefaultMethodInvokingMethodInterceptor.java:69)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)\n    at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:380)\n    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)\n    at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:138)\n    ... 20 more\n</code></pre>\n<p><strong>My Setup</strong></p>\n<p>I am using Spring Boot with the following dependencies:</p>\n<pre><code>spring-boot-starter-data-jpa\nhibernate-core\n</code></pre>\n<p>The <strong>FlightInstance</strong> entity inherits from a parent class called FlyWellModel. Here’s the relevant code:</p>\n<p><strong>Parent Class (FlyWellModel)</strong>: The base class for all models in the system</p>\n<pre><code>public class FlyWellModel {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.UUID)\n    private String id;\n    \n    @Column(nullable = false, unique = true)\n    private String publicId;\n\n\n    @PrePersist\n    protected void onCreate() {\n        if (publicId == null || publicId.isEmpty()) {\n            publicId = UUID.randomUUID().toString();\n        }\n    }\n\n\n    @Override\n    public String toString() {\n        return MoreObjects.toStringHelper(this)\n                .add(&quot;id&quot;, id)\n                .add(&quot;publicId&quot;, publicId)\n                .toString();\n    }\n}\n</code></pre>\n<p><strong>Child Class (FlightInstance)</strong>: The <strong>FlightInstance</strong> entity has a <strong>publicId</strong> field that is populated using a <strong>@PrePersist</strong> annotation in the <strong>onCreate</strong> method from the base class <strong>FlyWellModel</strong></p>\n<pre><code>@Entity\n@Table(name = &quot;flight_instance&quot;)\npublic class FlightInstance extends FlyWellModel {\n\n    @Column(nullable = false)\n    @FlightNumberSequence(name = &quot;flight_number_sequence&quot;, startWith = 1000, incrementBy = 3) &lt;---- Custom Annotation\n    private String flightNumber;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    @ToString.Exclude\n    private Flight flight;\n    // Other specific fields\n}\n</code></pre>\n<p>When the save method is invoked on the <strong>FlightInstance</strong> entity, the <strong>@PrePersist</strong> hook generates a value for the <strong>publicId</strong>, modifying the entity before the transaction completes. I suspect this modification might be causing Hibernate to treat the entity as &quot;dirty&quot;, leading to the exception.</p>\n<p>Interestingly, a similar setup works perfectly for the <strong>Flight</strong> entity, which is structured as follows:</p>\n<pre><code>@Entity\npublic class Flight extends FlyWellModel {\n\n    private long duration;\n    private String arrivalCity;\n    private String departureCity;\n    private String displayImage;\n\n    @OneToOne(cascade = ALL)\n    private Airport departureAirport;\n\n    @OneToOne(cascade = ALL)\n    private Airport arrivalAirport;\n\n    @OneToMany(mappedBy = &quot;flight&quot;, cascade = ALL, fetch = EAGER)\n    private Set&lt;FlightInstance&gt; instances = new LinkedHashSet&lt;&gt;();\n\n\n    public FlightInstance addFlightInstance(FlightInstance newInstance){\n        newInstance.setFlight(this);\n        instances.add(newInstance);\n        return newInstance;\n    }\n\n}\n</code></pre>\n<p><strong>The Problem</strong></p>\n<p>The exception occurs when calling the save method on the <strong>FlightInstanceRepository</strong> in the service layer:</p>\n<p><strong>Service Method:</strong></p>\n<pre><code>@Service\npublic class FlyWellFlightInstanceService {\n\n    @Autowired\n    private FlightInstanceRepository flightInstanceRepository;\n\n\n    @Override\n    @Transactional\n    @Retryable(retryFor = ObjectOptimisticLockingFailureException.class, maxAttempts = 5)\n    public FlightInstanceResponse createNew(FlightInstanceRequest request) {\n\n        Flight flight = flightRepository.findByPublicId(request.getFlightId())\n                .orElseThrow(() -&gt; new EntityNotFoundException(Constants.ENTITY_NOT_FOUND.formatted(&quot;Flight&quot;)));\n\n        FlightInstance mappedInstance = mapper.map(request, FlightInstance.class);\n        mappedInstance.setFlight(flight);\n        mappedInstance.setStatus(SCHEDULED);\n        mappedInstance.setFlightSeat(new ArrayList&lt;&gt;());\n\n        FlightInstance savedInstance = flight.addFlightInstance(mappedInstance);\n\n        flightRepository.save(flight);\n        return toResponse(savedInstance);\n    }\n\n\n    private FlightInstanceResponse toResponse(FlightInstance instance) {\n        \n        FlightInstanceResponse response = mapper.map(instance, FlightInstanceResponse.class);\n        response.setArrivalAirportName(instance.getFlight().getArrivalAirport().getName());\n        response.setDepartureAirportName(instance.getFlight().getDepartureAirport().getName());\n        \n        return response;\n    }\n</code></pre>\n<p><strong>Observations</strong></p>\n<ol>\n<li><strong>@PrePersist</strong> on FlightInstance: The publicId field is populated at the time of persistence, which modifies the entity during the save operation.</li>\n<li>Thread Interference: I suspect there might be multiple threads at play. While one thread modifies the Flight entity, another thread might be modifying its associated FlightInstance entity simultaneously, causing a conflict.</li>\n</ol>\n<p><strong>What I’ve Tried So Far</strong></p>\n<ol>\n<li><p>I suspect the issue could be related to the publicId field inherited from the FlyWellModel class, particularly the @PrePersist hook. To debug further, I made several adjustments:</p>\n</li>\n<li><p>Detached the FlightInstance Model: I completely removed the relationship between the FlightInstance model and FlyWellModel, ensuring that the FlightInstance model no longer inherits from FlyWellModel and has no publicId field. However, I still encountered the same error.</p>\n</li>\n<li><p>Renamed the Entity: Thinking the issue might be due to conflicting names between <strong>Flight</strong> and FlightInstance, I renamed FlightInstance to Instance but still faced the same error.</p>\n</li>\n<li><p>Disabled <strong>@PrePersist</strong>: I commented out the <strong>onCreate()</strong> method annotated with <strong>@PrePersist</strong> in the <strong>FlyWell</strong> model and I took the method to the <strong>Flight</strong> model, but the problem persisted.</p>\n</li>\n</ol>\n<p>These changes led me to believe the issue might not be directly tied to the <strong>publicId</strong> field or the <strong>@PrePersist</strong> logic. Now I’m even more confused, as these modifications didn’t resolve the error. What could be the underlying cause, and how do I approach solving this?</p>\n<p><strong>My Question</strong></p>\n<ol>\n<li>Is the <strong>@PrePersist</strong> modification to the <strong>publicId</strong> field causing the StaleObjectStateException? If so, what is the best way to handle this?</li>\n<li>Could multiple threads be modifying the FlightInstance entity simultaneously, and how can I verify or mitigate this in a Spring Boot + Hibernate setup?</li>\n<li>Why does the Flight entity work without any issues, while the <strong>FlightInstance</strong> entity throws this exception under similar conditions?\n4.How can I resolve this issue so that the <strong>FlightInstance</strong> entity is saved correctly without encountering <strong>StaleObjectStateException</strong></li>\n</ol>\n<p>Any guidance or insights would be greatly appreciated! Thank you!</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}