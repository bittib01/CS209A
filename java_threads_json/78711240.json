{
  "question": {
    "tags": [
      "java",
      "spring",
      "oauth-2.0",
      "keycloak"
    ],
    "owner": {
      "account_id": 15743792,
      "reputation": 136,
      "user_id": 11360373,
      "user_type": "registered",
      "profile_image": "https://lh6.googleusercontent.com/-9_X2XHass7I/AAAAAAAAAAI/AAAAAAAAiG8/WFxLMhhIwII/s256-rj/photo.jpg",
      "display_name": "Kerim Nurikic",
      "link": "https://stackoverflow.com/users/11360373/kerim-nurikic"
    },
    "is_answered": true,
    "view_count": 884,
    "accepted_answer_id": 78712754,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1762679031,
    "creation_date": 1720179361,
    "question_id": 78711240,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78711240/role-based-authentication-not-working-with-keycloak-and-java-spring",
    "title": "Role-based authentication not working with Keycloak and Java Spring",
    "body": "<p>I have been following this tutorial: <a href=\"https://www.baeldung.com/spring-boot-keycloak\" rel=\"nofollow noreferrer\">https://www.baeldung.com/spring-boot-keycloak</a> to set up my Spring app with Keycloak. The authentication works normally, but when I want to add role-based authentication, for example</p>\n<pre><code>.requestMatchers(new AntPathRequestMatcher(&quot;/api/v1/user/**&quot;)).hasRole(&quot;user&quot;)\n</code></pre>\n<p>I always get the following error</p>\n<pre><code>Bearer error=&quot;insufficient_scope&quot;, error_description=&quot;The request requires higher privileges than provided by the access token.&quot;, error_uri=&quot;https://tools.ietf.org/html/rfc6750#section-3.1&quot;\n</code></pre>\n<p>I have checked the authorites using</p>\n<pre><code>SecurityContextHolder.getContext().getAuthentication().getAuthorities();\n</code></pre>\n<p>and it only has ones that have the <code>SCOPE_</code> prefix.\nI have also checked the token and it returns this correctly</p>\n<pre><code> &quot;realm_access&quot;: {\n    &quot;roles&quot;: [\n      &quot;offline_access&quot;,\n      &quot;uma_authorization&quot;,\n      &quot;default-master-realm&quot;,\n      &quot;user&quot;\n    ]\n  },\n</code></pre>\n<p>besides the other fields.</p>\n<p>This is my <code>KeycloakConfig</code> class:</p>\n<pre><code>package com.motus.core.shared.config.security;\n\nimport com.motus.auth.constants.Authority;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.Customizer;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.authority.mapping.GrantedAuthoritiesMapper;\nimport org.springframework.security.core.session.SessionRegistry;\nimport org.springframework.security.core.session.SessionRegistryImpl;\nimport org.springframework.security.oauth2.core.oidc.user.OidcUserAuthority;\nimport org.springframework.security.oauth2.core.user.OAuth2UserAuthority;\nimport org.springframework.security.web.SecurityFilterChain;\nimport org.springframework.security.web.authentication.session.RegisterSessionAuthenticationStrategy;\nimport org.springframework.security.web.authentication.session.SessionAuthenticationStrategy;\nimport org.springframework.security.web.session.HttpSessionEventPublisher;\nimport org.springframework.security.web.util.matcher.AntPathRequestMatcher;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n@Slf4j\n@EnableWebSecurity\n@Configuration\npublic class KeycloakConfig {\n\n    private static final String GROUPS = &quot;groups&quot;;\n    private static final String REALM_ACCESS_CLAIM = &quot;realm_access&quot;;\n    private static final String ROLES_CLAIM = &quot;roles&quot;;\n\n    @Bean\n    public SessionRegistry sessionRegistry() {\n        return new SessionRegistryImpl();\n    }\n\n    @Bean\n    protected SessionAuthenticationStrategy sessionAuthenticationStrategy() {\n        return new RegisterSessionAuthenticationStrategy(sessionRegistry());\n    }\n\n    @Bean\n    public HttpSessionEventPublisher httpSessionEventPublisher() {\n        return new HttpSessionEventPublisher();\n    }\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http, KeycloakLogoutHandler keycloakLogoutHandler) throws Exception {\n        http.authorizeHttpRequests(auth -&gt; auth\n                .requestMatchers(new AntPathRequestMatcher(&quot;/api/v1/public/**&quot;)).permitAll()\n                .requestMatchers(new AntPathRequestMatcher(&quot;/api/v1/auth/**&quot;)).permitAll()\n                .requestMatchers(new AntPathRequestMatcher(&quot;/api/v1/admin/**&quot;)).hasRole(&quot;admin&quot;)\n                .requestMatchers(new AntPathRequestMatcher(&quot;/api/v1/user/**&quot;)).hasRole(&quot;user&quot;)\n                .anyRequest().authenticated()\n        );\n        http.oauth2ResourceServer(oauth2 -&gt; oauth2\n                .jwt(Customizer.withDefaults()));\n        http.oauth2Login(Customizer.withDefaults())\n                .logout(logout -&gt; logout.addLogoutHandler(keycloakLogoutHandler).logoutSuccessUrl(&quot;/&quot;));\n\n        http.csrf(AbstractHttpConfigurer::disable);\n        http.cors(Customizer.withDefaults());\n\n        return http.build();\n    }\n\n    @Bean\n    public GrantedAuthoritiesMapper userAuthoritiesMapperForKeycloak() {\n        return authorities -&gt; {\n            Set&lt;GrantedAuthority&gt; mappedAuthorities = new HashSet&lt;&gt;();\n            var authority = authorities.iterator().next();\n            boolean isOidc = authority instanceof OidcUserAuthority;\n\n            if (isOidc) {\n                var oidcUserAuthority = (OidcUserAuthority) authority;\n                var userInfo = oidcUserAuthority.getUserInfo();\n\n                if (userInfo.hasClaim(REALM_ACCESS_CLAIM)) {\n                    var realmAccess = userInfo.getClaimAsMap(REALM_ACCESS_CLAIM);\n                    var roles = (Collection&lt;String&gt;) realmAccess.get(ROLES_CLAIM);\n                    mappedAuthorities.addAll(generateAuthoritiesFromClaim(roles));\n                } else if (userInfo.hasClaim(GROUPS)) {\n                    Collection&lt;String&gt; roles = userInfo.getClaim(\n                            GROUPS);\n                    mappedAuthorities.addAll(generateAuthoritiesFromClaim(roles));\n                }\n            } else {\n                var oauth2UserAuthority = (OAuth2UserAuthority) authority;\n                Map&lt;String, Object&gt; userAttributes = oauth2UserAuthority.getAttributes();\n\n                if (userAttributes.containsKey(REALM_ACCESS_CLAIM)) {\n                    Map&lt;String, Object&gt; realmAccess = (Map&lt;String, Object&gt;) userAttributes.get(\n                            REALM_ACCESS_CLAIM);\n                    Collection&lt;String&gt; roles = (Collection&lt;String&gt;) realmAccess.get(ROLES_CLAIM);\n                    mappedAuthorities.addAll(generateAuthoritiesFromClaim(roles));\n                }\n            }\n            return mappedAuthorities;\n        };\n    }\n\n    Collection&lt;GrantedAuthority&gt; generateAuthoritiesFromClaim(Collection&lt;String&gt; roles) {\n        return roles.stream().map(role -&gt; new SimpleGrantedAuthority(&quot;ROLE_&quot; + role)).collect(\n                Collectors.toList());\n    }\n}\n</code></pre>\n<p>It looks like the GrantedAuthoritesMapper is not being invoked, do you know why?\nHere is what I added in my <code>pom.xml</code>:</p>\n<pre><code>&lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-oauth2-client&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-oauth2-resource-server&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>and here is what I added in my application.properties:</p>\n<pre><code>spring.security.oauth2.client.registration.keycloak.client-id=${KEYCLOAK_CLIENT_ID:test-backend}\nspring.security.oauth2.client.registration.keycloak.authorization-grant-type=${KEYCLOAK_AUTHORIZATION_GRANT_TYPE:password}\nspring.security.oauth2.client.registration.keycloak.scope=${KEYCLOAK_SCOPE:openid}\nspring.security.oauth2.client.provider.keycloak.issuer-uri=${KEYCLOAK_ISSUER_URI:http://localhost:8080/realms/master}\nspring.security.oauth2.client.provider.keycloak.user-name-attribute=${KEYCLOAK_USER_NAME_ATTRIBUTE:username}\nspring.security.oauth2.resourceserver.jwt.issuer-uri=${KEYCLOAK_RESOURCE_SERVER_JWT_ISSUER_URI:http://localhost:8080/realms/master}\n</code></pre>\n<p>I obtain the token using <code>http://localhost:8080/realms/master/protocol/openid-connect/token</code>\nThen I send the request to my app with the obtained token, and I always get the error mentioned above. Does anyone know how can I fix this?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}