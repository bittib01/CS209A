{
  "question": {
    "tags": [
      "java",
      "encryption",
      "rsa",
      "private-key"
    ],
    "owner": {
      "account_id": 4171143,
      "reputation": 141,
      "user_id": 3418882,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/35da37715b3ce57f296478693686accf?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "rsenden",
      "link": "https://stackoverflow.com/users/3418882/rsenden"
    },
    "is_answered": true,
    "view_count": 1106,
    "accepted_answer_id": 78377851,
    "answer_count": 2,
    "score": 0,
    "last_activity_date": 1714525752,
    "creation_date": 1713879023,
    "last_edit_date": 1713944692,
    "question_id": 78372763,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78372763/java-21-generate-encrypted-private-rsa-key-in-pem-format",
    "title": "Java 21: Generate encrypted private RSA key in PEM format",
    "body": "<p>I'd like to generate an RSA key pair in Java 21 using plain Java API (without using BouncyCastle or similar libraries). The private key should be processable by both OpenSSL and Java. Based on Java limitations, this means that I'd like to generate an AES-encrypted private key.</p>\n<p>The code below works fine for generating unencrypted private keys, but despite many Google &amp; StackOverflow searches, I haven't been able to successfully implement the <code>pemEncrypt</code> method. I'm getting somewhat lost in the many algorithms and formats; maybe I need to do extra work for generating a proper ASN.1 data structure?</p>\n<pre class=\"lang-java prettyprint-override\"><code>   @RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n    public static final class KPGenerator {\n        private final char[] passPhrase;\n        \n        @SneakyThrows\n        public final KeyPair generate() {\n            KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;RSA&quot;);\n            kpg.initialize(2048); \n            return kpg.generateKeyPair();\n        }\n        \n        @SneakyThrows\n        public final void writePem(Path privateKeyPath, Path publicKeyPath) {\n            var kp = generate();\n            writePem(&quot;PRIVATE KEY&quot;, kp.getPrivate().getEncoded(), privateKeyPath);\n            writePem(&quot;PUBLIC KEY&quot;, kp.getPublic().getEncoded(), publicKeyPath);\n        }\n        \n        @SneakyThrows\n        private final void writePem(String type, byte[] key, Path path) {\n            var pemString = asPem(type, key);\n            Files.writeString(path, pemString, StandardOpenOption.CREATE_NEW);\n        }\n        \n        private final String asPem(String type, byte[] key) {\n            if ( &quot;PRIVATE KEY&quot;.equals(type) &amp;&amp; passPhrase!=null ) {\n                return asPem(&quot;ENCRYPTED PRIVATE KEY&quot;, pemEncrypt(key, passPhrase));\n            }\n            return &quot;-----BEGIN &quot;+type+&quot;-----\\n&quot;\n                    + Base64.getMimeEncoder().encodeToString(key)\n                    + &quot;\\n-----END &quot;+type+&quot;-----&quot;;\n        }\n        \n        @SneakyThrows\n        private static final byte[] pemEncrypt(byte[] privateKey, char[] passPhrase) {\n           ???\n        }\n}\n</code></pre>\n<p>Below are some examples of <code>pemEncrypt</code> implementations that I've tried.</p>\n<p><strong>Method 1</strong></p>\n<p>Based on <a href=\"https://medium.com/@patc888/decrypt-openssl-encrypted-data-in-java-4c31983afe19\" rel=\"nofollow noreferrer\">https://medium.com/@patc888/decrypt-openssl-encrypted-data-in-java-4c31983afe19</a></p>\n<p>Problem: <code>openssl asn1parse -in privatekey.pem</code> throws an error: <code>4047F272597F0000:error:0680009B:asn1 encoding routines:ASN1_get_object:too long:../crypto/asn1/asn1_lib.c:95</code></p>\n<p>As written in the comments, this approach is wrong.</p>\n<pre class=\"lang-java prettyprint-override\"><code>        @SneakyThrows\n        private static final byte[] pemEncrypt(byte[] privateKey, char[] passPhrase) {\n            var salt = createSalt();\n            byte[] passAndSalt = ArrayUtils.addAll(toBytes(passPhrase), salt);\n            MessageDigest md = MessageDigest.getInstance(&quot;SHA-256&quot;);\n            byte[] key = md.digest(passAndSalt);\n            SecretKeySpec secretKey = new SecretKeySpec(key, &quot;AES&quot;);\n            md.reset();\n            byte[] iv = Arrays.copyOfRange(md.digest(ArrayUtils.addAll(key, passAndSalt)), 0, 16);\n            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(iv));\n            byte[] encryptedSecretKey = cipher.doFinal(privateKey);\n            try ( var bos = new ByteArrayOutputStream(); ) {\n                bos.writeBytes(&quot;Salted__&quot;.getBytes(StandardCharsets.US_ASCII));\n                bos.writeBytes(salt);\n                bos.writeBytes(encryptedSecretKey);\n                return bos.toByteArray();\n            }\n        }\n        private static final byte[] toBytes(char[] chars) {\n            CharBuffer charBuffer = CharBuffer.wrap(chars);\n            ByteBuffer byteBuffer = Charset.forName(&quot;UTF-8&quot;).encode(charBuffer);\n            byte[] bytes = Arrays.copyOfRange(byteBuffer.array(),\n                      byteBuffer.position(), byteBuffer.limit());\n            Arrays.fill(byteBuffer.array(), (byte) 0); // clear sensitive data\n            return bytes;\n        }\n        private static final byte[] createSalt() {\n            final byte[] salt = new byte[16];\n            new SecureRandom().nextBytes(salt);\n            return salt;\n        }\n</code></pre>\n<p>(sample output removed, not relevant as this approach is wrong)</p>\n<p><strong>Method 2</strong></p>\n<p>Problem: Similar OpenSSL error as before: <code>40B70A48E47F0000:error:0680007B:asn1 encoding routines:ASN1_get_object:header too long:../crypto/asn1/asn1_lib.c:105:</code></p>\n<p>As written in the comments, this approach is wrong.</p>\n<pre class=\"lang-java prettyprint-override\"><code>        @SneakyThrows\n        private static final byte[] pemEncrypt(byte[] key, char[] passPhrase) {\n            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);\n            cipher.init(Cipher.ENCRYPT_MODE, createKey(passPhrase), createIv());\n            return cipher.doFinal(key);\n        }\n        @SneakyThrows\n        private static final SecretKey createKey(char[] passPhrase) {\n            //PBE results in invalid key length exception\n            //SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBEWithHmacSHA256AndAES_256&quot;);\n            SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);\n            KeySpec spec = new PBEKeySpec(passPhrase, createSalt(), 65536, 256);\n            SecretKey secret = new SecretKeySpec(factory.generateSecret(spec).getEncoded(), &quot;AES&quot;);\n            return secret;\n        }\n        \n        private static final IvParameterSpec createIv() {\n            final byte[] iv = new byte[16];\n            new SecureRandom().nextBytes(iv);\n            return new IvParameterSpec(iv);\n        }\n        \n        private static final byte[] createSalt() {\n            final byte[] salt = new byte[16];\n            new SecureRandom().nextBytes(salt);\n            return salt;\n        }\n</code></pre>\n<p>(sample output removed, not relevant as this approach is wrong)</p>\n<p><strong>Method 3</strong></p>\n<p>Based on ChatGPT.</p>\n<p>Problem: Java exception <code>java.security.InvalidKeyException: Wrong algorithm: AES or Rijndael required</code> on <code>Cipher.init()</code></p>\n<pre class=\"lang-java prettyprint-override\"><code>        private static final byte[] pemEncrypt(byte[] privateKey, char[] passPhrase) {\n            PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(privateKey);\n            byte[] salt = createSalt();\n            int iterationCount = 65536; // You can adjust this value\n            int keyLength = 128; // You can adjust this value\n    \n            PBEKeySpec pbeKeySpec = new PBEKeySpec(passPhrase, salt, iterationCount, keyLength);\n            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA1&quot;);\n            SecretKey secretKey = secretKeyFactory.generateSecret(pbeKeySpec);\n    \n            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n            byte[] encryptedKey = cipher.doFinal(pkcs8EncodedKeySpec.getEncoded());\n    \n            EncryptedPrivateKeyInfo encryptedPrivateKeyInfo = new EncryptedPrivateKeyInfo(cipher.getParameters(), encryptedKey);\n            return encryptedPrivateKeyInfo.getEncoded();\n        }\n</code></pre>\n<p><strong>Method 4</strong></p>\n<p>Based on the comment below about using an existing OpenSSL-generated private key as a template. This fails with the following exception on the last line of the <code>pemEncrypt</code> method:</p>\n<pre><code> java.security.NoSuchAlgorithmException: unrecognized algorithm name: PBEWithHmacSHA256AndAES_256\n    at java.base/sun.security.x509.AlgorithmId.get(AlgorithmId.java:477)\n    at java.base/javax.crypto.EncryptedPrivateKeyInfo.&lt;init&gt;(EncryptedPrivateKeyInfo.java:191)\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>        @SneakyThrows\n        private static byte[] pemEncrypt(byte[] key, char[] passPhrase) {\n            EncryptedPrivateKeyInfo encryptPKInfo = new EncryptedPrivateKeyInfo(readTemplate());\n            Cipher cipher = Cipher.getInstance(encryptPKInfo.getAlgName());\n            PBEKeySpec pbeKeySpec = new PBEKeySpec(passPhrase);\n            SecretKeyFactory secFac = SecretKeyFactory.getInstance(encryptPKInfo.getAlgName());\n            Key pbeKey = secFac.generateSecret(pbeKeySpec);\n            // For now using original parameters; \n            // I suppose I should create new parameters instead?\n            AlgorithmParameters algParams = encryptPKInfo.getAlgParameters();\n            cipher.init(Cipher.ENCRYPT_MODE, pbeKey, algParams);\n            byte[] body = cipher.doFinal(key);\n            return new EncryptedPrivateKeyInfo(cipher.getParameters(), body).getEncoded();\n        }\n        \n        @SneakyThrows\n        private static byte[] readTemplate() {\n            try ( var is = KPGenerator.class.getClassLoader().getResourceAsStream(&quot;com/company/crypto/key-template.aes256.pem&quot;) ) {\n                return getKey(IOUtils.toString(is, StandardCharsets.US_ASCII));\n            }\n        }\n\n        private static final byte[] getKey(String pemOrBase64Key) {\n            var base64 = pemOrBase64Key.replaceAll(&quot;-----(BEGIN|END) [\\\\sA-Z]+ KEY-----|\\\\s&quot;, &quot;&quot;);\n            return Base64.getDecoder().decode(base64);\n        }\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}