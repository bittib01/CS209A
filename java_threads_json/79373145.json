{
  "question": {
    "tags": [
      "java",
      "algorithm",
      "game-development",
      "minecraft",
      "random-seed"
    ],
    "owner": {
      "account_id": 16695316,
      "reputation": 76,
      "user_id": 12066699,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/7f4da2f1519d7596ec6f9d48a025e188?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Alexito",
      "link": "https://stackoverflow.com/users/12066699/alexito"
    },
    "is_answered": false,
    "view_count": 206,
    "answer_count": 0,
    "score": 4,
    "last_activity_date": 1738278697,
    "creation_date": 1737430861,
    "last_edit_date": 1738278697,
    "question_id": 79373145,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79373145/can-a-random-seed-used-for-end-crystal-spikes-prior-to-minecraft-1-9-be-reproduc",
    "title": "Can a random seed used for End Crystal spikes prior to Minecraft 1.9 be reproduced?",
    "body": "<p>Before the release 1.9 of <em>Minecraft</em>, the End dimension consisted of a floating piece of land made of endstone blocks with obsidian pillars or spikes, which were scattered around this island with no particular order following a specific shape.</p>\n<p>While the floating island itself was generated using the world seed with the biome End (defined in <code>ChunkProviderEnd.java</code> in <code>BiomeEndGen.java</code>, respectively), these spikes were randomly created as new chunks were being generated (I originally thought they were, obviously). The code that creates them &quot;populates&quot; chunks that meet their requirements, most notably the ones that have endstone blocks.</p>\n<p>The (decompiled) file <code>BiomeEndDecorator.java</code> picks the randomized variable <code>randomGenerator</code> and utilizes the <code>nextInt(int bound)</code> function to return a randomized value from 0 to 15, which is then used to obtain the <em>x</em> and <em>z</em> coordinates with the following equations (<em>x</em> and <em>z</em> are actually <code>var2</code> and <code>var3</code>, respectively, within the code):</p>\n<pre class=\"lang-java prettyprint-override\"><code>x = this.chunk_X + this.randomGenerator.nextInt(16) + 8;\nz = this.chunk_Z + this.randomGenerator.nextInt(16) + 8;\n</code></pre>\n<p>chunk_X and chunk_Z are just the coordinates of the chunk within the End's region files (converted to world coordinates, as chunk coordinates within region files range from 0 to 15, just like how world coordinates use the same range within a chunk). There is a third variable called <em>var3</em> which calculates the height that the obsidian pillars will be, parsing it as the number of iterations for a loop that generates a circle of obsidian, with a random radius too.</p>\n<p>The <code>randomGenerator</code> variable is declared in <code>BiomeDecorator.java</code>:</p>\n<pre class=\"lang-java prettyprint-override\"><code>protected Random randomGenerator;\n</code></pre>\n<p>Now, there's ways to obtain the seed of random variables in Java, since its <em>built-in</em> randomness algorithm is quite insecure, and it can be easily reversed. However, I found some problems upon obtaining the seed.</p>\n<p>My initial and main approach was to obtain the coordinates and then solve the inverted equation to get the initial randomly-generated values, and it seems like the coordinates within the chunk are actually just <code>this.randomGenerator.nextInt(16) + 8</code>, while the chunk coordinates are multiplied by 16. I obtained a seed this way, which was wrong, but it helped me check if I could always get the same spike generation. I tried giving it a set value and then using <code>setSeed</code> in the previous file to force the <em>x</em> and <em>z</em> coordinates, and of course it caused a grid:</p>\n<pre class=\"lang-java prettyprint-override\"><code>protected Random randomGeneratorX = new Random(15384);\nprotected Random randomGeneratorZ = new Random(15384);\n</code></pre>\n<p>The file <code>BiomeEndDecorator.java</code> is the following, extending <code>BiomeDecorator.java</code>, focusing on the End dimension:</p>\n<pre class=\"lang-java prettyprint-override\"><code>package net.minecraft.world.biome;\n\nimport net.minecraft.entity.boss.EntityDragon;\nimport net.minecraft.init.Blocks;\nimport net.minecraft.world.gen.feature.WorldGenSpikes;\nimport net.minecraft.world.gen.feature.WorldGenerator;\n\npublic class BiomeEndDecorator extends BiomeDecorator\n{\n    protected WorldGenerator spikeGen;\n    private static final String __OBFID = &quot;CL_00000188&quot;;\n\n    public BiomeEndDecorator()\n    {\n        this.spikeGen = new WorldGenSpikes(Blocks.end_stone);\n    }\n\n    protected void func_150513_a(BiomeGenBase p_150513_1_)\n    {\n        this.generateOres();\n\n        if (this.randomGenerator.nextInt(5) == 0)\n        {\n            int var2 = this.chunk_X + this.randomGenerator.nextInt(16) + 8;\n            int var3 = this.chunk_Z + this.randomGenerator.nextInt(16) + 8;\n            int var4 = this.currentWorld.getTopSolidOrLiquidBlock(var2, var3);\n            this.spikeGen.generate(this.currentWorld, this.randomGenerator, var2, var4, var3);\n        }\n\n        if (this.chunk_X == 0 &amp;&amp; this.chunk_Z == 0)\n        {\n            EntityDragon var5 = new EntityDragon(this.currentWorld);\n            var5.setLocationAndAngles(0.0D, 128.0D, 0.0D, this.randomGenerator.nextFloat() * 360.0F, 0.0F);\n            this.currentWorld.spawnEntityInWorld(var5);\n        }\n    }\n}\n</code></pre>\n<p>Modifying <code>BiomeEndDecorator.java</code>, adding the <code>setSeed</code> to the generator:</p>\n<pre><code>    this.randomGeneratorX.setSeed(15384);\n    this.randomGeneratorZ.setSeed(15384);    \n\n    if (this.randomGenerator.nextInt(5) == 0)\n            {       \n                int var2 = this.chunk_X + this.randomGenerator.nextInt(16) + 8;\n                int var3 = this.chunk_Z + this.randomGenerator.nextInt(16) + 8;\n</code></pre>\n<p>This works, but I need to reduce the value in <code>nextInt</code> to something smaller, like 2 (which causes a 50% chance of generating an Ender Crystal, unlike the usual 20% with the 5) so I don't get a spikeless End. Unfortunately, if I try putting the setSeed values within the condition, the seed will work but it will pick random values from it, instead of a specific order.</p>\n<p>There's a third file, <code>WorldGenSpikes.java</code> (with <code>WorldGenerator.java</code>), which uses these values and generates the spikes. In here, I made a simple print command to the console to obtain the coordinates. Ignoring the set value, new pillars would generate with coordinates based on the chunk as I generated new ones, as intended. And I couldn't get past this. I used MCEdit to make large endstone surfaces on new chunks without actually loading them, so they wouldn't get populated too early, and I'd get the same problem. Of course, giving a fixed seed for one of the coordinates would generate a line of spikes with a random space in-between:</p>\n<p><a href=\"https://i.sstatic.net/ZLdX0Cjm.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/ZLdX0Cjm.png\" alt=\"Obsidian pillars aligned by the X-axis.\" /></a></p>\n<p>The boolean function for spike generation is the following:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public boolean generate(World par1World, Random par2Random, int par3, int par4, int par5)\n    {\n        if (par1World.isAirBlock(par3, par4, par5) &amp;&amp; par1World.getBlock(par3, par4 - 1, par5) == this.field_150520_a)\n        {\n            int var6 = par2Random.nextInt(32) + 6;\n            int var7 = par2Random.nextInt(4) + 1;\n            int var8;\n            int var9;\n            int var10;\n            int var11;\n\n            for (var8 = par3 - var7; var8 &lt;= par3 + var7; ++var8)\n            {\n                for (var9 = par5 - var7; var9 &lt;= par5 + var7; ++var9)\n                {\n                    var10 = var8 - par3;\n                    var11 = var9 - par5;\n\n                    if (var10 * var10 + var11 * var11 &lt;= var7 * var7 + 1 &amp;&amp; par1World.getBlock(var8, par4 - 1, var9) != this.field_150520_a)\n                    {\n                        return false;\n                    }\n                }\n            }\n\n            for (var8 = par4; var8 &lt; par4 + var6 &amp;&amp; var8 &lt; 256; ++var8)\n            {\n                for (var9 = par3 - var7; var9 &lt;= par3 + var7; ++var9)\n                {\n                    for (var10 = par5 - var7; var10 &lt;= par5 + var7; ++var10)\n                    {\n                        var11 = var9 - par3;\n                        int var12 = var10 - par5;\n\n                        if (var11 * var11 + var12 * var12 &lt;= var7 * var7 + 1)\n                        {\n                            par1World.setBlock(var9, var8, var10, Blocks.obsidian, 0, 2);\n                        }\n                    }\n                }\n            }\n\n            EntityEnderCrystal var13 = new EntityEnderCrystal(par1World);\n            var13.setLocationAndAngles((double)((float)par3 + 0.5F), (double)(par4 + var6), (double)((float)par5 + 0.5F), par2Random.nextFloat() * 360.0F, 0.0F);\n            par1World.spawnEntityInWorld(var13);\n            par1World.setBlock(par3, par4 + var6, par5, Blocks.bedrock, 0, 2);\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n</code></pre>\n<p>So, in summary, the same seed causes an identical island, but different spikes. Pushing endstone to unloaded chunks generates new random spikes, and there is probably no way of obtaining the exact same result for all spikes. We could at most get the exact seed every time a new spike was loaded, and just replicate the existing known ones.</p>\n<p>I'd need a function that is able to reverse the coordinates and obtain the seed for the initial randomized values and a way of setting that seed for all worlds, which would obviously imply a modification in the game's code, since there's no way of inputting said seed upon generating the End dimension.</p>\n<p>I found some values for the bedrock block coordinates, but it'd be virtually impossible to find an exact seed, considering the game is able to generate spikes outside of the island if there's enough blocks, and the fact that only 13 crystals were generated:</p>\n<pre><code>    x (after equation) |  z (after equation)  \n    3 -&gt;                 10\n    0 -&gt;                  2\n    7 -&gt;                  1\n   13 -&gt;                  5\n    1 -&gt;                  9\n</code></pre>\n<p>My question is, is there actually a sensible way of creating an algorithm that manages to crack the seed every time a new chunk is generated that meets the criteria for the obsidian pillars, considering each pillar generated uses a new random value?</p>\n<p><em>Note: It's possible to generate Overworld ores in The End, by pushing stone, among other blocks, towards unloaded chunks. Although the ores are indeed based on the seed within The Overworld, I haven't experimented to check if it's the same in The End (I believe they are, too). This is mostly a curiosity, as the ores are then affected by the seed, unlike the pillars, but they work the same way when it comes to actual generation conditions.</em></p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}