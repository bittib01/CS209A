{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "apache-kafka",
      "spring-kafka"
    ],
    "owner": {
      "account_id": 16845735,
      "reputation": 11,
      "user_id": 12179965,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/9a2e8030a42c25b809c88921764cbbcd?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "amumu",
      "link": "https://stackoverflow.com/users/12179965/amumu"
    },
    "is_answered": false,
    "view_count": 74,
    "answer_count": 0,
    "score": 0,
    "last_activity_date": 1759940351,
    "creation_date": 1759813921,
    "last_edit_date": 1759940351,
    "question_id": 79784223,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79784223/springboot-integration-kafka-retryabletopic-is-not-effective",
    "title": "springboot integration Kafka @RetryableTopic is not effective",
    "body": "<h3>describe</h3>\n<p>springboot integration  Kafka @RetryableTopic is not effective,I cannot control retry count; it is retrying continuously.There are two types of error logs continuously printed in the console: one is 'Unable to deliver to retry queue',and the other is 'Send exception not in transaction'.</p>\n<p>Because I want to send transactional messages, I have configured the ProducerConfig.TRANSACTIONAL_ID_CONFIG in the ProducerFactory and KafkaTemplate, and I have also added the @Transactional annotation on the message consumer side.</p>\n<h3>version</h3>\n<p>JDK1.8   spring-boot-starter-parent:2.7.17 spring-kafka:2.9.13\nbroker:kafka_2.12-3.6.1</p>\n<h2>code</h2>\n<p><a href=\"https://github.com/LimerenceAmumu/Kafka-study\" rel=\"nofollow noreferrer\">https://github.com/LimerenceAmumu/Kafka-study</a></p>\n<h3>consumer</h3>\n<pre><code>    // æ¶ˆè´¹è€…ç»„1ï¼šå¤„ç†è®¢å•\n        @RetryableTopic(\n            attempts = &quot;4&quot;,  // æ€»å…±å°è¯• 4 æ¬¡ï¼ˆ1æ¬¡åŸå§‹ + 3æ¬¡é‡è¯•ï¼‰\n            backoff = @Backoff(delay = 1000, multiplier = 2.0), // 1s, 2s, 4s é‡è¯•\n            dltTopicSuffix = &quot;.dlt&quot;,  // æ­»ä¿¡é˜Ÿåˆ— Topic åï¼šorder-topic.dlt\n            include = {Exception.class}, // é‡è¯•æ‰€æœ‰å¼‚å¸¸ç±»å‹,\n            dltStrategy = DltStrategy.FAIL_ON_ERROR  // å¤„ç†å¤±è´¥æ—¶è¿›å…¥ DLQ\n    )\n    @KafkaListener(\n            topics = &quot;order-topic-new&quot;,\n            groupId = &quot;${spring.kafka.consumer.group-id}&quot;,\n            containerFactory = &quot;kafkaListenerContainerFactory&quot;\n    )\n    public void consumeOrderMessage(ConsumerRecord&lt;String, Order&gt; record, @org.springframework.messaging.handler.annotation.Payload(required = false) Object payload, Acknowledgment acknowledgment) {\n        try {\n            Order order = record.value();\n            log.info(&quot;æ¥æ”¶åˆ°è®¢å•æ¶ˆæ¯: è®¢å•ID={}, ä¸»é¢˜={}, åˆ†åŒº={}, åç§»é‡={}&quot;,\n                    order.getOrderId(),\n                    record.topic(),\n                    record.partition(),\n                    record.offset());\n            // å¤„ç†è®¢å•\n            processOrder(order);\n\n            //åŠ é™å®š æŠ›å¼‚å¸¸\n            if (order.getCustomerName().equals(&quot;ex&quot;)) {\n                throw new RuntimeException(&quot;order process error&quot;);\n            }\n            acknowledgment.acknowledge();\n            log.info(&quot;order process ack: {}&quot;, order.getOrderId());\n        } catch (Exception e) {\n            log.error(&quot;order process error: {}&quot;, e.getMessage(), e);\n            throw e;\n        }\n    }\n</code></pre>\n<h3>config</h3>\n<pre><code>@RequiredArgsConstructor\n@EnableScheduling\n@Configuration\n@EnableKafka\npublic class KafkaConfig extends RetryTopicConfigurationSupport {\n\n    @Value(&quot;${spring.kafka.bootstrap-servers}&quot;)\n    private String bootstrapServers;\n\n    @Value(&quot;${spring.kafka.consumer.group-id}&quot;)\n    private String consumerGroupId;\n\n\n    @Override\n    protected void configureBlockingRetries(BlockingRetriesConfigurer blockingRetries) {\n        blockingRetries\n                .retryOn(Exception.class)\n                .backOff(new FixedBackOff(5000, 2));\n    }\n//    // åˆ›å»ºè®¢å•ä¸»é¢˜\n//    @Bean\n//    public NewTopic orderTopic() {\n//        Map&lt;String, String&gt; configs = new HashMap&lt;&gt;();\n//        configs.put(&quot;retention.ms&quot;, &quot;86400000&quot;);  // ä¿ç•™1å¤©\n//\n//        return TopicBuilder.name(&quot;order-topic&quot;)\n//                .partitions(3)  // 3ä¸ªåˆ†åŒº\n//                .replicas(1)    // 1ä¸ªå‰¯æœ¬\n//                .configs(configs)\n//                .build();\n//    }\n    // åˆ›å»ºè®¢å•ä¸»é¢˜\n    @Bean\n    public NewTopic orderTopicDLQ() {\n        Map&lt;String, String&gt; configs = new HashMap&lt;&gt;();\n        configs.put(&quot;retention.ms&quot;, &quot;86400000&quot;);  // ä¿ç•™1å¤©\n\n        return TopicBuilder.name(&quot;order-topic-new.dlt&quot;)\n                .partitions(3)  // 3ä¸ªåˆ†åŒº\n                .replicas(1)    // 1ä¸ªå‰¯æœ¬\n                .configs(configs)\n                .build();\n    }\n\n\n    // åˆ›å»ºè®¢å•ç¡®è®¤ä¸»é¢˜\n    @Bean\n    public NewTopic orderConfirmationTopic() {\n        return TopicBuilder.name(&quot;order-confirmation-topic&quot;)\n                .partitions(2)\n                .replicas(1)\n                .build();\n    }\n\n    // ç”Ÿäº§è€…é…ç½®\n    @Bean\n    public ProducerFactory&lt;String, Order&gt; orderProducerFactory() {\n        Map&lt;String, Object&gt; configProps = new HashMap&lt;&gt;();\n        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);\n        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);\n        configProps.put(ProducerConfig.ACKS_CONFIG, &quot;all&quot;);  // ç­‰å¾…æ‰€æœ‰å‰¯æœ¬ç¡®è®¤\n        configProps.put(ProducerConfig.RETRIES_CONFIG, 3);   // é‡è¯•æ¬¡æ•°\n        configProps.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);  // å¼€å¯å¹‚ç­‰æ€§\n        configProps.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, &quot;order-service-transaction&quot;);  // äº‹åŠ¡IDé…ç½®\n        return new DefaultKafkaProducerFactory&lt;&gt;(configProps);\n    }\n\n    @Bean\n    public KafkaTemplate&lt;String, Order&gt; kafkaTemplate() {\n        return new KafkaTemplate&lt;&gt;(orderProducerFactory());\n    }\n//\n//    @Bean(&quot;defaultRetryTopicKafkaTemplate&quot;)\n//    public KafkaTemplate&lt;String, Order&gt; defaultRetryTopicKafkaTemplate(ProducerFactory&lt;String, Order&gt; producerFactory) {\n//        KafkaTemplate&lt;String, Order&gt; template = new KafkaTemplate&lt;&gt;(producerFactory);\n//        // ğŸ‘‡ å…³é”®ï¼šå…è®¸éäº‹åŠ¡å‘é€\n//        template.setAllowNonTransactional(true);\n//        return template;\n//    }\n//    @Bean\n//    public DeadLetterPublishingRecoverer deadLetterPublishingRecoverer(KafkaTemplate&lt;String, Order&gt; retryKafkaTemplate) {\n//        return new DeadLetterPublishingRecoverer(retryKafkaTemplate);\n//    }\n\n    // æ¶ˆè´¹è€…é…ç½®\n    @Bean\n    public ConsumerFactory&lt;String, Order&gt; orderConsumerFactory() {\n        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();\n        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        props.put(ConsumerConfig.GROUP_ID_CONFIG, consumerGroupId);\n        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);\n        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);\n        props.put(JsonDeserializer.TRUSTED_PACKAGES, &quot;com.example.kafkaorderdemo.model&quot;);\n        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, &quot;earliest&quot;);  // ä»æœ€æ—©çš„æ¶ˆæ¯å¼€å§‹æ¶ˆè´¹\n        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);  // ç¦ç”¨è‡ªåŠ¨æäº¤\n        return new DefaultKafkaConsumerFactory&lt;&gt;(props);\n    }\n\n    @Bean\n    public ConcurrentKafkaListenerContainerFactory&lt;String, Order&gt; kafkaListenerContainerFactory() {\n        ConcurrentKafkaListenerContainerFactory&lt;String, Order&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;();\n        factory.setConsumerFactory(orderConsumerFactory());\n        factory.setBatchListener(false);\n        factory.setReplyTemplate(kafkaTemplate());\n        // è®¾ç½®æ‰‹åŠ¨ç¡®è®¤æ¨¡å¼ï¼Œä½¿Acknowledgmentå¯ç”¨\n        factory.getContainerProperties().setAckMode(ContainerProperties.AckMode.MANUAL);\n        return factory;\n    }\n\n    // äº‹åŠ¡ç®¡ç†å™¨é…ç½®\n    @Bean\n    public KafkaTransactionManager&lt;String, Order&gt; kafkaTransactionManager() {\n        KafkaTransactionManager&lt;String, Order&gt; transactionManager = new KafkaTransactionManager&lt;&gt;(orderProducerFactory());\n        transactionManager.setTransactionSynchronization(AbstractPlatformTransactionManager.SYNCHRONIZATION_ON_ACTUAL_TRANSACTION);\n        return transactionManager;\n    }\n\n}\n</code></pre>\n<h2>errorLogs:</h2>\n<pre><code>2025-10-07 12:01:09 [org.springframework.kafka.KafkaListenerEndpointContainer#1-0-C-1] ERROR o.s.k.r.DeadLetterPublishingRecovererFactory$1 - Dead-letter publication to order-topic-new-retry-0failed for: order-topic-new-0@0\njava.lang.IllegalStateException: No transaction is in process; possible solutions: run the template operation within the scope of a template.executeInTransaction() operation, start a transaction with @Transactional before invoking the template method, run in a transaction started by a listener container when consuming a record\n   at org.springframework.util.Assert.state(Assert.java:76)\n   at org.springframework.kafka.core.KafkaTemplate.getTheProducer(KafkaTemplate.java:782)\n   at org.springframework.kafka.core.KafkaTemplate.doSend(KafkaTemplate.java:674)\n   at org.springframework.kafka.core.KafkaTemplate.send(KafkaTemplate.java:459)\n   at org.springframework.kafka.listener.DeadLetterPublishingRecoverer.publish(DeadLetterPublishingRecoverer.java:654)\n   at org.springframework.kafka.listener.DeadLetterPublishingRecoverer.send(DeadLetterPublishingRecoverer.java:562)\n   at org.springframework.kafka.listener.DeadLetterPublishingRecoverer.sendOrThrow(DeadLetterPublishingRecoverer.java:527)\n   at org.springframework.kafka.listener.DeadLetterPublishingRecoverer.accept(DeadLetterPublishingRecoverer.java:499)\n   at org.springframework.kafka.listener.FailedRecordTracker.attemptRecovery(FailedRecordTracker.java:237)\n   at org.springframework.kafka.listener.FailedRecordTracker.recovered(FailedRecordTracker.java:191)\n   at org.springframework.kafka.listener.SeekUtils.lambda$doSeeks$5(SeekUtils.java:107)\n   at java.util.ArrayList.forEach(ArrayList.java:1257)\n   at org.springframework.kafka.listener.SeekUtils.doSeeks(SeekUtils.java:104)\n   at org.springframework.kafka.listener.SeekUtils.seekOrRecover(SeekUtils.java:207)\n   at org.springframework.kafka.listener.DefaultErrorHandler.handleRemaining(DefaultErrorHandler.java:174)\n   at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeErrorHandler(KafkaMessageListenerContainer.java:2854)\n   at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2722)\n   at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2572)\n   at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2448)\n   at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2078)\n   at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1430)\n   at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1394)\n   at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1291)\n   at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n   at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n   at java.lang.Thread.run(Thread.java:748)\n2025-10-07 12:01:09 [org.springframework.kafka.KafkaListenerEndpointContainer#1-0-C-1] ERROR o.s.k.listener.DefaultErrorHandler - Failed to determine if this record (order-topic-new-0@0) should be recovererd, including in seeks\norg.springframework.kafka.KafkaException: Dead-letter publication to order-topic-new-retry-0failed for: order-topic-new-0@0\n   at org.springframework.kafka.listener.DeadLetterPublishingRecoverer.verifySendResult(DeadLetterPublishingRecoverer.java:683)\n   at org.springframework.kafka.listener.DeadLetterPublishingRecoverer.publish(DeadLetterPublishingRecoverer.java:666)\n   at org.springframework.kafka.listener.DeadLetterPublishingRecoverer.send(DeadLetterPublishingRecoverer.java:562)\n   at org.springframework.kafka.listener.DeadLetterPublishingRecoverer.sendOrThrow(DeadLetterPublishingRecoverer.java:527)\n   at org.springframework.kafka.listener.DeadLetterPublishingRecoverer.accept(DeadLetterPublishingRecoverer.java:499)\n   at org.springframework.kafka.listener.FailedRecordTracker.attemptRecovery(FailedRecordTracker.java:237)\n   at org.springframework.kafka.listener.FailedRecordTracker.recovered(FailedRecordTracker.java:191)\n   at org.springframework.kafka.listener.SeekUtils.lambda$doSeeks$5(SeekUtils.java:107)\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}