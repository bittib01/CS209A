{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "spring-mvc",
      "spring-webflux"
    ],
    "owner": {
      "account_id": 38561859,
      "reputation": 1,
      "user_id": 28837036,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/aaba515656e31c7df7a3d7444f1b384a?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Ramss Martnez Martnez Canocles",
      "link": "https://stackoverflow.com/users/28837036/ramss-martnez-martnez-canocles"
    },
    "is_answered": true,
    "view_count": 49,
    "accepted_answer_id": 79303608,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1734969751,
    "creation_date": 1734521572,
    "question_id": 79290930,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79290930/the-www-authenticate-header-breaks-jettyclienthttpconnector",
    "title": "The www-authenticate header breaks JettyClientHttpConnector",
    "body": "<h3>Environment</h3>\n<ul>\n<li>Spring Boot <strong>3.3.4</strong></li>\n<li>Spring Web <strong>6.1.1</strong></li>\n</ul>\n<h3>Old surroundings where it operated</h3>\n<ul>\n<li>Spring Boot <strong>2.7.18</strong></li>\n<li>Spring Web <strong>5.3.31</strong></li>\n</ul>\n<h3>Context</h3>\n<p>We have migrated from a <strong>Spring Boot 2.7.18</strong> environment to <strong>Spring Boot 3.3.4</strong> and we have detected that when using a <strong>WebClient</strong> with a JettyClientHttpConnector with its respective HttpClient, in case the call comes with a <strong>www-authenticate</strong> header, it gets stuck making calls infinitely and we never get it to respond correctly.</p>\n<p>All this worked perfectly in the Spring Boot 2 version, where upon receiving the call, it responded without any problem.</p>\n<p>We have tried to define the connector in the most basic way possible, but it always breaks, in case of receiving that header.</p>\n<h3>Examples and Code</h3>\n<p>We have done the test, simply by telling <code>WebClient</code> that the connector we are going to use is <code>JettyClientHttpConnector</code>.</p>\n<pre class=\"lang-java prettyprint-override\"><code>WebClient client =\n        WebClient.builder()\n            .baseUrl(&quot;your-url-with-www-authenticate-header-in-response&quot;)\n            .clientConnector(new JettyClientHttpConnector())\n            .build();\n</code></pre>\n<p>If you try to make a call to any endpoint, which returns the www-authenticate header, you can see that it gets stuck and after passing the timeout, it throws this error:</p>\n<pre class=\"lang-none prettyprint-override\"><code>onFillableFail SslConnection@10ac4a81::SocketChannelEndPoint@4d09e077[{l=null,r=null,CLOSED,fill=-,flush=-,to=7/30000}{io=1/1,kio=-1,kro=-1}]-&gt;[SslConnection@10ac4a81{NOT_HANDSHAKING,eio=-1/-1,di=-1,fill=INTERESTED,flush=IDLE}~&gt;{l=null,r=null,CLOSED,fill=FI,flush=-,to=30027/30000}=&gt;HttpConnectionOverHTTP@46f46e11(l:null &lt;-&gt; r:null,closed=true)=&gt;HttpChannelOverHTTP@11d2c7ca(exchange=null)[send=HttpSenderOverHTTP@4f015fae(req=QUEUED,failure=null)[HttpGenerator@3d8bec8d{s=START}],recv=HttpReceiverOverHTTP@69f1010a(ex=null,rsp=IDLE,failure=null)[HttpParser{s=START,0 of -1}]]]\njava.nio.channels.ClosedChannelException: null\n    at org.eclipse.jetty.io.FillInterest.onClose(FillInterest.java:147)\n    at org.eclipse.jetty.io.AbstractEndPoint.onClose(AbstractEndPoint.java:336)\n    at org.eclipse.jetty.io.SelectableChannelEndPoint.onClose(SelectableChannelEndPoint.java:165)\n    at org.eclipse.jetty.io.AbstractEndPoint.onClose(AbstractEndPoint.java:326)\n    at org.eclipse.jetty.io.AbstractEndPoint.doOnClose(AbstractEndPoint.java:253)\n    at org.eclipse.jetty.io.AbstractEndPoint.close(AbstractEndPoint.java:217)\n    at org.eclipse.jetty.io.AbstractEndPoint.close(AbstractEndPoint.java:200)\n    at org.eclipse.jetty.io.ssl.SslConnection$SslEndPoint.disconnect(SslConnection.java:1399)\n    at org.eclipse.jetty.io.ssl.SslConnection$SslEndPoint.doShutdownOutput(SslConnection.java:1381)\n    at org.eclipse.jetty.io.ssl.SslConnection$SslEndPoint.doClose(SslConnection.java:1449)\n    at org.eclipse.jetty.io.AbstractEndPoint.doOnClose(AbstractEndPoint.java:248)\n    at org.eclipse.jetty.io.AbstractEndPoint.close(AbstractEndPoint.java:217)\n    at org.eclipse.jetty.io.AbstractEndPoint.close(AbstractEndPoint.java:200)\n    at org.eclipse.jetty.client.transport.internal.HttpConnectionOverHTTP.close(HttpConnectionOverHTTP.java:298)\n    at org.eclipse.jetty.client.transport.internal.HttpConnectionOverHTTP.onIdleExpired(HttpConnectionOverHTTP.java:237)\n    at org.eclipse.jetty.io.ssl.SslConnection.onIdleExpired(SslConnection.java:371)\n    at org.eclipse.jetty.io.AbstractEndPoint.onIdleExpired(AbstractEndPoint.java:389)\n    at org.eclipse.jetty.io.IdleTimeout.checkIdleTimeout(IdleTimeout.java:172)\n    at org.eclipse.jetty.io.IdleTimeout.idleCheck(IdleTimeout.java:113)\n</code></pre>\n<p>Also, it seems to retry the call until finally the error appears, but the call gets hung up and never resolves.</p>\n<pre class=\"lang-none prettyprint-override\"><code>[DEBUG] [ o.e.j.u.t.ReservedThreadExecutor: 348 ]  waiting for task\n[DEBUG] [ com.zaxxer.hikari.pool.HikariPool: 405 ]  HikariPool-1 - Pool stats (total=10, active=0, idle=10, waiting=0)\n[DEBUG] [ com.zaxxer.hikari.pool.HikariPool: 510 ]  HikariPool-1 - Fill pool skipped, pool has sufficient level or currently being filled.\n[DEBUG] [ o.e.j.util.thread.QueuedThreadPool: 1015 ]  Evict check, period=60000ms QueuedThreadPool[HttpClient@7218bb00]@42681628{STARTED,8&lt;=12&lt;=200,i=3,r=-1,t=-67ms,q=0}[ReservedThreadExecutor@7457d199{capacity=16,threads=ThreadIdPool@397ce9d8{capacity=16}}]\n[DEBUG] [ o.e.j.util.thread.QueuedThreadPool: 1033 ]  Evict skipped, threshold=59932ms in the future QueuedThreadPool[HttpClient@7218bb00]@42681628{STARTED,8&lt;=12&lt;=200,i=3,r=-1,t=-67ms,q=0}[ReservedThreadExecutor@7457d199{capacity=16,threads=ThreadIdPool@397ce9d8{capacity=16}}]\n[DEBUG] [ o.e.j.u.t.ReservedThreadExecutor: 348 ]  waiting for task\n[DEBUG] [ o.e.j.util.thread.QueuedThreadPool: 1015 ]  Evict check, period=60000ms QueuedThreadPool[HttpClient@7218bb00]@42681628{STARTED,8&lt;=12&lt;=200,i=3,r=-1,t=-74ms,q=0}[ReservedThreadExecutor@7457d199{capacity=16,threads=ThreadIdPool@397ce9d8{capacity=16}}]\n[DEBUG] [ o.e.j.util.thread.QueuedThreadPool: 1033 ]  Evict skipped, threshold=59925ms in the future QueuedThreadPool[HttpClient@7218bb00]@42681628{STARTED,8&lt;=12&lt;=200,i=3,r=-1,t=-75ms,q=0}[ReservedThreadExecutor@7457d199{capacity=16,threads=ThreadIdPool@397ce9d8{capacity=16}}]\n[DEBUG] [ com.zaxxer.hikari.pool.PoolBase: 133 ]  HikariPool-1 - Closing connection oracle.jdbc.driver.T4CConnection@24c9581b: (connection has passed maxLifetime)\n[DEBUG] [ com.zaxxer.hikari.pool.HikariPool: 728 ]  HikariPool-1 - Added connection oracle.jdbc.driver.T4CConnection@c485e55\n[DEBUG] [ com.zaxxer.hikari.pool.HikariPool: 405 ]  HikariPool-1 - Connection not added, stats (total=10, active=0, idle=10, waiting=0)\n</code></pre>\n<p>However, with exactly the same code in Spring Boot 2, it resolves the call without a problem.</p>\n<p>Thanks for help!</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}