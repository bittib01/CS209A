{
  "question": {
    "tags": [
      "java",
      "spring",
      "hibernate",
      "session"
    ],
    "owner": {
      "account_id": 14724831,
      "reputation": 155,
      "user_id": 10634207,
      "user_type": "registered",
      "profile_image": "https://graph.facebook.com/1959580214120876/picture?type=large",
      "display_name": "Toni Nagy",
      "link": "https://stackoverflow.com/users/10634207/toni-nagy"
    },
    "is_answered": true,
    "view_count": 506,
    "accepted_answer_id": 79279333,
    "answer_count": 2,
    "score": 1,
    "last_activity_date": 1734117343,
    "creation_date": 1705871401,
    "last_edit_date": 1705871728,
    "question_id": 77856651,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/77856651/why-is-the-hibernate-session-still-open-after-the-transaction-is-committed",
    "title": "Why is the Hibernate Session still open after the transaction is committed",
    "body": "<p>I was perplexed when the creation of a projection from a lazily loaded entity collection didn't throw a LazyInitializationException, when returning a DTO response from a stateless REST service's update method.\nSo I checked, and the Hibernate Session was still open, even after the transaction has completed and was no longer active (as per the printout):</p>\n<pre><code>@ResponseStatus(HttpStatus.OK)\n@ResponseBody\n@PutMapping(value = &quot;/{employeeId}&quot;, consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)\npublic EmployeeDto updateEmployee( @PathVariable Long employeeId, @Valid @RequestBody UpdateEmployeeDto updateEmployeeDto) {       \n   Employee employee = employeeService.updateEmployee(employeeId, updateEmployeeDto);\n   System.out.println(&quot;Transaction Active: &quot; + \n   TransactionSynchronizationManager.isActualTransactionActive()); // prints false\n   Session hibernateSession = entityManager.unwrap(Session.class);\n   System.out.println(&quot;Hibernate Session Open: &quot; + hibernateSession.isOpen()); //prints true\n   return employeeMapper.toDto(employee);\n}\n</code></pre>\n<p>I understood that by default, session management in Spring was tightly coupled with the transactional context, i.e. the session is scoped to the current database transaction. So why didn't it close after triggering the previous tx commit?</p>\n<p>A bare @Transactional is used on the update employee method, and there is no extended persistence context applied.</p>\n<p>I remember getting LazyInitExceptions when converting to DTO projections from previous projects, I must be missing something apparent, though there is no special configuration done to the transaction/session management of this project.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}