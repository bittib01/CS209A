{
  "question": {
    "tags": [
      "java",
      "spring",
      "spring-boot",
      "hibernate",
      "rest"
    ],
    "owner": {
      "account_id": 34933530,
      "reputation": 9,
      "user_id": 26868283,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/1914470f0f48147af40dd282c83e1340?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Yash Singh",
      "link": "https://stackoverflow.com/users/26868283/yash-singh"
    },
    "is_answered": true,
    "view_count": 108,
    "accepted_answer_id": 78889554,
    "answer_count": 1,
    "score": -1,
    "last_activity_date": 1724495435,
    "creation_date": 1724000131,
    "last_edit_date": 1724087687,
    "question_id": 78885190,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78885190/getting-500-exception-response-on-my-entity-booking-due-to-future-annotation",
    "title": "Getting 500 Exception response on my entity Booking due to @Future Annotation",
    "body": "<p>I am building a web application based on hotel room booking and testing my REST API through postman and this @Future annotation from import jakarta.validation.constraints.Future; is giving me 500 response, while I tried to hit the link mentioned in the screenshot, I tried again by removing this <code>@Future</code> annotation and it is working perfectly, so please tell me if there is any alternative or solution for this issue.</p>\n<p>I have used this <code>@Future</code> over one attribute(checkOutDate) of entity, below are the codes related to Booking: -</p>\n<p><strong>Booking.java</strong></p>\n<pre><code>package com.Yash.Astoria.entities;\n\nimport jakarta.validation.constraints.Future;\nimport jakarta.persistence.*;\nimport jakarta.validation.constraints.Min;\nimport jakarta.validation.constraints.NotNull;\nimport lombok.Data;\n\nimport java.time.LocalDate;\n\n@Data\n@Entity\n@Table(name = &quot;bookings&quot;)\npublic class Booking {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @NotNull(message = &quot;CheckIn Date is required&quot;)\n    private LocalDate checkInDate;\n\n    @Future(message = &quot;check out date must be in the future&quot;)\n    private LocalDate checkOutDate;\n\n    @Min(value = 1, message = &quot;Atleast 1 adult should be selected&quot;)\n    private int numOfAdults;\n\n    @Min(value = 0, message = &quot;Number of Childrens should not be less then 0&quot;)\n    private int numOfChildren;\n\n    private int totalNumOfGuests;\n\n    private String bookingConfirmationCode;\n\n    @ManyToOne(fetch = FetchType.EAGER)\n    @JoinColumn(name = &quot;user_id&quot;)\n    private User user;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = &quot;room_id&quot;)\n    private Room room;\n\n    public void getTotalNumberOfGuests(){\n        this.totalNumOfGuests = this.numOfAdults + this.numOfChildren;\n    }\n\n    public void setNumOfAdults(int numOfAdults) {\n        this.numOfAdults = numOfAdults;\n        getTotalNumberOfGuests();\n    }\n\n    public void setNumOfChildren(int numOfChildren) {\n        this.numOfChildren = numOfChildren;\n        getTotalNumberOfGuests();\n    }\n\n    @Override\n    public String toString() {\n        return &quot;Booking{&quot; +\n                &quot;id=&quot; + id +\n                &quot;, checkInDate=&quot; + checkInDate +\n                &quot;, checkOutDate=&quot; + checkOutDate +\n                &quot;, numOfAdults=&quot; + numOfAdults +\n                &quot;, numOfChildren=&quot; + numOfChildren +\n                &quot;, totalNumOfGuests=&quot; + totalNumOfGuests +\n                &quot;, bookingConfirmationCode='&quot; + bookingConfirmationCode + '\\'' +\n                '}';\n    }\n}\n</code></pre>\n<p><strong>BookingController.java</strong></p>\n<pre><code>package com.Yash.Astoria.controllers;\n\nimport com.Yash.Astoria.dto.Response;\nimport com.Yash.Astoria.entities.Booking;\nimport com.Yash.Astoria.services.Interface.IBookingService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.security.access.prepost.PreAuthorize;\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping(&quot;/bookings&quot;)\npublic class BookingController {\n\n    @Autowired\n    private IBookingService bookingService;\n\n    @PostMapping(&quot;/book-room/{roomId}/{userId}&quot;)\n    @PreAuthorize(&quot;hasAuthority('ADMIN') or hasAuthority('USER')&quot;)\n    public ResponseEntity&lt;Response&gt; saveBookings(@PathVariable Long roomId,\n                                                 @PathVariable Long userId,\n                                                 @RequestBody Booking bookingRequest){\n        Response response = bookingService.saveBooking(roomId, userId, bookingRequest);\n        return  ResponseEntity.status(response.getStatusCode()).body(response);\n    }\n\n    @GetMapping(&quot;/all&quot;)\n    @PreAuthorize(&quot;hasAuthority('ADMIN')&quot;)\n    public ResponseEntity&lt;Response&gt; getAllBookings(){\n        Response response = bookingService.getAllBookings();\n        return ResponseEntity.status(response.getStatusCode()).body(response);\n    }\n\n    @GetMapping(&quot;/get-by-confirmation-code/{confirmationCode}&quot;)\n    public ResponseEntity&lt;Response&gt; getBookingByConfirmationCode(@PathVariable String confirmationCode){\n        Response response = bookingService.findBookingByConfirmationCode(confirmationCode);\n        return  ResponseEntity.status(response.getStatusCode()).body(response);\n    }\n\n    @DeleteMapping\n    @PreAuthorize(&quot;hasAuthority('ADMIN') or hasAuthority('USER')&quot;)\n    public ResponseEntity&lt;Response&gt; cancelBooking(@PathVariable Long bookingId){\n        Response response = bookingService.cancelBooking(bookingId);\n        return ResponseEntity.status(response.getStatusCode()).body(response);\n    }\n\n}\n</code></pre>\n<p><strong>IBookingService.java</strong></p>\n<pre><code>package com.Yash.Astoria.services.Interface;\n\nimport com.Yash.Astoria.dto.Response;\nimport com.Yash.Astoria.entities.Booking;\n\npublic interface IBookingService {\n\n    Response saveBooking(Long roomId, Long userId, Booking bookingRequest);\n\n    Response findBookingByConfirmationCode(String confirmationCode);\n\n    Response getAllBookings();\n\n    Response cancelBooking(Long bookingId);\n}\n</code></pre>\n<p><strong>BookingService.java</strong></p>\n<pre><code>package com.Yash.Astoria.services.impl;\n\nimport com.Yash.Astoria.dto.BookingDTO;\nimport com.Yash.Astoria.dto.Response;\nimport com.Yash.Astoria.entities.Booking;\nimport com.Yash.Astoria.entities.Room;\nimport com.Yash.Astoria.entities.User;\nimport com.Yash.Astoria.exception.OurException;\nimport com.Yash.Astoria.repository.BookingRepository;\nimport com.Yash.Astoria.repository.RoomRepository;\nimport com.Yash.Astoria.repository.UserRepository;\nimport com.Yash.Astoria.services.Interface.IBookingService;\nimport com.Yash.Astoria.services.Interface.IRoomService;\nimport com.Yash.Astoria.utils.Utils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n@Service\npublic class BookingService implements IBookingService {\n\n    @Autowired\n    private BookingRepository bookingRepository;\n\n    @Autowired\n    private IRoomService roomService;\n\n    @Autowired\n    private RoomRepository roomRepository;\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Override\n    public Response saveBooking(Long roomId, Long userId, Booking bookingRequest) {\n\n        Response response = new Response();\n\n        try {\n\n            if (bookingRequest.getCheckOutDate().isBefore(bookingRequest.getCheckInDate())) {\n                throw new IllegalArgumentException(&quot;Check out date must come after Check in date&quot;);\n            }\n\n            Room room = roomRepository.findById(roomId).orElseThrow(() -&gt; new OurException(&quot;Room Not Found&quot;));\n            User user = userRepository.findById(userId).orElseThrow(() -&gt; new OurException(&quot;User Not Found&quot;));\n\n            List&lt;Booking&gt; existingBookings = room.getBookings();\n\n            if (!roomIsAvailable(bookingRequest, existingBookings)) {\n                throw new OurException(&quot;Room not Available for selected date range&quot;);\n            }\n\n            bookingRequest.setRoom(room);\n            bookingRequest.setUser(user);\n            String bookingConfirmationCode = Utils.generateRandomConfirmationCode(10);\n            bookingRequest.setBookingConfirmationCode(bookingConfirmationCode);\n            bookingRepository.save(bookingRequest);\n            response.setStatusCode(200);\n            response.setMessage(&quot;successful&quot;);\n            response.setBookingConfirmationCode(bookingConfirmationCode);\n\n        } catch (OurException e) {\n            response.setStatusCode(404);\n            response.setMessage(e.getMessage());\n        } catch (Exception e){\n            response.setStatusCode(500);\n            response.setMessage(&quot;Error while Saving a Booking&quot;+e.getMessage());\n        }\n\n        return response;\n    }\n\n    @Override\n    public Response findBookingByConfirmationCode(String confirmationCode) {\n\n        Response response = new Response();\n\n        try {\n\n            Booking booking = bookingRepository.findBookingByBookingConfirmationCode(confirmationCode).orElseThrow(()-&gt; new OurException(&quot;Booking Not Found&quot;));\n            BookingDTO bookingDTO = Utils.mapBookingEntityToBookingDTOPlusBookedRooms(booking, true);\n            response.setStatusCode(200);\n            response.setMessage(&quot;successful&quot;);\n            response.setBooking(bookingDTO);\n\n        } catch (OurException e) {\n            response.setStatusCode(404);\n            response.setMessage(e.getMessage());\n        } catch (Exception e){\n            response.setStatusCode(500);\n            response.setMessage(&quot;Error Finding a Booking&quot;+e.getMessage());\n        }\n\n        return response;\n\n    }\n\n    @Override\n    public Response getAllBookings() {\n\n        Response response = new Response();\n\n        try {\n\n            List&lt;Booking&gt; bookingList = bookingRepository.findAll(Sort.by(Sort.Direction.DESC, &quot;id&quot;));\n            List&lt;BookingDTO&gt; bookingDTOList = Utils.mapBookingListEntityToBookingListDTO(bookingList);\n            response.setStatusCode(200);\n            response.setMessage(&quot;successful&quot;);\n            response.setBookingList(bookingDTOList);\n\n        } catch (OurException e) {\n            response.setStatusCode(404);\n            response.setMessage(e.getMessage());\n        } catch (Exception e){\n            response.setStatusCode(500);\n            response.setMessage(&quot;Error while retrieving all the Bookings&quot;+e.getMessage());\n        }\n\n        return response;\n\n    }\n\n    @Override\n    public Response cancelBooking(Long bookingId) {\n        Response response = new Response();\n\n        try {\n\n            bookingRepository.findById(bookingId).orElseThrow(()-&gt; new OurException(&quot;Booking Does Not Exist&quot;));\n            bookingRepository.deleteById(bookingId);\n            response.setStatusCode(200);\n            response.setMessage(&quot;successful&quot;);\n\n        } catch (OurException e) {\n            response.setStatusCode(404);\n            response.setMessage(e.getMessage());\n        } catch (Exception e){\n            response.setStatusCode(500);\n            response.setMessage(&quot;Error Cancelling a Booking&quot;+e.getMessage());\n        }\n\n        return response;\n    }\n\n\n    // Method to check if a room is available for a given booking request\n    private boolean roomIsAvailable(Booking bookingRequest, List&lt;Booking&gt; existingBookings) {\n        // Stream through the list of existing bookings\n        return existingBookings.stream()\n                // Check if none of the existing bookings match the given conditions\n                .noneMatch(existingBooking -&gt;\n                        // Condition 1: Check if the check-in date of the booking request is the same as any existing booking's check-in date\n                        bookingRequest.getCheckInDate().equals(existingBooking.getCheckInDate())\n\n                                // Condition 2: Check if the check-out date of the booking request is before any existing booking's check-out date\n                                || bookingRequest.getCheckOutDate().isBefore(existingBooking.getCheckOutDate())\n\n                                // Condition 3: Check if the check-in date of the booking request is after the check-in date and before the check-out date of any existing booking\n                                || (bookingRequest.getCheckInDate().isAfter(existingBooking.getCheckInDate())\n                                &amp;&amp; bookingRequest.getCheckInDate().isBefore(existingBooking.getCheckOutDate()))\n\n                                // Condition 4: Check if the booking request overlaps with any existing booking\n                                || (bookingRequest.getCheckInDate().isBefore(existingBooking.getCheckOutDate())\n                                &amp;&amp; bookingRequest.getCheckOutDate().isAfter(existingBooking.getCheckInDate()))\n\n                                // Condition 5: Check if the check-in date of the booking request is equal to the check-out date and the check-out date is equal to the check-in date of any existing booking\n                                || (bookingRequest.getCheckInDate().equals(existingBooking.getCheckOutDate())\n                                &amp;&amp; bookingRequest.getCheckOutDate().equals(existingBooking.getCheckInDate()))\n\n                                // Condition 6: Check if the check-in date of the booking request is equal to the check-out date and the check-out date is equal to the check-in date of the booking request\n                                || (bookingRequest.getCheckInDate().equals(existingBooking.getCheckOutDate())\n                                &amp;&amp; bookingRequest.getCheckOutDate().equals(bookingRequest.getCheckInDate()))\n                );\n    }\n\n}\n</code></pre>\n<p><strong>BookingDTO.java</strong></p>\n<pre><code>package com.Yash.Astoria.dto;\n\nimport com.Yash.Astoria.entities.Room;\nimport com.Yash.Astoria.entities.User;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport jakarta.persistence.FetchType;\nimport jakarta.persistence.JoinColumn;\nimport jakarta.persistence.ManyToOne;\nimport jakarta.validation.constraints.Future;\nimport jakarta.validation.constraints.Min;\nimport jakarta.validation.constraints.NotNull;\nimport lombok.Data;\n\nimport java.time.LocalDate;\n\n@Data\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic class BookingDTO {\n\n    private Long id;\n    private LocalDate checkInDate;\n    private LocalDate checkOutDate;\n    private int numOfAdults;\n    private int numOfChildren;\n    private int totalNumOfGuests;\n    private String bookingConfirmationCode;\n\n    private UserDTO user;\n\n    private RoomDTO room;\n}\n</code></pre>\n<p><strong>StackTrace in Console:</strong></p>\n<pre><code>2024-08-19T22:35:34.930+05:30  INFO 19264 --- [Astoria] [nio-8081-exec-5] o.s.web.servlet.DispatcherServlet        : Completed initialization in 0 ms\njakarta.validation.ConstraintViolationException: Validation failed for classes [com.Yash.Astoria.entities.Booking] during persist time for groups [jakarta.validation.groups.Default, ]\nList of constraint violations:[\n    ConstraintViolationImpl{interpolatedMessage='check out date must be in the future', propertyPath=checkOutDate, rootBeanClass=class com.Yash.Astoria.entities.Booking, messageTemplate='check out date must be in the future'}\n]\n    at org.hibernate.boot.beanvalidation.BeanValidationEventListener.validate(BeanValidationEventListener.java:151)\n    at org.hibernate.boot.beanvalidation.BeanValidationEventListener.onPreInsert(BeanValidationEventListener.java:81)\n    at org.hibernate.action.internal.EntityIdentityInsertAction.preInsert(EntityIdentityInsertAction.java:201)\n    at org.hibernate.action.internal.EntityIdentityInsertAction.execute(EntityIdentityInsertAction.java:79)\n    at org.hibernate.engine.spi.ActionQueue.execute(ActionQueue.java:670)\n    at org.hibernate.engine.spi.ActionQueue.addResolvedEntityInsertAction(ActionQueue.java:291)\n    at org.hibernate.engine.spi.ActionQueue.addInsertAction(ActionQueue.java:272)\n    at org.hibernate.engine.spi.ActionQueue.addAction(ActionQueue.java:322)\n    at org.hibernate.event.internal.AbstractSaveEventListener.addInsertAction(AbstractSaveEventListener.java:391)\n    at org.hibernate.event.internal.AbstractSaveEventListener.performSaveOrReplicate(AbstractSaveEventListener.java:305)\n    at org.hibernate.event.internal.AbstractSaveEventListener.performSave(AbstractSaveEventListener.java:224)\n    at org.hibernate.event.internal.AbstractSaveEventListener.saveWithGeneratedId(AbstractSaveEventListener.java:137)\n    at org.hibernate.event.internal.DefaultPersistEventListener.entityIsTransient(DefaultPersistEventListener.java:175)\n    at org.hibernate.event.internal.DefaultPersistEventListener.persist(DefaultPersistEventListener.java:93)\n    at org.hibernate.event.internal.DefaultPersistEventListener.onPersist(DefaultPersistEventListener.java:77)\n    at org.hibernate.event.internal.DefaultPersistEventListener.onPersist(DefaultPersistEventListener.java:54)\n    at org.hibernate.event.service.internal.EventListenerGroupImpl.fireEventOnEachListener(EventListenerGroupImpl.java:127)\n    at org.hibernate.internal.SessionImpl.firePersist(SessionImpl.java:757)\n    at org.hibernate.internal.SessionImpl.persist(SessionImpl.java:741)\n    at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)\n    at java.base/java.lang.reflect.Method.invoke(Method.java:580)\n    at org.springframework.orm.jpa.ExtendedEntityManagerCreator$ExtendedEntityManagerInvocationHandler.invoke(ExtendedEntityManagerCreator.java:364)\n    at jdk.proxy4/jdk.proxy4.$Proxy132.persist(Unknown Source)\n    at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)\n    at java.base/java.lang.reflect.Method.invoke(Method.java:580)\n    at org.springframework.orm.jpa.SharedEntityManagerCreator$SharedEntityManagerInvocationHandler.invoke(SharedEntityManagerCreator.java:319)\n    at jdk.proxy4/jdk.proxy4.$Proxy132.persist(Unknown Source)\n    at org.springframework.data.jpa.repository.support.SimpleJpaRepository.save(SimpleJpaRepository.java:629)\n    at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)\n    at java.base/java.lang.reflect.Method.invoke(Method.java:580)\n    at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:354)\n    at org.springframework.data.repository.core.support.RepositoryMethodInvoker$RepositoryFragmentMethodInvoker.lambda$new$0(RepositoryMethodInvoker.java:277)\n    at org.springframework.data.repository.core.support.RepositoryMethodInvoker.doInvoke(RepositoryMethodInvoker.java:170)\n    at org.springframework.data.repository.core.support.RepositoryMethodInvoker.invoke(RepositoryMethodInvoker.java:158)\n    at org.springframework.data.repository.core.support.RepositoryComposition$RepositoryFragments.invoke(RepositoryComposition.java:516)\n    at org.springframework.data.repository.core.support.RepositoryComposition.invoke(RepositoryComposition.java:285)\n    at org.springframework.data.repository.core.support.RepositoryFactorySupport$ImplementationMethodExecutionInterceptor.invoke(RepositoryFactorySupport.java:628)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)\n    at org.springframework.data.repository.core.support.QueryExecutorMethodInterceptor.doInvoke(QueryExecutorMethodInterceptor.java:168)\n    at org.springframework.data.repository.core.support.QueryExecutorMethodInterceptor.invoke(QueryExecutorMethodInterceptor.java:143)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)\n    at org.springframework.data.projection.DefaultMethodInvokingMethodInterceptor.invoke(DefaultMethodInvokingMethodInterceptor.java:70)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)\n    at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:379)\n    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)\n    at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:138)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)\n    at org.springframework.data.jpa.repository.support.CrudMethodMetadataPostProcessor$CrudMethodMetadataPopulatingMethodInterceptor.invoke(CrudMethodMetadataPostProcessor.java:165)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)\n    at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:97)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)\n    at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:223)\n    at jdk.proxy4/jdk.proxy4.$Proxy143.save(Unknown Source)\n    at com.Yash.Astoria.services.impl.BookingService.saveBooking(BookingService.java:60)\n    at com.Yash.Astoria.controllers.BookingController.saveBookings(BookingController.java:23)\n    at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)\n    at java.base/java.lang.reflect.Method.invoke(Method.java:580)\n    at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:354)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:196)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\n    at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:768)\n    at org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor.proceed(AuthorizationManagerBeforeMethodInterceptor.java:269)\n    at org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor.attemptAuthorization(AuthorizationManagerBeforeMethodInterceptor.java:264)\n    at org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor.invoke(AuthorizationManagerBeforeMethodInterceptor.java:197)\n    at org.springframework.security.config.annotation.method.configuration.PrePostMethodSecurityConfiguration$DeferringMethodInterceptor.invoke(PrePostMethodSecurityConfiguration.java:200)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)\n    at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:768)\n    at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:720)\n    at com.Yash.Astoria.controllers.BookingController$$SpringCGLIB$$0.saveBookings(&lt;generated&gt;)\n    at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)\n    at java.base/java.lang.reflect.Method.invoke(Method.java:580)\n    at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:255)\n    at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:188)\n    at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)\n    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:926)\n    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:831)\n    at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\n    at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)\n    at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)\n    at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)\n    at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)\n    at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590)\n    at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)\n    at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)\n    at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)\n    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:110)\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)\n    at org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)\n    at org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)\n    at org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:100)\n    at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)\n    at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:126)\n</code></pre>\n<p>[postman screenshot 500 internal server error] (<a href=\"https://i.sstatic.net/8M5SUQsT.png\" rel=\"nofollow noreferrer\">https://i.sstatic.net/8M5SUQsT.png</a>)</p>\n<blockquote>\n<p>Expectation: validating the condition that checkOutDate should be greater than checkInDate</p>\n</blockquote>\n<blockquote>\n<p>Also, I have tried <code>@FutureOrPresent</code> annotation, and it gives the same error</p>\n</blockquote>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}