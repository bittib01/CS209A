{
  "question": {
    "tags": [
      "java",
      "rest",
      "logging",
      "slf4j"
    ],
    "owner": {
      "account_id": 357362,
      "reputation": 2341,
      "user_id": 697480,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/6bbcd5e0d55813a03ccc659f818a284c?s=256&d=identicon&r=PG",
      "display_name": "Adam Wise",
      "link": "https://stackoverflow.com/users/697480/adam-wise"
    },
    "is_answered": true,
    "view_count": 265,
    "answer_count": 1,
    "score": 2,
    "last_activity_date": 1729517228,
    "creation_date": 1714507880,
    "last_edit_date": 1714508232,
    "question_id": 78410826,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78410826/how-to-correlate-rest-errors-with-log-entries-using-slf4j",
    "title": "How to correlate REST errors with log entries using slf4j?",
    "body": "<p>In backend code, when a REST endpoint method produces an exception, the endpoint should return a payload with an appropriate http error status, such as 500. It is also a good practice that the payload of the REST response should not include the exception itself because this can leak security information. Logging the exception is also good practice for later debugging.</p>\n<p>What we would like to do is return a payload from the REST call that can be later correlated with the log entry. One way to do this would be to have a pattern like the following:</p>\n<pre class=\"lang-java prettyprint-override\"><code> // next line would be nice, but doesn't work\n long timestampOfLogEntry = LOGGER.error(&quot;Unexpected error in REST call&quot;, exception);\n // return a REST payload with the timestamp - so we can lookup the error later\n return status(INTERNAL_SERVER_ERROR, new response(&quot;Unexpected error&quot;, timestampOfLogEntry))\n</code></pre>\n<p>However, the LOGGER methods have 'void' return types, instead of returning a timestamp or anything that could be natively used to identify the log entry later.</p>\n<p>One solution would be to capture our own timestamp and include it in the log, but that would be redundant with the timestamp the logger framework creates automatically. We could also create some sort of random number to include in both the log and the return payload, but that adds noise to the log.</p>\n<p>This seems like a problem universal to all REST endpoint implementations, at least those using Java and common logging frameworks. Is there an common solution I've overlooked?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}