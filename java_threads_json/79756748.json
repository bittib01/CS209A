{
  "question": {
    "tags": [
      "java",
      "multithreading",
      "synchronization",
      "memory-visibility"
    ],
    "owner": {
      "account_id": 9300980,
      "reputation": 77,
      "user_id": 6906471,
      "user_type": "registered",
      "profile_image": "https://lh5.googleusercontent.com/-CGpoNP2vH00/AAAAAAAAAAI/AAAAAAAAFnM/txdGmmntWLE/s256-rj/photo.jpg",
      "display_name": "Igor Yarmolyk",
      "link": "https://stackoverflow.com/users/6906471/igor-yarmolyk"
    },
    "is_answered": true,
    "view_count": 114,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1757088628,
    "creation_date": 1757073848,
    "question_id": 79756748,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79756748/is-this-piece-of-code-correctly-synchronized-java-synchronization-and-memory-vi",
    "title": "Is this piece of code correctly synchronized? Java synchronization and memory visibility question",
    "body": "<p>Here is a Java class that writes messages in a parallel thread to a stream. When the <code>stop()</code> method is called, the <code>mCloseWriter</code> flag is set and the thread that writes the messages to the stream is notified of this. It also starts a thread called <code>mTimeoutThread</code>, which waits for the specified time and if the thread that writes the messages has not completed its execution, it is interrupted.</p>\n<p>In parallel, the <code>mThread</code> thread waits for the completion of <code>mWriterThread</code> and <code>mTimeoutThread</code> and then notifies <code>mListener</code> about the completion of writing.</p>\n<p>The question is, is it safe to access <code>mTimeoutThread</code> from thread <code>mThread</code> without a synchronized block in this specific case? Will <code>mThread</code> see the latest value of <code>mTimeoutThread</code>?</p>\n<p>Based on my understanding of Java, this is safe because:</p>\n<p>a) when we reach the commented line of code, the value of <code>mTimeoutThread</code> seen by <code>mThread</code> is equal to the value of <code>mTimeoutThread</code> seen by <code>mWriterThread</code> because <code>mWriterThread</code> has already completed its execution (we called <code>mWriterThread.join()</code> from <code>mThread</code>) and according to Java rules all actions in a thread happen-before any other thread successfully returns from a <code>join()</code> on that thread.</p>\n<p>b) <code>mWriterThread</code> can finish its execution in two cases:</p>\n<ol>\n<li>If the <code>stop()</code> method has set the <code>mCloseWriter</code> flag and <code>mWriterThread</code> has written all messages and sees from the <code>synchronized(mObject)</code> block that <code>mCloseWriter</code> is set to true. Here, the <code>synchronized(mObject)</code> block also guarantees that <code>mThread</code> will see the the value of <code>mTimeoutThread</code> initialized  by the <code>stop()</code> method.</li>\n<li>An exception is thrown in the <code>loopWriter()</code> method. In this case, the exception will be caught and the <code>terminate()</code> method will be called.\nSince <code>terminate()</code> is synchronized by the <code>synchronized(mObject)</code> block, after <code>terminate()</code> completes, <code>mWriterThread</code> will see the current value of <code>mTimeoutThread</code>. And since <code>terminate()</code> also sets the value of <code>mException</code>, which prevents the value of <code>mTimeoutThread</code> from being changed by the <code>stop()</code> method, <code>mWriterThread</code> will observe the last possible value of <code>mTimeoutThread</code>.</li>\n</ol>\n<p>And based on the above sequence of events, <code>mThread</code> will see the current value of <code>mTimeoutThread</code> even without the <code>synchronized(mObject)</code> block and this class has no synchronization problems. However, I loaded this code into ChatGPT and it thinks there is a data race. So, is the code below properly synchronized?</p>\n<pre><code>public class MessageWriter {\n    private final OutputStream mStream;\n    private Thread mWriterThread;\n    private Thread mTimeoutThread;\n    private boolean mCloseWriter;\n    private Thread mThread;\n    private final Object mObject = new Object();\n    private Exception mException;\n    private final Listener mListener;\n    private final LinkedList&lt;byte[]&gt; mMessageQueue = new LinkedList&lt;&gt;();\n\n    public MessageWriter(OutputStream stream, Listener listener) {\n        mStream = stream;\n        mListener = listener;\n        start();\n    }\n\n    private void start() {\n        synchronized (mObject) {\n            mThread = new Thread(() -&gt; {\n                    startWriterThread();\n                    joinThread(mWriterThread);\n                    \n                    /*Is it safe to access mTimeoutThread without \n                      a synchronized block here?*/\n                    if (mTimeoutThread != null) {      \n                        joinThread(mTimeoutThread);\n                    }\n                    mListener.onClosed(mException);\n                });\n           mThread.start();\n        }\n    }\n\n    private void startWriterThread() {\n        synchronized (mObject) {\n            mWriterThread = new Thread(() -&gt; {\n                try {\n                    loopWriter();\n                } catch (Exception e) {\n                    terminate(e);\n                }\n            });\n            mWriterThread.start();\n        }\n    }\n\n    public void stop() {\n        synchronized (mObject) {\n            if (!mCloseWriter &amp;&amp; mException == null) {\n                mCloseWriter = true;\n                mTimeoutThread = new Thread(() -&gt; {\n                    try {\n                        waitAndThrow(5000);\n                    } catch(InterruptedException ignored){\n                    } catch (Exception e) {\n                        terminate(e);\n                    }\n                });\n                mTimeoutThread.start();\n\n                mObject.notifyAll();\n            }\n        }\n    }\n\n\n    private void terminate(Exception exception) {\n        synchronized (mObject) {\n            if (mException == null) {\n                mException = exception;\n                mWriterThread.interrupt();\n                mTimeoutThread.interrupt();\n                mThread.interrupt();\n            }\n        }\n    }\n\n    private static void joinThread(Thread thread) {\n        do {\n            try { thread.join(); } catch (InterruptedException ignored) {}\n        } while (thread.isAlive());\n    }\n\n    private byte[] nextMessage() throws InterruptedException {\n        synchronized (mObject) {\n            while (mMessageQueue.isEmpty()) {\n                if (mCloseWriter) return null;\n                mObject.wait();\n            }\n            return mMessageQueue.remove();\n        }\n    }\n    private void loopWriter() throws InterruptedException, IOException {\n        while (true) {\n            final byte[] message = nextMessage();\n            if (message == null) {\n                synchronized (mObject) {\n                   mTimeoutThread.interrupt();\n                }\n                return;\n            }\n            mStream.write(message);\n        }\n    }\n    \n    public void writeMessage(byte[] message) {\n        synchronized (mObject) {\n            if (mCloseWriter || mException != null) {\n                return;\n            }\n            if (mMessageQueue.isEmpty()) {\n                mObject.notifyAll();\n            }\n            mMessageQueue.add(message);\n        }\n    }\n\n    private static void waitAndThrow(long timeoutMillis) throws InterruptedException {\n        for (long deadline = System.currentTimeMillis() + timeoutMillis;;) {\n            final long currentUptime = System.currentTimeMillis();\n\n            if (currentUptime &lt;= deadline) {\n                throw new RuntimeException(&quot;Timeout!!!&quot;);\n            }\n            Thread.sleep(deadline - currentUptime);\n        }\n    }\n\n    public interface Listener {\n        void onClosed(Exception exception);\n    }\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}