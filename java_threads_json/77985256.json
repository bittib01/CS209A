{
  "question": {
    "tags": [
      "java",
      "spring",
      "spring-security"
    ],
    "owner": {
      "account_id": 23652212,
      "reputation": 35,
      "user_id": 17680942,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/42594676c45ece169e9eceb3e4d88c52?s=256&d=identicon&r=PG",
      "display_name": "Jumple",
      "link": "https://stackoverflow.com/users/17680942/jumple"
    },
    "is_answered": false,
    "view_count": 210,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1754371875,
    "creation_date": 1707790475,
    "last_edit_date": 1754371875,
    "question_id": 77985256,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/77985256/spring-security-maximumsessions-not-working-when-using-custom-filter",
    "title": "Spring Security maximumSessions not working when using custom filter",
    "body": "<p>Environment:</p>\n<ul>\n<li>Spring Boot: 3.2.2.</li>\n<li>Spring Security: 6.2.1</li>\n</ul>\n<p>I'm currently using a custom filter to support JSON formatted data in requests. I also want to use <code>maximumSessions</code> to limit user that can only login in a browser at the same time.</p>\n<p>I learned from an article on the internet that it seems necessary to set <code>ConcurrentSessionControlAuthenticationStrategy</code> in the custom filter bean.</p>\n<p>Here is my config code:</p>\n<pre><code>    @Bean\n    public LoginFilter loginFilter(AuthenticationManager authenticationManager) throws Exception {\n        LoginFilter loginFilter = new LoginFilter();\n        loginFilter.setFilterProcessesUrl(&quot;/doLogin&quot;);\n        loginFilter.setAuthenticationManager(authenticationManager);\n        loginFilter.setSecurityContextRepository(new DelegatingSecurityContextRepository(\n                new RequestAttributeSecurityContextRepository(),\n                new HttpSessionSecurityContextRepository()\n        ));\n        loginFilter.setAuthenticationSuccessHandler((request, response, authentication) -&gt; {\n            ...\n        });\n        loginFilter.setAuthenticationFailureHandler((request, response, exception) -&gt; {\n            ...\n        });\n\n        ConcurrentSessionControlAuthenticationStrategy strategy = new ConcurrentSessionControlAuthenticationStrategy(sessionRegistry());\n        strategy.setMaximumSessions(1);\n        loginFilter.setSessionAuthenticationStrategy(strategy);\n\n        return loginFilter;\n    }\n\n\n    @Bean\n    public SessionRegistry sessionRegistry() {\n        return new SessionRegistryImpl();\n    }\n\n    @Bean\n    public HttpSessionEventPublisher httpSessionEventPublisher() {\n        return new HttpSessionEventPublisher();\n    }\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity, LoginFilter loginFilter) throws Exception {\n        httpSecurity\n                .sessionManagement(session -&gt; session.maximumSessions(1).maxSessionsPreventsLogin(true))\n                .addFilterAt(new ConcurrentSessionFilter(sessionRegistry(), event -&gt; {\n                    HttpServletResponse resp = event.getResponse();\n                    resp.setContentType(&quot;application/json;charset=utf-8&quot;);\n                    resp.setStatus(401);\n                    PrintWriter out = resp.getWriter();\n                    out.write(&quot;Already logged in on another device.&quot;);\n                    out.flush();\n                    out.close();\n                }), ConcurrentSessionFilter.class)\n                .addFilterAt(loginFilter, UsernamePasswordAuthenticationFilter.class)\n                .authorizeHttpRequests(\n                        requests -&gt; requests\n                                .requestMatchers(&quot;/css/**&quot;, &quot;/js/**&quot;, &quot;/images/**&quot;, &quot;/getVerifyCode&quot;).permitAll()\n                                .requestMatchers(&quot;/error&quot;).permitAll()\n                                .anyRequest().authenticated()\n                )              \n                .logout(logout -&gt; logout.logoutUrl(&quot;/doLogout&quot;)\n                        .logoutSuccessHandler((request, response, authentication) -&gt; {\n                            ...\n                        })\n                )\n                .csrf(csrfConfigurer -&gt; csrfConfigurer.disable())\n                .exceptionHandling(exceptionHandler -&gt; exceptionHandler.authenticationEntryPoint((request, response, authException) -&gt; {\n                    log.error(authException);                  \n                }));\n\n\n        return httpSecurity.build();\n    }\n\n\n</code></pre>\n<p>And Here is the code of <code>LoginFilter</code></p>\n<pre><code>@Log4j2\npublic class LoginFilter extends UsernamePasswordAuthenticationFilter {\n    private final ObjectMapper objectMapper;\n    private SessionRegistry sessionRegistry;\n\n    public LoginFilter() {\n        super();\n        objectMapper = new ObjectMapper();\n    }\n\n    @Autowired\n    public void setSessionRegistry(SessionRegistry sessionRegistry) {\n        this.sessionRegistry = sessionRegistry;\n    }\n\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n        if (!request.getMethod().equals(&quot;POST&quot;)) {\n            throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod());\n        }\n\n        String verifyCode = (String) request.getSession().getAttribute(&quot;verify_code&quot;);\n        Map&lt;String, String&gt; requestParameters = new HashMap&lt;&gt;();\n        if (MediaType.APPLICATION_JSON_VALUE.equals(request.getContentType())) {\n            requestParameters = extractRequestParametersFromJson(request);\n        } else {\n            requestParameters = extractRequestParametersFromForm(request);\n        }\n\n        String code = requestParameters.get(&quot;code&quot;);\n        checkoutVerifyCode(code, verifyCode);\n\n        String username = requestParameters.get(getUsernameParameter());\n        String password = requestParameters.get(getPasswordParameter());\n\n        username = username != null ? username.trim() : &quot;&quot;;\n        password = password != null ? password : &quot;&quot;;\n        UsernamePasswordAuthenticationToken authRequest = UsernamePasswordAuthenticationToken.unauthenticated(username, password);\n        this.setDetails(request, authRequest);\n\n        sessionRegistry.registerNewSession(request.getSession().getId(), authRequest.getPrincipal());\n        return this.getAuthenticationManager().authenticate(authRequest);\n    }\n}\n\n</code></pre>\n<p>I'm new in Spring Security so I'm not sure if the configuration is incorrect or if there are missing parts.<br />\nIf someone could point out the issue, I would greatly appreciate it.</p>\n<p><strong>Update</strong></p>\n<p>I read the source code and realized that when a user logs in, <code>ConcurrentSessionControlAuthenticationStrategy#onAuthentication</code> will be called, and inside this method is <code>SessionRegistryImpl#getAllSessions</code>. Inside this method, it will call the <code>this.principals.get(principal)</code> method, where <code>principals</code> is a <code>ConcurrentMap&lt;Object, Set&lt;String&gt;&gt;</code> and <code>principal</code> is an <code>Object</code> used as the map's key.</p>\n<p>The <code>principal</code> actually is my custom <code>User</code> class and has overridden <code>equals()</code> and <code>hashCode()</code>. However, the strange thing is that when I set a breakpoint on <code>equals()</code>, it shows that the parameter of <code>equals()</code> is a <code>String</code> object. I am confused as to why the <code>Map</code> uses the <code>User</code> object as a key but there is a <code>String</code> object in <code>equals()</code>.</p>\n<p>This strange situation only happens when I use my custom filter which extends <code>UsernamePasswordAuthenticationFilter</code>. If I use the default <code>HttpSecurity#formLogin</code> and set the <code>sessionManagement</code>, it works normally.</p>\n<p>When using <code>HttpSecurity#formLogin</code>, the parameter of <code>equals()</code> shows the type is <code>User</code>. I would like to know what causes the difference from <code>HttpSecurity#formLogin</code> and my custom filter.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}