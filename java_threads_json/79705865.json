{
  "question": {
    "tags": [
      "java",
      "maven",
      "dependencies",
      "maven-3"
    ],
    "owner": {
      "account_id": 2344577,
      "reputation": 3815,
      "user_id": 2055163,
      "user_type": "registered",
      "accept_rate": 81,
      "profile_image": "https://www.gravatar.com/avatar/38e40a8a1f83778784f9ffbed05584ed?s=256&d=identicon&r=PG",
      "display_name": "Thorsten Sch&#246;ning",
      "link": "https://stackoverflow.com/users/2055163/thorsten-sch%c3%b6ning"
    },
    "is_answered": true,
    "view_count": 95,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1752829034,
    "creation_date": 1752825629,
    "question_id": 79705865,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79705865/why-does-maven-multi-module-project-resolve-dependencies-based-on-nexus-but-bui",
    "title": "Why does Maven multi-module project resolve dependencies based on Nexus, but builds based on local files?",
    "body": "<p>I have a pretty basic multi-module project. The parent is aware of the two modules, the two modules are aware of the parent and <code>module2</code> includes <code>module1</code> as dependency as well. So far everything works as expected, the application runs etc.</p>\n<ul>\n<li>parent\n<ul>\n<li>module1</li>\n<li>module2</li>\n</ul>\n</li>\n</ul>\n<p>I needed to update a dependency in <code>module1</code> and when using <code>mvn dependency:tree</code>, I see the updated dependency. Though, when I do the same for <code>module2</code>, it still shows the outdated dependency as a transient dependency of <code>module1</code>. From my understanding, the reason is that I have an outdated snapshot of <code>module1</code> in Nexus and my local <code>.m2</code> directory, whichever of both might be taken into account.</p>\n<p>The result of this is that <code>module2</code> starts successfully, but at runtime fails at some point, because a method is called on the dependency of <code>module1</code> which, doesn't exist in the older version, but only the newer one. But still, the <code>module1</code> is correctly build with the newer version of the dependency, <code>module2</code> seems to link against <code>module1</code> of the multi-module project, but starts with a classpath containing an outdated dependency of <code>module1</code>, breaking at runtime in the end.</p>\n<pre><code>The following method did not exist:\n\n    'java.lang.Object org.apache.commons.lang3.ObjectUtils.getIfNull(java.lang.Object, java.lang.Object)'\n[...]\nThe called method's class, org.apache.commons.lang3.ObjectUtils, is available from the following locations:\n\n    jar:file:/C:/Users/THS/.m2/repository/org/apache/commons/commons-lang3/3.17.0/commons-lang3-3.17.0.jar!/org/apache/commons/lang3/ObjectUtils.class\n\nThe called method's class hierarchy was loaded from the following locations:\n\n    org.apache.commons.lang3.ObjectUtils: file:/C:/Users/THS/.m2/repository/org/apache/commons/commons-lang3/3.17.0/commons-lang3-3.17.0.jar\n</code></pre>\n<p>This looks like a runtime classpath issue to me, because the outdated version of <code>module1</code> in Nexus or <code>.m2</code> not only has an outdated dependency, but the classes of the <code>module1</code> were renamed as well. But those are properly used by <code>module2</code>. <code>module2</code> isn't able at all to work with the outdated version of <code>module1</code> in Nexus and <code>.m2</code>, there is a strong coupling, class names would be different etc. Things couldn't even start at all...</p>\n<p><strong>Why is that snapshot taken into account when resolving dependencies and creating the runtime classpath instead of what is contained in the multi-module project only?</strong></p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}