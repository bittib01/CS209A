{
  "question": {
    "tags": [
      "java",
      "oracle-database",
      "jdbc",
      "connection-pooling",
      "tns"
    ],
    "owner": {
      "account_id": 19578991,
      "reputation": 73,
      "user_id": 14328474,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/91989a925ac776572667c2f91ff31743?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Carlos Avila",
      "link": "https://stackoverflow.com/users/14328474/carlos-avila"
    },
    "is_answered": false,
    "view_count": 179,
    "answer_count": 0,
    "score": 0,
    "last_activity_date": 1724353350,
    "creation_date": 1724352302,
    "last_edit_date": 1724353350,
    "question_id": 78903068,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78903068/i-always-get-oracle-net-jdbc-nl-invalidsyntaxexception-twice-and-in-the-third-at",
    "title": "I always get oracle.net.jdbc.nl.InvalidSyntaxException twice and in the third attempt the call succeeds",
    "body": "<p>We have a Spring Boot application which utilizes Spring Data to call stored procedures in a Oracle Database.\nWhenever the application accesses the database, we can see in Dynatrace an exception:</p>\n<p>oracle.net.jdbc.nl.InvalidSyntaxException\nMessage:\nTNS-***** Invalid syntax error: Expected &quot;(&quot; before or at , cn =</p>\n<p>This a sample database URL we utilize:</p>\n<p><code>jdbc:oracle:thin:@ldap://mydomain.com:938/DAFPRXHSUSR,cn=OracleContext,dc=eusovd,dc=com</code></p>\n<p>This url follows the oracle connection string syntax for LDAP connections</p>\n<p>This exception is thrown twice and then in a third attempt it succeeds to execute the actual call to the database, the thing to notice here is that we didn't code any retry logic, I'm suspecting that</p>\n<p>a)the Oracle Driver jar has some retry logic within or that\nb)maybe the library makes 2 calls before doing the one we coded and that these 2 previous calls are the ones having the issue.</p>\n<p>Somehow the driver I think it thinks it's a TNS URL , fails twice and in the 3rd retry it finally gets connected, I don't know if it finally detects it's an LDPAP URL or it reconverts the URL to a TNS format, or if as I mentioned, the driver throws 2 previous calls to the database with wrong URL syntax and then executes the actual call with the right URL syntax</p>\n<p>This is the exception stack:</p>\n<pre><code>Exception:\noracle.net.jdbc.nl.InvalidSyntaxException\nMessage:\nTNS-***** Invalid syntax error: Expected &quot;(&quot; before or at , cn =\nStacktrace:\noracle.net.jdbc.nl.NVFactory._readTopLevelNVPair(NVFactory.java:97)\noracle.net.jdbc.nl.NVFactory.createNVPair(NVFactory.java:65)\noracle.jdbc.driver.PhysicalConnection.isDRCPConnection(PhysicalConnection.java:11325)\noracle.jdbc.driver.PhysicalConnection.connect(PhysicalConnection.java:1199)\noracle.jdbc.driver.T4CDriverExtension.getConnection(T4CDriverExtension.java:105)\noracle.jdbc.driver.OracleDriver.connect(OracleDriver.java:886)\noracle.jdbc.datasource.impl.OracleDataSource.getPhysicalConnection(OracleDataSource.java:707)\noracle.jdbc.datasource.impl.OracleDataSource.getConnection(OracleDataSource.java:381)\noracle.jdbc.datasource.impl.OracleDataSource.getConnectionInternal(OracleDataSource.java:2206)\noracle.jdbc.datasource.impl.OracleDataSource.getConnection(OracleDataSource.java:354)\noracle.jdbc.datasource.impl.OracleDataSource.getConnection(OracleDataSource.java:315)\norg.springframework.jdbc.datasource.DataSourceUtils.fetchConnection(DataSourceUtils.java:157)\norg.springframework.jdbc.datasource.DataSourceUtils.doGetConnection(DataSourceUtils.java:115)\norg.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:78)\norg.springframework.jdbc.support.JdbcUtils.extractDatabaseMetaData(JdbcUtils.java:319)\norg.springframework.jdbc.core.metadata.CallMetaDataProviderFactory.createMetaDataProvider(CallMetaDataProviderFactory.java:74)\norg.springframework.jdbc.core.metadata.CallMetaDataContext.initializeMetaData(CallMetaDataContext.java:253)\norg.springframework.jdbc.core.simple.AbstractJdbcCall.compileInternal(AbstractJdbcCall.java:314)\norg.springframework.jdbc.core.simple.AbstractJdbcCall.compile(AbstractJdbcCall.java:297)\norg.springframework.jdbc.core.simple.AbstractJdbcCall.checkCompiled(AbstractJdbcCall.java:356)\norg.springframework.jdbc.core.simple.AbstractJdbcCall.doExecute(AbstractJdbcCall.java:383)\norg.springframework.jdbc.core.simple.SimpleJdbcCall.execute(SimpleJdbcCall.java:187)\ncom.esrx.services.inventory.scanner.persistence.repository.impl.InventoryCountsRepositoryImpl.getSnapshotsList(InventoryCountsRepositoryImpl.java:70)\ncom.esrx.services.inventory.scanner.persistence.repository.impl.InventoryCountsRepositoryImpl$$FastClassBySpringCGLIB$$970dd8c.invoke(&lt;generated&gt;)\norg.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\norg.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:749)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\norg.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:139)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\norg.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688)\ncom.esrx.services.inventory.scanner.persistence.repository.impl.InventoryCountsRepositoryImpl$$EnhancerBySpringCGLIB$$.getSnapshotsList\ncom.esrx.services.inventory.scanner.core.service.impl.InventoryCountsServiceImpl.getSnapshotsList(InventoryCountsServiceImpl.java:35)\ncom.esrx.services.inventory.scanner.web.controller.InventoryCountsController.getSnapshots(InventoryCountsController.java:56)\njdk.internal.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java)\njdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\njdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n</code></pre>\n<p>This is one code snippet of one of our calls, the exception is thrown within the SimpleJdbcCall.execute() method:</p>\n<pre><code>SimpleJdbcCall jdbcCall = new SimpleJdbcCall(\n                    dataSourcePool.getCurrentUserJdbcTemplate())\n                    .withoutProcedureColumnMetaDataAccess()\n                    .withSchemaName(Constants.SCHEMA_NAME)\n                    .withCatalogName(Constants.CATALOG_NAME)\n                    .withProcedureName(Constants.ASSIGN_COUNTSHEET_ROW)\n                    .declareParameters(new SqlParameter(Constants.P_SNAPSHOT_ID, Types.NUMERIC),\n                            new SqlParameter(Constants.P_COUNT_SHEET_NUMBER, Types.NUMERIC),\n                            new SqlParameter(Constants.P_SEARCH_WHBIN, \n                            new SqlOutParameter(&quot;p_abbrv&quot;, Types.VARCHAR));\n\n            SqlParameterSource paramsIn = new MapSqlParameterSource()\n                    .addValue(Constants.P_SNAPSHOT_ID, pSnapshotId)\n                    .addValue(Constants.P_COUNT_SHEET_NUMBER, pCountSheetNumber)\n                    .addValue(Constants.P_SEARCH_WHBIN, searchWhbin);\n\n            Map&lt;String, Object&gt; out = jdbcCall.execute(paramsIn);\n\n\n</code></pre>\n<p>This is another code snippet, the difference here is that  we also get the exception but only once, and we see that in a second attempt it succeeds. It's important to notice this is the code the application utilizes to create the datasource that is utilized for all database calls:</p>\n<pre><code>public OracleDataSource getDataSource(String username, String credential) throws SQLException {\n\n        log.info(&quot;..:: --&gt; Create DataSource &lt;-- ::..&quot;);\n        OracleDataSource dataSource = new OracleDataSource();\n        dataSource.setUser(username);\n        dataSource.setPassword(credential);\n        dataSource.setURL(this.getUrl());\n\n    //  dataSource.getFastConnectionFailoverEnabled();\n\n        // Try to get the connection, if credentials are not valid it will\n        // not connect and throw an SQLException\n        try(OracleConnection connection = (OracleConnection) dataSource.getConnection()){\n            \n        }\n        \n\n        log.info(&quot;Succesful datasource creation for user {}&quot;, username);\n\n        return dataSource;\n    }\n</code></pre>\n<p>Yes, this OracleDataSource class is not pooled, but that's the application requirement</p>\n<p><strong>Java versions tested: 8, 11</strong>\n<strong>Oracle database version: 19.0.0.0.0</strong></p>\n<p>These are the Oracle driver versions that have been tested and have the issue (pom.xml):</p>\n<pre><code>&lt;dependency&gt;\n            &lt;groupId&gt;com.oracle.ojdbc&lt;/groupId&gt;\n            &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt;\n            &lt;version&gt;19.3.0.0&lt;/version&gt;\n            &lt;exclusions&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;\n                                com.oracle.ojdbc\n                            &lt;/groupId&gt;\n                    &lt;artifactId&gt;simplefan&lt;/artifactId&gt;\n                &lt;/exclusion&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;com.oracle.ojdbc&lt;/groupId&gt;\n                    &lt;artifactId&gt;ons&lt;/artifactId&gt;\n                &lt;/exclusion&gt;\n            &lt;/exclusions&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<pre><code>&lt;dependency&gt;\n            &lt;groupId&gt;com.oracle.database.jdbc&lt;/groupId&gt;\n            &lt;artifactId&gt;ojdbc11&lt;/artifactId&gt;\n            &lt;version&gt;23.5.0.24.07&lt;/version&gt;\n            &lt;exclusions&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;com.oracle.ojdbc&lt;/groupId&gt;\n                    &lt;artifactId&gt;simplefan&lt;/artifactId&gt;\n                &lt;/exclusion&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;com.oracle.ojdbc&lt;/groupId&gt;\n                    &lt;artifactId&gt;ons&lt;/artifactId&gt;\n                &lt;/exclusion&gt;\n            &lt;/exclusions&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>I have tried upgrading from java 8 to java 11, algo upgrading the oracle driver from ojdbc8 19.3.0.0 to ojdbc11 23.5.0.24.07, but the problem persists.</p>\n<p>Also, I've changed the way we create the datasource replacing OracleDataSource with the pooled datasource HikariDataSource, and the problem is gone!\nSo somehow I think the problem is when utilizing OracleDataSource class, but I can't use the HikariDataSource because we need to login different oracle users to the application with their own Oracle connection (user/password pair), and the HikariDataSource only lets me have one connection pool with one database user. This is the code snippet that utilizes HikariDataSource:</p>\n<pre><code>public DataSource getDataSourceV2(String username, String credential) throws SQLException {\n        log.info(&quot;..:: Create DataSource v2 ::..&quot;);\n        DataSource ds = DataSourceBuilder.create()\n        .username(username)\n        .password(credential)\n        .url(url)\n        .type(HikariDataSource.class)\n        .build();\n        \n        HikariDataSource hds = (HikariDataSource) ds;\n        hds.setMaximumPoolSize(1);\n        try(Connection conn = ds.getConnection()){\n            \n        }\n        log.info(&quot;Succesful datasource creation for user {}&quot;, username);\n        return ds;\n    }\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}