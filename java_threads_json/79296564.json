{
  "question": {
    "tags": [
      "java",
      "oracle-database",
      "jpa",
      "composite-key",
      "batch-insert"
    ],
    "owner": {
      "account_id": 9526522,
      "reputation": 11,
      "user_id": 7079586,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/3596dbe6ac5454f60a3fce53acdc6dd2?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Antoine",
      "link": "https://stackoverflow.com/users/7079586/antoine"
    },
    "is_answered": false,
    "view_count": 288,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1742943568,
    "creation_date": 1734682400,
    "last_edit_date": 1734682472,
    "question_id": 79296564,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79296564/how-can-i-batch-insert-in-jpa-with-a-composite-id",
    "title": "How can I Batch insert in JPA with a composite ID?",
    "body": "<p>I'm using JPA (3.1.1) on all my project and I managed to make everything run smoothly so far, but I'm encountering issues on bacth inserting in an Oracle GTT (global temporary table). (Oracle is in 19C)</p>\n<p>My table has no PK (id) and only contains four columns; I need to load up to millions of keys in it, and then run queries on the database side for efficiency.</p>\n<p>My problem lies with the loading process; it is very slow because Hibernate runs the insert statements one by one.</p>\n<p>Here is what my log looks like. I would expect some kind of batching, like &quot;INSERT ALL&quot;, and definitely less time communicating with the server. At least I got rid of the select before inserts with the &quot;isNew()&quot; logic of Persistable implementation...</p>\n<pre><code>2024-12-19 18:33:57,594 DEBUG org.hibernate.engine.jdbc.spi.SqlStatementLogger [scheduling-3] insert into XXX.MY_TMP_TABLE (ADDITIONAL_DATA,AN_ENUM,A_BOOLEAN,A_STRING) values (?,?,?,?)\n2024-12-19 18:33:57,594 TRACE org.hibernate.type.descriptor.JdbcBindingLogging [scheduling-3] binding parameter [1] as [VARCHAR] - [xx1]\n2024-12-19 18:33:57,594 TRACE org.hibernate.type.descriptor.JdbcBindingLogging [scheduling-3] binding parameter [2] as [VARCHAR] - [I]\n2024-12-19 18:33:57,594 TRACE org.hibernate.type.descriptor.JdbcBindingLogging [scheduling-3] binding parameter [3] as [BOOLEAN] - [true]\n2024-12-19 18:33:57,594 TRACE org.hibernate.type.descriptor.JdbcBindingLogging [scheduling-3] binding parameter [4] as [VARCHAR] - [abcd]\n2024-12-19 18:33:57,595 DEBUG org.hibernate.engine.jdbc.spi.SqlStatementLogger [scheduling-3] insert into XXX.MY_TMP_TABLE (ADDITIONAL_DATA,AN_ENUM,A_BOOLEAN,A_STRING) values (?,?,?,?)\n2024-12-19 18:33:57,595 TRACE org.hibernate.type.descriptor.JdbcBindingLogging [scheduling-3] binding parameter [1] as [VARCHAR] - [xx1]\n2024-12-19 18:33:57,595 TRACE org.hibernate.type.descriptor.JdbcBindingLogging [scheduling-3] binding parameter [2] as [VARCHAR] - [I]\n2024-12-19 18:33:57,595 TRACE org.hibernate.type.descriptor.JdbcBindingLogging [scheduling-3] binding parameter [3] as [BOOLEAN] - [true]\n2024-12-19 18:33:57,596 TRACE org.hibernate.type.descriptor.JdbcBindingLogging [scheduling-3] binding parameter [4] as [VARCHAR] - [abce]\n2024-12-19 18:33:57,596 DEBUG org.hibernate.engine.jdbc.spi.SqlStatementLogger [scheduling-3] insert into XXX.MY_TMP_TABLE (ADDITIONAL_DATA,AN_ENUM,A_BOOLEAN,A_STRING) values (?,?,?,?)\n2024-12-19 18:33:57,596 TRACE org.hibernate.type.descriptor.JdbcBindingLogging [scheduling-3] binding parameter [1] as [VARCHAR] - [xx1]\n2024-12-19 18:33:57,596 TRACE org.hibernate.type.descriptor.JdbcBindingLogging [scheduling-3] binding parameter [2] as [VARCHAR] - [I]\n2024-12-19 18:33:57,596 TRACE org.hibernate.type.descriptor.JdbcBindingLogging [scheduling-3] binding parameter [3] as [BOOLEAN] - [true]\n2024-12-19 18:33:57,597 TRACE org.hibernate.type.descriptor.JdbcBindingLogging [scheduling-3] binding parameter [4] as [VARCHAR] - [abcf]\n\n</code></pre>\n<p>Here is my entity:</p>\n<pre><code>@Entity\n@Table(schema = &quot;XXX&quot;, name = &quot;MY_TMP_TABLE&quot;)\npublic class MyEntity implements Persistable&lt;MyPK&gt; {\n\n    @EmbeddedId\n    private MyPK id;\n\n    @Column(name = &quot;ADDITIONAL_DATA&quot;, nullable = false)\n    private String additionalData;\n\n    @Transient\n    private boolean isNew;\n\n    /**\n     * Creator with &quot;isNew&quot; flag to avoid SELECT before INSERT in batch treatments\n     * \n     * @param aIsNew true if we are certain the key does not exist in the database\n     */\n    public MyEntity(boolean aIsNew) {\n        super();\n        this.isNew = aIsNew;\n    }\n\n    /**\n     * @return the composite ID\n     */\n    @Override\n    public MyPK getId() {\n        return id;\n    }\n\n    /**\n     * Sets the composite ID\n     * \n     * @param anId the ID\n     */\n    public void setId(MyPK anId) {\n        this.id = anId;\n    }\n\n    /**\n     * @return the additional data\n     */\n    public String getAdditionalData() {\n        return additionalData;\n    }\n\n    /**\n     * @param anAdditionalData the additional data to set\n     */\n    public void setAdditionalData(String anAdditionalData) {\n        this.additionalData = anAdditionalData;\n    }\n\n    @Override\n    public boolean isNew() {\n        return isNew;\n    }\n}\n</code></pre>\n<p>And embedded Id:</p>\n<pre><code>@Embeddable\npublic class MyPK {\n    @Column(name = &quot;A_STRING&quot;, nullable = false)\n    private String aString;\n\n    @Column(name = &quot;AN_ENUM&quot;, nullable = false)\n    @Convert(converter = AConverter.class)\n    private AnEnum anEnum;\n\n    @Column(name = &quot;A_BOOLEAN&quot;, nullable = false)\n    private boolean aBoolean;\n\n    /**\n     * @return the String\n     */\n    public String getAString() {\n        return aString;\n    }\n\n    /**\n     * @param aString the String to set\n     */\n    public void setAString(String aString) {\n        this.aString = aString;\n    }\n\n    /**\n     * @return the enum\n     */\n    public AnEnum getAnEnum() {\n        return anEnum;\n    }\n\n    /**\n     * @param anEnum the enum to set\n     */\n    public void setAnEnum(AnEnum anEnum) {\n        this.anEnum  = anEnum;\n    }\n\n    /**\n     * @return the boolean\n     */\n    public boolean getABoolean() {\n        return aBoolean;\n    }\n\n    /**\n     * @param aBoolean the boolean to set\n     */\n    public void setBoolean(boolean aBoolean) {\n        this.aBoolean = aBoolean;\n    }\n\n}\n</code></pre>\n<p>Here is what my insertions look like (and I tried saveAll() with collections too with no success)</p>\n<pre><code>    myEntityRepository.save(myEntity);\n    if (nbTotal % batchSize == 0) {\n        myEntityRepository.flush();\n    }\n</code></pre>\n<p>And finally my jpa configuration:</p>\n<pre><code>        properties.setProperty(&quot;hibernate.jdbc.batch_size&quot;, dbOkcJpaBatchSize); --100\n        properties.setProperty(&quot;hibernate.order_inserts&quot;, dbOkcJpaOrderInserts); --true\n        properties.setProperty(&quot;hibernate.order_updates&quot;, dbOkcJpaOrderUpdates); --true\n</code></pre>\n<p>I'm getting desperate, I would like to avoid using jdbc statements with native queries, or modifying the database to add a numerical ID + a sequence that seem useless to me...</p>\n<p>I'm hoping some other devs found a solution for something similar...</p>\n<p>Thanks y'all!</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}