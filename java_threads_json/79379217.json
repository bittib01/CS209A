{
  "question": {
    "tags": [
      "java",
      "algorithm",
      "time-complexity"
    ],
    "owner": {
      "account_id": 31187804,
      "reputation": 794,
      "user_id": 23993901,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/7417aaad0c8ece3fac44f06d05a8ba8b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "CodeCrusader",
      "link": "https://stackoverflow.com/users/23993901/codecrusader"
    },
    "is_answered": true,
    "view_count": 160,
    "accepted_answer_id": 79379636,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1737604327,
    "creation_date": 1737580144,
    "last_edit_date": 1737604327,
    "question_id": 79379217,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79379217/given-tasks-and-programmers-solve-the-tasks-in-less-time",
    "title": "Given tasks and programmers solve the tasks in less time",
    "body": "<p>I have a list of tasks of size <code>n</code> and the time taken to process is represented as <code>tasks[i]</code>, where <code>i</code> is index for the task.</p>\n<p><strong>Processing Step:</strong> These tasks should be processed sequentially from <code>i = 0</code> to <code>i = n-1</code>, one after the other.</p>\n<p>Now there is another list of programmers of size <code>m</code>, who can work on the tasks for a specified duration represented by <code>programmers[i]</code>, where <code>i</code> is the index.</p>\n<p>A task is said to be completed if its value is 0, otherwise it is a pending task.</p>\n<p>So if there are some tasks pending by end of above mentioned processing step, processing should start again from <code>i = 0</code> to <code>i = n-1</code></p>\n<p>If all tasks are finished, then we can load the tasks back and start the processing from beginning.</p>\n<p>I want to collect how many tasks are still pending after each programmer works for their specified duration.</p>\n<p>Here is an example:</p>\n<h2>Example 1</h2>\n<p>n=5, tasks = <code>[2, 4, 5, 1, 1]</code>\nm=5, programmers = <code>[1, 5, 1, 5, 2]</code></p>\n<div class=\"s-table-container\"><table class=\"s-table\">\n<thead>\n<tr>\n<th>Programmer</th>\n<th>Tasks</th>\n<th>Pending tasks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td><code>[1, 4, 5, 1, 1]</code></td>\n<td>The first task is partially processed, total pending tasks = 5</td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>[0, 0, 5, 1, 1]</code></td>\n<td>The first two tasks are fully processed, total pending tasks = 3</td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>[0, 0, 4, 1, 1]</code></td>\n<td>The third task is partially processed, total pending tasks = 3</td>\n</tr>\n<tr>\n<td>4</td>\n<td><code>[0, 0, 0, 0, 1]</code></td>\n<td>The third and fourth tasks are fully processed, total pending tasks = 1</td>\n</tr>\n<tr>\n<td>5</td>\n<td><code>[0, 0, 0, 0, 0]</code></td>\n<td>The last task is fully processed, total pending tasks = 0</td>\n</tr>\n</tbody>\n</table></div>\n<p>Hence, the number of pending tasks = <code>[5, 3, 3, 1, 0]</code></p>\n<h2>Example 2</h2>\n<p>tasks = <code>[1, 2, 4, 1, 2]</code>\nprogrammers = <code>[3, 10, 1, 1, 1]</code></p>\n<div class=\"s-table-container\"><table class=\"s-table\">\n<thead>\n<tr>\n<th>Programmer</th>\n<th>Tasks</th>\n<th>Pending tasks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td><code>[0, 0, 4, 1, 2]</code></td>\n<td>The first and second tasks are fully processed, total pending tasks = 3</td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>[0, 0, 0, 0, 0]</code></td>\n<td>All tasks are fully processed, total pending tasks = 0 (Pending is 0 so load back all tasks <code>[1,2,4,1,2]</code>)</td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>[0, 2, 4, 1, 2]</code></td>\n<td>The first task is fully processed, total pending tasks = 4</td>\n</tr>\n<tr>\n<td>4</td>\n<td><code>[0, 1, 4, 1, 2]</code></td>\n<td>The second task is partially processed, total pending tasks = 4</td>\n</tr>\n<tr>\n<td>5</td>\n<td><code>[0, 0, 3, 1, 2]</code></td>\n<td>The second task is fully processed, total pending tasks = 3</td>\n</tr>\n</tbody>\n</table></div>\n<p>Output = <code>[3,0,4,4,3]</code></p>\n<h2>Example 3</h2>\n<p>tasks = <code>[1, 4, 4]</code>\nprogrammers = <code>[9, 1, 4]</code></p>\n<p>Output = <code>[0, 2, 1]</code></p>\n<p>Here is my code that runs in O(m*n) time:</p>\n<pre><code>import java.util.*;\n\npublic class Main {\n\n    public static List&lt;Integer&gt; getPendingTasks(List&lt;Integer&gt; tasks, List&lt;Integer&gt; programmers) {\n        List&lt;Integer&gt; pendingTasks = new ArrayList&lt;&gt;();\n        List&lt;Integer&gt; originalTasks = new ArrayList&lt;&gt;(tasks); // Save original tasks for reloading\n        int n = tasks.size();\n        \n        for (int programmer : programmers) {\n            int timeRemaining = programmer;\n            for (int i = 0; i &lt; n &amp;&amp; timeRemaining &gt; 0; i++) {\n                if (tasks.get(i) &gt; 0) {\n                    if (tasks.get(i) &lt;= timeRemaining) {\n                        timeRemaining -= tasks.get(i);\n                        tasks.set(i, 0);\n                    } else {\n                        tasks.set(i, tasks.get(i) - timeRemaining);\n                        timeRemaining = 0;\n                    }\n                }\n            }\n\n            // Count pending tasks\n            int pending = 0;\n            for (int task : tasks) {\n                if (task &gt; 0) {\n                    pending++;\n                }\n            }\n\n            pendingTasks.add(pending);\n\n            // Reload tasks if all are completed\n            if (pending == 0) {\n                tasks = new ArrayList&lt;&gt;(originalTasks);\n            }\n        }\n\n        return pendingTasks;\n    }\n\n    public static void main(String[] args) {\n        // Example 1\n        List&lt;Integer&gt; tasks1 = Arrays.asList(2, 4, 5, 1, 1);\n        List&lt;Integer&gt; programmers1 = Arrays.asList(1, 5, 1, 5, 2);\n        System.out.println(&quot;Output: &quot; + getPendingTasks(tasks1, programmers1)); // Output: [5, 3, 3, 1, 0]\n\n        // Example 2\n        List&lt;Integer&gt; tasks2 = Arrays.asList(1, 2, 4, 1, 2);\n        List&lt;Integer&gt; programmers2 = Arrays.asList(3, 10, 1, 1, 1);\n        System.out.println(&quot;Output: &quot; + getPendingTasks(tasks2, programmers2)); // Output: [3, 0, 4, 4, 3]\n\n        // Example 3\n        List&lt;Integer&gt; tasks3 = Arrays.asList(1, 4, 4);\n        List&lt;Integer&gt; programmers3 = Arrays.asList(9, 1, 4);\n        System.out.println(&quot;Output: &quot; + getPendingTasks(tasks3, programmers3)); // Output: [0, 2, 1]\n    }\n}\n</code></pre>\n<p>I also tried using PriorityQueue to process only pending tasks:</p>\n<pre><code>import java.util.*;\n\nclass Main {\n\n    public static List&lt;Integer&gt; getPendingTasks(List&lt;Integer&gt; tasks, List&lt;Integer&gt; programmer) {\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n        Queue&lt;Integer&gt; pending = new PriorityQueue&lt;&gt;();\n        int n = tasks.size();\n        List&lt;Integer&gt; originalTasks = new ArrayList&lt;&gt;(tasks);\n\n        // Initialize set with all tasks\n        for (int i = 0; i &lt; n; i++) {\n            pending.add(i);\n        }\n        Queue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(pending);\n        \n        // Process each item\n        for (int p : programmer) {\n            int timeAvailable = p;\n\n            // Process only unprocessed tasks\n            List&lt;Integer&gt; balancedTask = new ArrayList&lt;&gt;();\n            \n            while (!q.isEmpty()) {\n                int i = q.poll();\n                if (tasks.get(i) &lt;= timeAvailable) {\n                    timeAvailable -= tasks.get(i);\n                    // Task fully processed\n                } else {\n                    tasks.set(i, tasks.get(i) - timeAvailable); // Partially processed\n                    timeAvailable = 0; // time exhausted\n                    balancedTask.add(i);\n                }\n            }\n            q.addAll(balancedTask);\n            result.add(q.size());\n            if(q.size() ==0) {\n                tasks = originalTasks;\n                q= pending;\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(getPendingTasks(Arrays.asList(2, 4, 5, 1, 1), Arrays.asList(1, 5, 1, 5, 2))); \n        // Expected: [5, 3, 3, 1, 0]\n        \n        System.out.println(getPendingTasks(Arrays.asList(1, 2, 4, 1, 2), Arrays.asList(3, 10, 1, 1, 1))); \n        // Expected: [3, 0, 4, 4, 3]\n        \n        System.out.println(getPendingTasks(Arrays.asList(1, 4, 4), Arrays.asList(9, 1, 4))); \n        // Expected: [0, 2, 1]\n    }\n}\n</code></pre>\n<p>But above code also runs in <code>O(n*m*log(m))</code> time complexity</p>\n<p><strong>Constraints:</strong></p>\n<pre><code>n and m in range 1 to 2 * 10^5\neach item in input lists is 1 to 10^9\n</code></pre>\n<p>I want to know how to solve this in less time complexity</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}