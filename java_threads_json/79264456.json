{
  "question": {
    "tags": [
      "java",
      "spring",
      "authentication",
      "jwt"
    ],
    "owner": {
      "account_id": 11485599,
      "reputation": 45,
      "user_id": 8418377,
      "user_type": "registered",
      "profile_image": "https://graph.facebook.com/424843534582604/picture?type=large",
      "display_name": "A_B",
      "link": "https://stackoverflow.com/users/8418377/a-b"
    },
    "is_answered": true,
    "view_count": 145,
    "accepted_answer_id": 79422757,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1739360968,
    "creation_date": 1733736702,
    "last_edit_date": 1739360968,
    "question_id": 79264456,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79264456/apply-method-in-my-authenticationfilter-not-getting-called",
    "title": "Apply method in my AuthenticationFilter not getting called",
    "body": "<p>I don't know why but my apply method inside my AuthenticationFileter is not getting called, even though I hitting the routes</p>\n<p>my AuthenticationFilter</p>\n<pre><code>@Component(&quot;Authenticate&quot;)\n@Slf4j\npublic class AuthenticationFilter extends AbstractGatewayFilterFactory&lt;AuthenticationFilter.Config&gt;{\n\n    private static final Logger logger = LoggerFactory.getLogger(AuthenticationFilter.class);\n    \n    @Autowired\n    private RouteValidator routeValidator;\n    \n    @Autowired\n    private JwtUtil jwtUtil;\n    \n    private final Auth_Manager_Service authManagerFeignClient;\n    \n    public AuthenticationFilter(@Lazy Auth_Manager_Service authManagerFeignClient) {\n        super(Config.class);\n        this.authManagerFeignClient = authManagerFeignClient;\n    }\n\n    @PostConstruct\n    public void init() {\n        logger.info(&quot;!!!!!!!!!!!!!!!!!!!!AuthenticationFilter initialized and registered!!!!!!!!!!!!!!!!!!!!&quot;);\n    }\n    \n    public static class Config {}   \n\n    @Override\n    public GatewayFilter apply(Config config) {\n        \n        return ((exchange, chain)-&gt;{\n            logger.debug(&quot;\\nEnter Authentication Filter&quot;);\n            \n            ServerHttpRequest httpRequest = null;\n                    \n                logger.debug(&quot;\\n--- Authentication Filter Debug Information ---&quot;);\n                logger.debug(&quot;Request URL: {}&quot;, exchange.getRequest().getURI());\n                logger.debug(&quot;Request Headers: {}&quot;, exchange.getRequest().getHeaders());\n                logger.info(&quot;Processing request: {} {}&quot;, exchange.getRequest().getMethod(),exchange.getRequest().getURI().getPath());\n                \n                \n                        logger.debug(&quot;\\n{}&quot;,routeValidator.isSecured.test(exchange.getRequest()));\n                        if (routeValidator.isSecured.test(exchange.getRequest())) {\n\n                                //header contains token or not\n                                if (!exchange.getRequest().getHeaders().containsKey(HttpHeaders.AUTHORIZATION)) {\n                                    logger.error(&quot;Missing or invalid authorization header&quot;);\n                                    throw new RuntimeException(&quot;Missing authorization header&quot;);\n                                }\n                                \n                                \n                                \n                                String authHeader = exchange.getRequest().getHeaders().get(HttpHeaders.AUTHORIZATION).get(0);       //it's a token\n                                System.out.println(&quot;Token: &quot;+authHeader);\n                                logger.error(&quot;Token: {}&quot;,authHeader);\n                                \n                                if (authHeader != null &amp;&amp; authHeader.startsWith(&quot;Bearer &quot;)) {\n                                    authHeader = authHeader.substring(7);\n                                }\n                                try {\n                                    System.out.println(&quot;Checking if it even reach here?&quot;);\n                                    jwtUtil.validateToken(authHeader);\n                                    logger.debug(&quot;Auth Header: {}&quot;, authHeader);\n                                    System.out.println(&quot;authHeader: &quot;+authHeader);\n                                    \n                                    \n                                    String username = jwtUtil.extractUsername(authHeader);\n                                    System.out.println(&quot;username: &quot;+username);\n                                    \n                                    List&lt;String&gt; roles = authManagerFeignClient.getRolesByUsername(username);\n                                    System.out.println(&quot;roles: &quot;+roles);\n                                    \n                                    String rolesAsString = String.join(&quot;,&quot;, roles);\n                                    System.out.println(&quot;roles: &quot;+rolesAsString);\n                                    \n                                    \n                                    logger.debug(&quot;Authenticated User: {}&quot;, username);\n                                    logger.debug(&quot;User Roles: {}&quot;, rolesAsString);\n\n                                    httpRequest = exchange.getRequest().mutate()\n                                             .header(&quot;loggedInUser&quot;, jwtUtil.extractUsername(authHeader))\n                                             .header(&quot;loggedInUserRoles&quot;, rolesAsString)        // Only for now as we are taking roles as single value and not as list\n                                             .build();\n                                    logger.debug(&quot;Header Info: {}&quot;, httpRequest);\n                                            \n                                } catch (ExpiredJwtException e) {\n                                    logger.error(&quot;JWT token has expired&quot;, e);\n                                    throw new RuntimeException(&quot;JWT token has expired&quot;, e);\n                                } catch (MalformedJwtException e) {\n                                    logger.error(&quot;JWT token is malformed&quot;, e);\n                                    throw new RuntimeException(&quot;JWT token is malformed&quot;, e);\n                                } catch (SignatureException e) {\n                                    logger.error(&quot;JWT signature is invalid&quot;, e);\n                                    throw new RuntimeException(&quot;JWT signature is invalid&quot;, e);\n                                } catch (Exception e) {\n                                    logger.error(&quot;Invalid access: Unauthorized access to application&quot;, e);\n                                    System.out.println(&quot;Invalid access...!&quot;);\n                                    throw new RuntimeException(&quot;!!Unauthorized access to application!!&quot;);\n                                }\n                        }\n            \n            logger.debug(&quot;---------------------------\\n&quot;);\n            return chain.filter(exchange.mutate().request(httpRequest).build());\n        \n        });\n    }\n}\n</code></pre>\n<p>my GatewayConfig</p>\n<pre><code>    @Bean\n    public WebClient.Builder webClientBuilder() {\n        return WebClient.builder();\n    }\n    \n    @Bean\n    public RouteLocator customRouteLocator(RouteLocatorBuilder builder, AuthenticationFilter authFilter) {\n        return builder.routes()\n            .route(&quot;Gateway&quot;, r -&gt; r\n                .path(&quot;/api/gateway/v1/user-info&quot;)  // The specific path to route\n                .filters(f -&gt; f.filter(authFilter.apply(new AuthenticationFilter.Config())))\n                .uri(&quot;http://localhost:8084&quot;))\n            .build();\n    }\n</code></pre>\n<p>myRouteValidator</p>\n<pre><code>@Component\npublic class RouteValidator {\n\n    private static final Logger logger = LoggerFactory.getLogger(RouteValidator.class);\n    \n    public static final List&lt;String&gt; openApiEndpoints = List.of(\n            &quot;/api/auth/v1/register&quot;,\n            &quot;/api/auth/v1/token&quot;,\n            &quot;/eureka&quot;,\n            &quot;/api-docs&quot;\n    );\n            \n    public Predicate&lt;ServerHttpRequest&gt; isSecured = request -&gt; {\n                String currentPath = request.getURI().getPath();\n                logger.info(&quot;Checking security for path: {}&quot;, currentPath);\n                \n                boolean isOpen = openApiEndpoints.stream()\n                    .anyMatch(uri -&gt; currentPath.contains(uri));  \n                \n                logger.info(&quot;Path {} is {}secured&quot;, currentPath, isOpen ? &quot;not &quot; : &quot;&quot;);\n                return !isOpen;\n            };        \n}\n</code></pre>\n<p>when I am trying to hit api: /api/gateway/v1/user-info, any of the log or system.out.println present apply method in authentionFilter is showing.</p>\n<p>AuthConfig, configuration on below asked comment</p>\n<pre><code>package com.auth_am.AM.config;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.AuthenticationProvider;\nimport org.springframework.security.authentication.dao.DaoAuthenticationProvider;\nimport org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.web.SecurityFilterChain;\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\n\nimport com.auth_am.AM.service.CustomUserDetailsService;\n\n@Configuration\n@EnableWebSecurity\npublic class AuthConfig {\n\n    private static final Logger logger = LoggerFactory.getLogger(AuthConfig.class);\n    \n    @Autowired\n    private JWTAuthenticationFilter jwtAuthenticationFilter;\n    \n    @Bean\n    UserDetailsService userDetailsService(){\n        logger.info(&quot;UserDetailsService bean created&quot;);\n        return new CustomUserDetailsService();\n    }\n    \n    @Bean\n    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        return http.csrf(csrf -&gt; csrf.disable())                    // Disable CSRF\n                .authorizeHttpRequests(authorize -&gt; authorize\n                        .requestMatchers(&quot;/api/auth/v1/register&quot;, &quot;/api/auth/v1/token&quot;, &quot;/api/auth/v1/validate&quot;).permitAll()        // Public endpoint\n                        .anyRequest().authenticated()                                       // Other requests require authentication\n                    )\n                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)\n                .build();\n    }   \n\n    @Bean\n    PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n    \n    @Bean\n    public AuthenticationProvider authenticationProvider(){\n        DaoAuthenticationProvider authenticationProvider=new DaoAuthenticationProvider();\n        authenticationProvider.setUserDetailsService(userDetailsService());\n        authenticationProvider.setPasswordEncoder(passwordEncoder());\n        return authenticationProvider;\n    }\n    \n    @Bean\n    AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {\n        return config.getAuthenticationManager();\n    }\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}