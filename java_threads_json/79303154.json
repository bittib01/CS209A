{
  "question": {
    "tags": [
      "java",
      "spring",
      "hibernate",
      "jpa"
    ],
    "owner": {
      "account_id": 14666883,
      "reputation": 1736,
      "user_id": 10628833,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/170ff1d78e1fbc9f2f4d849422276eaa?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Gustavo Ces&#225;rio",
      "link": "https://stackoverflow.com/users/10628833/gustavo-ces%c3%a1rio"
    },
    "is_answered": false,
    "view_count": 58,
    "answer_count": 0,
    "score": 0,
    "last_activity_date": 1734967212,
    "creation_date": 1734958676,
    "last_edit_date": 1734967212,
    "question_id": 79303154,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79303154/how-does-transactions-work-from-a-read-only-perspective-in-spring-jpa-hibernat",
    "title": "How does transactions work from a read-only perspective in Spring JPA + Hibernate?",
    "body": "<p>Before the actual question, let me give some background: Recently I stumbled upon a N+1 problem which according to <a href=\"https://vladmihalcea.com/hibernate-multiplebagfetchexception/\" rel=\"nofollow noreferrer\">this</a> article written by Vlad Mihalcea it could be solved by prefetching the entities from the relationships within the same persistence context. Indeed it solved the N+1 problem (to a fixed number of 10 queries). However, the performance was drastically decreased after this implementation, and I'm still trying to figure out why. Sometimes I would even get a timeout when trying to connect to the database with the error <code>Unable to acquire JDBC Connection</code>.</p>\n<p>So, my question is: what happens behind the scenes when I use <code>@Transactional(readOnly=true)</code> in a method? Does it create a lock while the method is running? If so, what could I do to guarantee that I'm in the same persistence context and therefore achieve what I want with the prefetch?</p>\n<p>Anything that could point me in the direction of the actual problem would be very much appreciated.</p>\n<p>Edit: I forgot to mention that the problem is mostly apparent when I have a large amount of concurrent requests. It seems like each request has to wait until the previous one has been finished. This is why I suspect that it could be a lock issue.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}