{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "grpc",
      "illegalstateexception",
      "grpc-java"
    ],
    "owner": {
      "account_id": 31740931,
      "reputation": 11,
      "user_id": 24556603,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/8ef968a6b99aa32b88ea26fa5d2d3ff8?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Aleksandr Fominsky",
      "link": "https://stackoverflow.com/users/24556603/aleksandr-fominsky"
    },
    "is_answered": false,
    "view_count": 250,
    "answer_count": 2,
    "score": 1,
    "last_activity_date": 1723158599,
    "creation_date": 1713763945,
    "last_edit_date": 1713764091,
    "question_id": 78364126,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78364126/closing-a-grps-connection-when-handling-an-exception",
    "title": "Closing a grps-connection when handling an exception",
    "body": "<p>I'm writing an interceptor that validates messages in a grpc server and I'm running into a problem.</p>\n<p>The general scheme is: interceptor is activated at the level of the application and validates incoming proto-messages. If it does not pass validation, I need to forward the exception further into the application so that the exception handler correctly build the response as a StatusRuntime exception and returns it to the client. Here is some sample code, it works:</p>\n<pre><code>@Slf4j\n@GrpcGlobalServerInterceptor\npublic class ValidationInterceptor implements ServerInterceptor {\n  private static final String UNKNOWN_CALL_NAME = &quot;Unknown call&quot;;\n  private final GrpcExceptionResponseHandler exceptionHandler;\n  private final Validator validator;\n\n  public ValidationInterceptor(GrpcExceptionResponseHandler exceptionHandler,\n                               Validator validator) {\n    this.exceptionHandler = exceptionHandler;\n    this.validator = validator;\n  }\n\n  @Override\n  public &lt;ReqT, RespT&gt; Listener&lt;ReqT&gt; interceptCall(ServerCall&lt;ReqT, RespT&gt; call,\n                                                    Metadata headers,\n                                                    ServerCallHandler&lt;ReqT, RespT&gt; next) {\n    final Listener&lt;ReqT&gt; delegateListener = next.startCall(call, headers);\n    return new ForwardingServerCallListener.SimpleForwardingServerCallListener&lt;&gt;(delegateListener) {\n      @Override\n      public void onMessage(ReqT message) {\n        try {\n          final ValidationResult validationResult = validator.validate((Message) message);\n\n          if (!validationResult.isSuccess()) {\n            exceptionHandler.handleError(call,\n                new ValidationRuntimeException(\n                    getMethodName(call), validationResult.getViolations())\n            );\n            return;\n          }\n\n          super.onMessage(message);\n        } catch (Exception e) {\n          log.warn(&quot;Unexpected exception caught when validating method {}&quot;, getMethodName(call), e);\n          exceptionHandler.handleError(call, e);\n        }\n      }\n    };\n  }\n\n  private &lt;ReqT, RespT&gt; String getMethodName(ServerCall&lt;ReqT, RespT&gt; call) {\n    return Optional.ofNullable(call.getMethodDescriptor())\n        .map(MethodDescriptor::getFullMethodName)\n        .orElse(UNKNOWN_CALL_NAME);\n  }\n}\n\n</code></pre>\n<p>Handler</p>\n<pre><code>@GrpcAdvice\n@Slf4j\npublic class GrpcErrorHandler {\n  @GrpcExceptionHandler\n  public StatusRuntimeException handleValidationRuntimeException(\n      ValidationRuntimeException e) {\n    String message = Optional.ofNullable(e.getMessage()).orElse(DEFAULT_MESSAGE);\n    log.warn(&quot;Error {}&quot;, message, e);\n    errorCounterMetrics.incrementError(e);\n    return toStatusRuntimeException(e.getViolations());\n  }\n}\n\n</code></pre>\n<p>Everything works great, except for one detail. After the <code>handleValidationRuntimeException()</code> method has processed and returned an exception, for some reason the <code>call()</code> is called again on an already closed channel, which leads to an <code>IllegalStateException</code></p>\n<p>Stack trace</p>\n<pre><code>java.lang.IllegalStateException: call already closed\n    at com.google.common.base.Preconditions.checkState(Preconditions.java:502)\n    at io.grpc.internal.ServerCallImpl.closeInternal(ServerCallImpl.java:216)\n    at io.grpc.internal.ServerCallImpl.close(ServerCallImpl.java:209)\n    at io.grpc.PartialForwardingServerCall.close(PartialForwardingServerCall.java:48)\n    at io.grpc.ForwardingServerCall.close(ForwardingServerCall.java:22)\n    at io.grpc.ForwardingServerCall$SimpleForwardingServerCall.close(ForwardingServerCall.java:39)\n    at net.devh.boot.grpc.server.metric.MetricCollectingServerCall.close(MetricCollectingServerCall.java:60)\n    at net.devh.boot.grpc.server.advice.GrpcAdviceExceptionHandler.handleThrownExceptionByImplementation(GrpcAdviceExceptionHandler.java:112)\n    at net.devh.boot.grpc.server.advice.GrpcAdviceExceptionHandler.handleError(GrpcAdviceExceptionHandler.java:82)\n    at net.devh.boot.grpc.server.error.GrpcExceptionListener.onHalfClose(GrpcExceptionListener.java:72)\n    at io.grpc.PartialForwardingServerCallListener.onHalfClose(PartialForwardingServerCallListener.java:35)\n    at io.grpc.ForwardingServerCallListener.onHalfClose(ForwardingServerCallListener.java:23)\n    at io.grpc.ForwardingServerCallListener$SimpleForwardingServerCallListener.onHalfClose(ForwardingServerCallListener.java:40)\n    at io.grpc.PartialForwardingServerCallListener.onHalfClose(PartialForwardingServerCallListener.java:35)\n    at io.grpc.ForwardingServerCallListener.onHalfClose(ForwardingServerCallListener.java:23)\n    at io.grpc.ForwardingServerCallListener$SimpleForwardingServerCallListener.onHalfClose(ForwardingServerCallListener.java:40)\n    at net.devh.boot.grpc.server.security.interceptors.AbstractAuthenticatingServerCallListener.onHalfClose(AbstractAuthenticatingServerCallListener.java:103)\n    at net.devh.boot.grpc.server.security.interceptors.DefaultAuthenticatingServerInterceptor$AuthenticatingServerCallListener.onHalfClose(DefaultAuthenticatingServerInterceptor.java:243)\n    at io.grpc.PartialForwardingServerCallListener.onHalfClose(PartialForwardingServerCallListener.java:35)\n    at io.grpc.ForwardingServerCallListener.onHalfClose(ForwardingServerCallListener.java:23)\n    at io.grpc.ForwardingServerCallListener$SimpleForwardingServerCallListener.onHalfClose(ForwardingServerCallListener.java:40)\n    at net.devh.boot.grpc.server.security.interceptors.ExceptionTranslatingServerInterceptor$ExceptionTranslatorServerCallListener.onHalfClose(ExceptionTranslatingServerInterceptor.java:124)\n    at io.grpc.PartialForwardingServerCallListener.onHalfClose(PartialForwardingServerCallListener.java:35)\n    at io.grpc.ForwardingServerCallListener.onHalfClose(ForwardingServerCallListener.java:23)\n    at io.grpc.ForwardingServerCallListener$SimpleForwardingServerCallListener.onHalfClose(ForwardingServerCallListener.java:40)\n    at io.grpc.PartialForwardingServerCallListener.onHalfClose(PartialForwardingServerCallListener.java:35)\n    at io.grpc.ForwardingServerCallListener.onHalfClose(ForwardingServerCallListener.java:23)\n    at io.grpc.ForwardingServerCallListener$SimpleForwardingServerCallListener.onHalfClose(ForwardingServerCallListener.java:40)\n    at io.grpc.Contexts$ContextualizedServerCallListener.onHalfClose(Contexts.java:86)\n    at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.halfClosed(ServerCallImpl.java:352)\n    at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1HalfClosed.runInContext(ServerImpl.java:866)\n    at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)\n    at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)\n    at java.lang.Thread.run(Thread.java:833)\n</code></pre>\n<p>Actually, what can be done about this? Thank you!</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}