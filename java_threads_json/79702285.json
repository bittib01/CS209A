{
  "question": {
    "tags": [
      "java",
      "postgresql",
      "spring-boot",
      "spring-security",
      "mapstruct"
    ],
    "owner": {
      "account_id": 43045854,
      "reputation": 13,
      "user_id": 31047070,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/ccad5dde42a1f2337836ce3e944e79d9?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Mario Rodriguez",
      "link": "https://stackoverflow.com/users/31047070/mario-rodriguez"
    },
    "is_answered": true,
    "view_count": 196,
    "accepted_answer_id": 79703049,
    "answer_count": 2,
    "score": 1,
    "last_activity_date": 1752655505,
    "creation_date": 1752592387,
    "last_edit_date": 1752592499,
    "question_id": 79702285,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79702285/all-mapstruct-fields-are-encrypted-with-passwordencoder-instead-of-only-the-pass",
    "title": "All MapStruct fields are encrypted with PasswordEncoder instead of only the password",
    "body": "<p>I’m developing an application with <strong>Spring Boot</strong> and facing an issue using <strong>MapStruct</strong> to map a DTO (<code>RegisterRequest</code>) to an entity (<code>Usuario</code>) and save the data in a <strong>PostgreSQL</strong> database.</p>\n<p>My goal is for <strong>only</strong> the <code>password</code> field to be encrypted with <strong>PasswordEncoder</strong> (using BCrypt), while the other fields (<code>firstName</code>, <code>lastName</code>, <code>email</code>, <code>role</code>) should be mapped directly from the DTO.</p>\n<p>However, the implementation generated by <strong>MapStruct</strong> is encrypting <strong>all</strong> the fields, which causes a length error:<br />\n<code>value too long for type character varying(30)</code></p>\n<p>on the firstName column, which has a 30-character limit, while the generated hashes are approximately 60 characters long.</p>\n<p><strong>What I want to do</strong></p>\n<p>To avoid doing the mapping manually, I wanted to use <strong>MapStruct</strong> (as I had done before with other mappings) to delegate this work and reduce boilerplate code. The flow I needed was:</p>\n<ul>\n<li><p>Receive a POST request with a <code>RegisterRequest</code> containing <code>email</code>, <code>password</code>, <code>firstName</code>, and <code>lastName</code>.</p>\n</li>\n<li><p>Map these fields to a <code>Usuario</code> entity using <strong>MapStruct</strong>.</p>\n</li>\n<li><p>Encrypt only the <code>password</code> field using <strong>PasswordEncoder</strong>.</p>\n</li>\n<li><p>Assign a constant value <code>&quot;User&quot;</code> to the <code>role</code> field.</p>\n</li>\n<li><p>Save the <code>Usuario</code> in the database without any length errors.</p>\n</li>\n</ul>\n<hr />\n<p><strong>Relevant Code</strong></p>\n<pre><code>@Mapper(componentModel = MappingConstants.ComponentModel.SPRING)\npublic interface UsuarioRegisterMapper {\n\n    @Mapping(target = &quot;rol&quot;, constant = &quot;User&quot;)\n    @Mapping(target = &quot;id&quot;, ignore = true)\n    @Mapping(target = &quot;contrasena&quot;, expression = &quot;java(encodePassword(request.contrasena(), passwordEncoder))&quot;)\n    Usuario toEntity(RegisterRequest request, @Context PasswordEncoder passwordEncoder);\n\n    default String encodePassword(String rawPassword, @Context PasswordEncoder passwordEncoder) {\n        return passwordEncoder.encode(rawPassword);\n    }\n}\n</code></pre>\n<p>the implementation automatically generated by MapStruct:</p>\n<pre><code>@Generated(\n    value = &quot;org.mapstruct.ap.MappingProcessor&quot;,\n    date = &quot;2025-07-14T21:19:15-0600&quot;,\n    comments = &quot;version: 1.5.5.Final, compiler: javac, environment: Java 23.0.2 (Oracle Corporation)&quot;\n)\n@Component\npublic class UsuarioRegisterMapperImpl implements UsuarioRegisterMapper {\n\n    @Override\n    public Usuario toEntity(RegisterRequest request, PasswordEncoder passwordEncoder) {\n        if (request == null) {\n            return null;\n        }\n\n        Usuario usuario = new Usuario();\n\n        usuario.setNombre(encodePassword(request.nombre(), passwordEncoder));\n        usuario.setApellido(encodePassword(request.apellido(), passwordEncoder));\n        usuario.setEmail(encodePassword(request.email(), passwordEncoder));\n        usuario.setRol(encodePassword(&quot;User&quot;, passwordEncoder));\n        usuario.setContrasena(encodePassword(request.contrasena(), passwordEncoder));\n\n        return usuario;\n    }\n}\n</code></pre>\n<pre><code>package com.proyectoUno.security.dto;\n\npublic record RegisterRequest(\n        String email,\n        String contrasena,\n        String nombre,\n        String apellido\n) {}\n</code></pre>\n<pre><code>@Service\npublic class AuthService {\n    // ... (injections)\n\n    public AuthResponse register(RegisterRequest request) {\n        if (usuarioRepository.findByEmail(request.email()).isPresent()) {\n            throw new EntidadDuplicadaException(&quot;Email is already associated with an account&quot;, &quot;email&quot;, Collections.singletonList(request.email()));\n        }\n\n// This is where I use the mapper to skip the manual process of instantiating the class and calling .set for each value\n        Usuario usuario = usuarioRegisterMapper.toEntity(request, this.passwordEncoder);\n\n        System.out.println(&quot;Usuario before saving: &quot; + usuario);\n        usuarioRepository.save(usuario);\n\n        UserDetails userDetails = new CustomUserDetails(usuario);\n        String jwtToken = jwtService.generateAccessToken(userDetails);\n        String refreshToken = jwtService.generateRefreshToken(userDetails);\n        return new AuthResponse(jwtToken, refreshToken);\n    }\n    // ...\n}\n</code></pre>\n<p>Postman:</p>\n<pre><code>{\n  &quot;email&quot;: &quot;mario.rodriguez@gmail.com&quot;,\n  &quot;contrasena&quot;: &quot;soyMario1050&quot;,\n  &quot;nombre&quot;: &quot;Mario&quot;,\n  &quot;apellido&quot;: &quot;Rodriguez&quot;\n}\n</code></pre>\n<p>After sending the request from Postman, the bug appeared. To verify it was caused by the Mapper configuration, I did some quick debugging to check the mapper’s output.</p>\n<pre><code>Usuario before saving: Usuario{id=null, \n  nombre='$2a$10$SKiTvYYJK.vZPetwOtY1OOBMCz6m15.bSUCZzk67Q..Ybs0h0n6nu', \n  apellido='$2a$10$h/PjGAv8aF7sGdCMo7jK/.CaHfcS.e1bHGIM28bb/RIYd/t1CL0jy', \n  email='$2a$10$ookM1PA26edcSu0mt4FnZegsvg/Cm3S0zdp5aRmfY/e1pcJ7TqT8K', \n  contrasena='$2a$10$aMIQJAo/pX7TEWhbKwtj/O0x/yuy8eqkfMVBfY7..fmnnmcwLo1e.', \n  rol='$2a$10$WV1kZvIx.j/UZfCSmcPMoOvOMFXXUM.qDKIarD5rIOLAHThULlUKK', \n  fechaRegistro=null, activo=false, prestamo=[]}\n</code></pre>\n<p>And that’s when the issue became clear: the mapper wasn’t just handling the <code>password</code> field — it was applying the default method to <strong>all</strong> fields, even though it was only supposed to be used for the <code>password</code>.</p>\n<p><strong>What I’ve tried</strong></p>\n<ul>\n<li><p>I added explicit mappings in <code>UsuarioRegisterMapper</code> for <code>nombre</code>, <code>apellido</code>, and <code>email</code> (like <code>@Mapping(target = &quot;nombre&quot;, source = &quot;request.nombre&quot;)</code>), but the generated implementation still applies <code>encodePassword</code> to all fields.</p>\n</li>\n<li><p>I cleaned and recompiled the project with <code>mvn clean install</code>, but the problem persists.</p>\n</li>\n<li><p>I verified that the <code>usuario</code> table has the correct column lengths (e.g., <code>nombre</code> as <code>varchar(30)</code>), but the generated hashes exceed this limit.</p>\n</li>\n</ul>\n<p><strong>Question</strong></p>\n<ul>\n<li><p>Why is MapStruct encrypting all fields with <code>PasswordEncoder</code> instead of limiting it to the <code>password</code> field?</p>\n</li>\n<li><p>How can I fix the configuration or implementation so that only <code>password</code> is encrypted and the other fields are mapped directly?</p>\n</li>\n<li><p>Is there a bug in MapStruct version 1.5.5.Final with Java 23.0.2?</p>\n</li>\n</ul>\n<p>Any help or suggestions would be greatly appreciated. Thanks in advance.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}