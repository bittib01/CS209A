{
  "question": {
    "tags": [
      "java",
      "spring",
      "spring-boot",
      "jpa"
    ],
    "owner": {
      "account_id": 35217103,
      "reputation": 11,
      "user_id": 27056726,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/5eea6b6d1c47c9399baf3ed637cd6ffb?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Mariusz Nowicki",
      "link": "https://stackoverflow.com/users/27056726/mariusz-nowicki"
    },
    "is_answered": false,
    "view_count": 75,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1729766085,
    "creation_date": 1725966918,
    "last_edit_date": 1729766085,
    "question_id": 78969211,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78969211/unable-to-retrieve-a-dependency-using-database-view",
    "title": "Unable to retrieve a dependency using database view",
    "body": "<p>Im trying to use data base view to join fetch any dependency that is associated with the Employee class which extends Person.</p>\n<p>I have a search method where I'd like to search by the number of job positions associated with the employee.</p>\n<p>After creating an Employee &amp; assigning a jobPosition Im trying to use the search method to find the Employee by the number of job positions but I get the following error:</p>\n<pre><code>RROR 14956 --- [nio-8080-exec-9] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: org.springframework.dao.InvalidDataAccessResourceUsageException: could not prepare statement [Kolumna &quot;P.ID&quot; nie istnieje\nColumn &quot;P.ID&quot; not found; SQL statement:\nSELECT p.id AS id, p.name AS name, p.surname AS surname, p.job_position_count AS numberOfJobPositions FROM person_view p WHERE p.type = 'employee' [42122-214]] [SELECT p.id AS id, p.name AS name, p.surname AS surname, p.job_position_count AS numberOfJobPositions FROM person_view p WHERE p.type = 'employee']; SQL [SELECT p.id AS id, p.name AS name, p.surname AS surname, p.job_position_count AS numberOfJobPositions FROM person_view p WHERE p.type = 'employee']] with root cause\n\norg.h2.jdbc.JdbcSQLSyntaxErrorException: Column &quot;P.ID&quot; doesn't exist\nColumn &quot;P.ID&quot; not found; SQL statement:\nSELECT p.id AS id, p.name AS name, p.surname AS surname, p.job_position_count AS numberOfJobPositions FROM person_view p WHERE p.type = 'employee'\n</code></pre>\n<p>Here is my code</p>\n<pre><code>@Getter\n@Setter\n@AllArgsConstructor\n@NoArgsConstructor\n@SuperBuilder\n@Entity\n@DiscriminatorValue(&quot;EMPLOYEE&quot;)\npublic class Employee extends Person {\n\n    @OneToMany(cascade = CascadeType.ALL, mappedBy = &quot;employee&quot;)\n    private Set&lt;JobPosition&gt; jobPositions;\n</code></pre>\n<pre><code>@Getter\n@Setter\n@SuperBuilder\n@AllArgsConstructor\n@NoArgsConstructor\n@Entity\n@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\n@DiscriminatorColumn(name = &quot;type&quot;, discriminatorType = DiscriminatorType.STRING)\npublic class Person {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private long id;\n    @Column(insertable = false, updatable = false)\n    private String type;\n    private String name;\n    private String surname;\n    @Column(unique = true)\n    private String pesel;\n    private double height;\n    private double weight;\n    private String emailAddress;\n    @Version\n    private int version;\n}\n</code></pre>\n<pre><code>CREATE TABLE IF NOT EXISTS person\n(\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255),\n    surname VARCHAR(255),\n    pesel VARCHAR(20),\n    height DOUBLE,\n    weight DOUBLE,\n    email_address VARCHAR(255),\n    type VARCHAR(50), -- Type differentiates between Employee, Student, Pensioner, etc.\n    version INT\n    );\n\nCREATE TABLE IF NOT EXISTS job_position\n(\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    position_name VARCHAR(255),\n    start_date DATE,\n    end_date DATE,\n    salary DOUBLE,\n    employee_id BIGINT,\n    FOREIGN KEY (employee_id) REFERENCES employee(id)\n    );\nCREATE OR REPLACE VIEW person_view AS\nSELECT\n    p.id AS person_id,\n    p.name,\n    p.surname,\n    p.pesel,\n    p.height,\n    p.weight,\n    p.email_address,\n    p.type,\n    jp.position_name,\n    jp.start_date,\n    jp.end_date,\n    jp.salary,\n    COUNT(jp.id) OVER (PARTITION BY p.id) AS job_position_count\nFROM person p\n         LEFT JOIN job_position jp ON p.id = jp.employee_id\nWHERE p.type = 'employee'\nGROUP BY p.id, p.name, p.surname, p.pesel, p.height, p.weight, p.email_address, p.type,\n         jp.position_name, jp.start_date, jp.end_date, jp.salary\nHAVING COUNT(jp.id) &gt; 0;\n\nCREATE TABLE IF NOT EXISTS file_import\n(\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    created_at TIMESTAMP(6),\n    file_path VARCHAR(255),\n    finished_at TIMESTAMP(6),\n    last_processed_row BIGINT,\n    started_at TIMESTAMP(6),\n    status VARCHAR(255),\n    CONSTRAINT file_import_status_check CHECK (status IN ('PENDING', 'SUCCESS', 'FAILED', 'IN_PROGRESS'))\n    );\n</code></pre>\n<pre><code>public interface PersonRepository extends JpaRepository&lt;Person, Long&gt;, JpaSpecificationExecutor&lt;Person&gt; {\n    Optional&lt;Person&gt; findById(Long id);\n\n    @Query(&quot;select e from Employee e left join fetch e.jobPositions where e.id=:id&quot;)\n    Optional&lt;Employee&gt; findByIdWithJobs(@Param(&quot;id&quot;) Long id);\n\n    @Query(value = &quot;SELECT p.id AS id, p.name AS name, p.surname AS surname, p.job_position_count AS numberOfJobPositions FROM person_view p WHERE p.type = 'employee'&quot;, nativeQuery = true)\n    List&lt;EmployeeDto&gt; findAllEmployeesWithJobPositions();\n}\n</code></pre>\n<pre><code>@Component\npublic class JobPositionsSpecificationProvider implements SpecificationProvider {\n\n    private final PersonRepository personRepository;\n\n    public JobPositionsSpecificationProvider(PersonRepository personRepository) {\n        this.personRepository = personRepository;\n    }\n\n    @Override\n    public boolean supports(SearchCriteria criteria) {\n         return &quot;numberOfJobPositions&quot;.equals(criteria.getKey()) &amp;&amp; &quot;range&quot;.equals(criteria.getOperation());\n    }\n\n    @Override\n    public Specification&lt;Person&gt; getSpecification(SearchCriteria criteria) {\n        return (root, query, criteriaBuilder) -&gt; {\n\n            List&lt;EmployeeDto&gt; employees = personRepository.findAllEmployeesWithJobPositions();\n\n            Integer minJobPositions = parseInteger(criteria.getValue());\n            Integer maxJobPositions = parseInteger(criteria.getSecondValue());\n\n            return buildJobPositionPredicate(minJobPositions, maxJobPositions, root, criteriaBuilder);\n        };\n    }\n\n    private Predicate buildJobPositionPredicate(Integer minJobPositions, Integer maxJobPositions, Root&lt;Person&gt; root, CriteriaBuilder criteriaBuilder) {\n        Expression&lt;Integer&gt; jobPositionCount = root.get(&quot;numberOfJobPositions&quot;);\n\n        if (minJobPositions != null &amp;&amp; maxJobPositions != null) {\n            return criteriaBuilder.between(jobPositionCount, minJobPositions, maxJobPositions);\n        } else if (minJobPositions != null) {\n            return criteriaBuilder.greaterThanOrEqualTo(jobPositionCount, minJobPositions);\n        } else if (maxJobPositions != null) {\n            return criteriaBuilder.lessThanOrEqualTo(jobPositionCount, maxJobPositions);\n        }\n\n        return criteriaBuilder.conjunction();\n    }\n\n    private Integer parseInteger(Object value) {\n        if (value instanceof String) {\n            try {\n                return Integer.parseInt((String) value);\n            } catch (NumberFormatException e) {\n                return null;\n            }\n        } else if (value instanceof Integer) {\n            return (Integer) value;\n        }\n        return null;\n    }\n}\n</code></pre>\n<pre><code>   @Transactional(readOnly = true)\n    public Page&lt;PersonDto&gt; searchPersons(String searchCriteriaParam, Pageable pageable) throws JsonProcessingException {\n        List&lt;SearchCriteria&gt; searchCriteria = objectMapper.readValue(searchCriteriaParam, new TypeReference&lt;List&lt;SearchCriteria&gt;&gt;() {\n        });\n\n        Specification&lt;Person&gt; specification = PersonSpecification.any();\n        for (SearchCriteria criteria : searchCriteria) {\n            specification = personSpecification.addSpecification(specification, criteria);\n        }\n\n        Page&lt;Person&gt; result = personRepository.findAll(specification, pageable);\n        return result.map(personMapper::toDto);\n    }\n</code></pre>\n<p>I'd need to edit it so it will allow me to use the database view (as there are various types of people such as student employee pensioner) &amp; retrieve the job positions when using the search method so I can look for employees between 0 &amp; 2 job positions, for example.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}