{
  "question": {
    "tags": [
      "java",
      "android",
      "websocket",
      "webrtc"
    ],
    "owner": {
      "account_id": 9069534,
      "reputation": 696,
      "user_id": 6753279,
      "user_type": "registered",
      "accept_rate": 63,
      "profile_image": "https://i.sstatic.net/kcm2c.jpg?s=256",
      "display_name": "Ritu",
      "link": "https://stackoverflow.com/users/6753279/ritu"
    },
    "is_answered": false,
    "view_count": 92,
    "answer_count": 0,
    "score": 1,
    "last_activity_date": 1727196270,
    "creation_date": 1726354307,
    "question_id": 78986304,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78986304/webrtc-ice-and-sdp-exchange-successful-but-peerconnection-stuck-in-new-state",
    "title": "WebRTC ICE and SDP Exchange Successful, but PeerConnection Stuck in new state",
    "body": "<p>I am building a voice/video calling app on Android using WebRTC, where <code>SDP</code> and <code>ICE</code> candidates are exchanged through a <code>WebSocket</code> server. The flow of <code>SDP</code> and <code>ICE</code> candidates between two users (A and B) looks correct in the <code>WebSocket</code> logs, but the connection doesn't seem to fully establish.</p>\n<p><strong>Websocket Log</strong></p>\n<pre><code>User = A Send User B =&gt;&gt; offer of SDP\nUser = A Send User B =&gt;&gt; offer of ICE\nUser = A Send User B =&gt;&gt; offer of ICE\nUser = A Send User B =&gt;&gt; offer of ICE\nUser = A Send User B =&gt;&gt; offer of ICE\nUser = A Send User B =&gt;&gt; offer of ICE\nUser = A Send User B =&gt;&gt; offer of ICE\nUser = A Send User B =&gt;&gt; offer of ICE\nUser = A Send User B =&gt;&gt; offer of ICE\nUser = B Send User A =&gt;&gt; answer of SDP\nUser = B Send User A =&gt;&gt; answer of ICE\nUser = B Send User A =&gt;&gt; answer of ICE\nUser = B Send User A =&gt;&gt; answer of ICE\nUser = B Send User A =&gt;&gt; answer of ICE\nUser = B Send User A =&gt;&gt; answer of ICE\nUser = B Send User A =&gt;&gt; answer of ICE\nUser = B Send User A =&gt;&gt; answer of ICE\nUser = B Send User A =&gt;&gt; answer of ICE\n</code></pre>\n<p>However, in the Android logs, the connection state doesnâ€™t progress as expected after the ICE exchange completes. The connection remains in the following states indefinitely:</p>\n<pre><code>Log.d(TAG, &quot;Connection State: &quot; + peerConnection.connectionState());  // Shows &quot;New&quot;\nLog.d(TAG, &quot;ICE Connection State: &quot; + peerConnection.iceConnectionState());  // Shows &quot;Checking&quot;\nLog.d(TAG, &quot;ICE Gathering State: &quot; + peerConnection.iceGatheringState());  // Shows &quot;Gathering&quot;\n</code></pre>\n<p><strong>My Call Fragment.</strong></p>\n<pre><code>public class Video_Voice_Call_Fragment extends Fragment {\n\n    private static final String TAG = &quot;Call_Fragment&quot;;\n    private static final int PERMISSION_REQUEST_CODE = 1;\n    public static final int VIDEO_RESOLUTION_WIDTH = 1280;\n    public static final int VIDEO_RESOLUTION_HEIGHT = 720;\n    public static final int FPS = 30;\n\n    private EglBase rootEglBase;\n    private PeerConnectionFactory peerConnectionFactory;\n    private VideoCapturer videoCapturer;\n    private VideoSource videoSource;\n    private VideoTrack localVideoTrack;\n    private AudioTrack localAudioTrack;\n    private SurfaceViewRenderer localVideoView;\n    private SurfaceTextureHelper surfaceTextureHelper;\n    private SurfaceViewRenderer remoteVideoView;\n    private ImageButton greenCallButton;\n    private ImageButton redCallButton;\n    private MediaStream localMediaStream;\n    OkHttpClient client;\n    PeerConnection peerConnection,peerConnectionRemote;\n    private String FCMToken_Other;\n\n    TextView CallStatus;\n    ImageView UserImage;\n    boolean isCaller = true;\n    boolean isVoiceCall;\n\n    @Nullable\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        return inflater.inflate(R.layout.fragment_video_voice_call, container, false);\n    }\n\n    @Override\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n        localVideoView = view.findViewById(R.id.call_remoteSurfaceView);\n        greenCallButton = view.findViewById(R.id.call_connect);\n        redCallButton = view.findViewById(R.id.call_disconnect);\n        if (isCaller){\n            ConstraintLayout.LayoutParams params = (ConstraintLayout.LayoutParams) redCallButton.getLayoutParams();\n            params.startToStart = ConstraintSet.PARENT_ID;\n            params.setMarginEnd(0);\n            redCallButton.setLayoutParams(params);\n            greenCallButton.setVisibility(View.GONE);\n        }\n        UserImage = view.findViewById(R.id.call_UserImage);\n        CallStatus = view.findViewById(R.id.call_Status);\n        TextView CallName = view.findViewById(R.id.call_callerName);\n\n        isVoiceCall = getArguments().getBoolean(&quot;VoiceCall&quot;);\n        String ImagePath = getArguments().getString(&quot;image&quot;);\n        String Name = getArguments().getString(&quot;name&quot;);\n        FCMToken_Other = getArguments().getString(&quot;fcm&quot;);\n        int OtherUserID = getArguments().getInt(&quot;OtherID&quot;);\n        Session.setOtherUserID(OtherUserID);\n        Glide.with(getActivity()).load(ImagePath).into(UserImage);\n        CallStatus.setText(&quot;Connecting...&quot;);\n        CallName.setText(Name);\n\n        client = new OkHttpClient();\n\n       \n        initializePeerConnectionFactory(isVoiceCall);\n        setupLocalTracks(isVoiceCall);\n        setupUI(view);\n        startCall(isVoiceCall);\n    }\n\n\n    \n    private void initializePeerConnectionFactory(boolean isVoiceCall) {\n        // Initialize EGL context for rendering\n        rootEglBase = EglBase.create();\n\n        // Initialize PeerConnectionFactory\n        PeerConnectionFactory.initialize(PeerConnectionFactory.InitializationOptions.builder(requireContext())\n                .setEnableInternalTracer(true)\n                .createInitializationOptions());\n\n        PeerConnectionFactory.Options options = new PeerConnectionFactory.Options();\n        PeerConnectionFactory.Builder builder = PeerConnectionFactory.builder();\n        options.networkIgnoreMask = 16;\n        options.disableNetworkMonitor = true;\n\n        if (!isVoiceCall){\n            //Video Call\n            DefaultVideoEncoderFactory videoEncoderFactory = new DefaultVideoEncoderFactory(rootEglBase.getEglBaseContext(),true,true);\n            DefaultVideoDecoderFactory videoDecoderFactory = new DefaultVideoDecoderFactory(rootEglBase.getEglBaseContext());\n            builder.setVideoEncoderFactory(videoEncoderFactory);\n            builder.setVideoDecoderFactory(videoDecoderFactory);\n            //Set EGL context\n            localVideoView.init(rootEglBase.getEglBaseContext(), null);\n            localVideoView.setMirror(true);\n            getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n        }\n\n        peerConnectionFactory = builder.setOptions(options).createPeerConnectionFactory();\n\n    }\n\n    private void setupLocalTracks(boolean isVoiceCall) {\n        localMediaStream = peerConnectionFactory.createLocalMediaStream(&quot;local_stream&quot;);\n        if (!isVoiceCall){\n            // Create video capturer\n            videoCapturer = createVideoCapturer();\n            // Create video source\n            videoSource = peerConnectionFactory.createVideoSource(false);\n            localVideoTrack = peerConnectionFactory.createVideoTrack(&quot;local_video&quot;, videoSource);\n            surfaceTextureHelper = SurfaceTextureHelper.create(&quot;SurfaceHelper&quot;,rootEglBase.getEglBaseContext());\n            videoCapturer.initialize(surfaceTextureHelper,getActivity(),videoSource.getCapturerObserver());\n            if (videoCapturer!=null){\n                videoCapturer.startCapture(VIDEO_RESOLUTION_WIDTH,VIDEO_RESOLUTION_HEIGHT,FPS);\n                localVideoTrack.addSink(localVideoView);\n            }\n            localMediaStream.addTrack(localVideoTrack);\n        }\n\n\n\n        // Create audio source and track\n        AudioSource audioSource = peerConnectionFactory.createAudioSource(new MediaConstraints());\n        localAudioTrack = peerConnectionFactory.createAudioTrack(&quot;local_audio&quot;, audioSource);\n        // Create local media stream\n        localMediaStream.addTrack(localAudioTrack);\n\n    }\n\n    private VideoCapturer createVideoCapturer() {\n        VideoCapturer videoCapturer;\n        CameraEnumerator enumerator = new Camera2Enumerator(requireContext());\n\n        final String[] deviceNames = enumerator.getDeviceNames();\n\n        // Find front facing camera\n        for (String deviceName : deviceNames) {\n            if (enumerator.isFrontFacing(deviceName)) {\n                videoCapturer = enumerator.createCapturer(deviceName, null);\n                if (videoCapturer != null) {\n                    return videoCapturer;\n                }\n            }\n        }\n\n        // Front facing camera not found, use the first available\n        if (deviceNames.length &gt; 0) {\n            return enumerator.createCapturer(deviceNames[0], null);\n        } else {\n            return null;\n        }\n    }\n\n   \n\n\n\n    private void startCall(boolean isVoiceCall) {\n      \n        Log.d(TAG, &quot;Starting call...&quot;);\n\n        // Create an offer and set local description\n        peerConnection = InitializePeerConnection();\n       \n        if (!isVoiceCall){\n            peerConnection.addTrack(localVideoTrack);\n        }\n\n        peerConnection.addTrack(localAudioTrack);\n\n        peerConnection.createOffer(new SimpleSdpObserver() {\n            @Override\n            public void onCreateSuccess(SessionDescription sessionDescription) {\n                Log.d(TAG, &quot;onCreateSuccess: &quot; + sessionDescription.description);\n\n                Websocket.connectWebSocket(new WebSocketCallback() {\n                    @Override\n                    public void onConnectionSuccess() {\n                        //Websocket Connected\n                        Log.d(TAG, &quot;onConnectionSuccess: Websocket Connected&quot;);\n                        String message = generateJSON(sessionDescription.description,true,&quot;offer&quot;);\n                        peerConnection.setLocalDescription(new SimpleSdpObserver(), sessionDescription);\n                        Websocket.sendMessage(message);\n                    }\n\n                    @Override\n                    public void onConnectionFailure(String message) {\n                        Log.d(TAG, &quot;onConnectionFailure: Message = &quot;+message);\n                    }\n\n                    @Override\n                    public void onConnectionClosed(String reason) {\n                        Log.d(TAG, &quot;onConnectionClosed: Reason = &quot;+reason);\n                    }\n\n                    @Override\n                    public void onConnectionsMessage(String message) {\n                        Log.d(TAG, &quot;onConnectionsMessage: Message = &quot;+message);\n                        // Here User will receive the message from the websocket\n                        try{\n                            JSONObject socketMessage = new JSONObject(message);\n                            String type = socketMessage.getString(&quot;type&quot;);\n                            Log.d(TAG, &quot;onConnectionsMessage: Type = &quot;+type);\n                            String sdp_ice_VALUE = null ;\n                            if (socketMessage.has(&quot;SDP_ICE_info&quot;)){\n                                sdp_ice_VALUE = socketMessage.getString(&quot;SDP_ICE_info&quot;);\n                            }\n\n                            switch (type) {\n                                case &quot;SDP&quot;:\n                                    Log.d(TAG, &quot;onConnectionsMessage: Type SDP&quot;);\n                                    SessionDescription sessionDescription = new SessionDescription(SessionDescription.Type.ANSWER, sdp_ice_VALUE);\n                                    peerConnection.setRemoteDescription(new SdpObserver() {\n                                        @Override\n                                        public void onCreateSuccess(SessionDescription sessionDescription) {\n                                            Log.d(TAG, &quot;onCreateSuccess: &quot;);\n                                        }\n\n                                        @Override\n                                        public void onSetSuccess() {\n\n                                            Log.d(TAG, &quot;onSetSuccess: Gathering state = &quot; + peerConnection.iceGatheringState());\n                                            Log.d(TAG, &quot;onSetSuccess: Connection State = &quot; + peerConnection.iceConnectionState());\n                         \n\n                                        }\n\n                                        @Override\n                                        public void onCreateFailure(String s) {\n                                            Log.d(TAG, &quot;onCreateFailure: &quot; + s);\n                                        }\n\n                                        @Override\n                                        public void onSetFailure(String s) {\n                                            Log.d(TAG, &quot;onSetFailure: &quot; + s);\n                                        }\n                                    }, sessionDescription);\n                                    //Generate ICE and Send it User B\n\n                                    break;\n                                case &quot;Offline&quot;:\n                                    Log.d(TAG, &quot;onConnectionsMessage: OFFLINE&quot;);\n                                    DefaultExecutorSupplier.getInstance().forMainThreadTasks().execute(new Runnable() {\n                                        @Override\n                                        public void run() {\n                                            Toast.makeText(getActivity(), &quot;User Is Not Available&quot;, Toast.LENGTH_SHORT).show();\n                                            CallStatus.setText(&quot;Offline&quot;);\n                                            closeConnection();\n                                        }\n                                    });\n\n                                    break;\n\n                                case &quot;ICE&quot;:\n                                    // Received ICE from server as answer, This is the last step in exchanging info\n                                    Log.d(TAG, &quot;onConnectionsMessage: Message Recevied ICE  = &quot; + type);\n                                    addIceCandidates(sdp_ice_VALUE);\n                                    break;\n                            }\n                        }catch (JSONException e){\n                            Log.d(TAG, &quot;onMessage: Error &quot;+e.getMessage());\n                        }\n                    }\n                });\n\n               \n            }\n\n            @Override\n            public void onCreateFailure(String s) {\n                Log.e(TAG, &quot;onCreateFailure: &quot; + s);\n            }\n        }, new MediaConstraints());\n    }\n\n    private PeerConnection InitializePeerConnection(){\n        ArrayList&lt;PeerConnection.IceServer&gt; iceServers = new ArrayList&lt;&gt;();\n        List&lt;String&gt; STUNList= Arrays.asList(\n                &quot;stun:stun.l.google.com:19302&quot;,\n                &quot;stun:stun1.l.google.com:19302&quot;,\n                &quot;stun:stun2.l.google.com:19302&quot;,\n                &quot;stun:stun3.l.google.com:19302&quot;,\n                &quot;stun:stun4.l.google.com:19302&quot;);\n        for(String i:STUNList){\n            PeerConnection.IceServer.Builder iceServerBuilder = PeerConnection.IceServer.builder(i);\n          //iceServerBuilder.setTlsCertPolicy(PeerConnection.TlsCertPolicy.TLS_CERT_POLICY_INSECURE_NO_CHECK);\n            iceServerBuilder.setTlsCertPolicy(PeerConnection.TlsCertPolicy.TLS_CERT_POLICY_SECURE);\n            PeerConnection.IceServer iceServer =  iceServerBuilder.createIceServer();\n            iceServers.add(iceServer);\n        }\n        PeerConnection.RTCConfiguration rtcConfig = new PeerConnection.RTCConfiguration(iceServers);\n\n        PeerConnection.Observer observer = new PeerConnection.Observer() {\n            @Override\n            public void onSignalingChange(PeerConnection.SignalingState signalingState) {\n                Log.d(TAG, &quot;onSignalingChange: &quot;+signalingState);\n            }\n\n            @Override\n            public void onIceConnectionChange(PeerConnection.IceConnectionState iceConnectionState) {\n                Log.d(TAG, &quot;onIceConnectionChange: &quot;+iceConnectionState);\n                if (PeerConnection.IceConnectionState.CONNECTED == iceConnectionState){\n                    Log.d(TAG, &quot;onIceConnectionChange: Connection Established&quot;);\n                }\n            }\n\n            @Override\n            public void onIceConnectionReceivingChange(boolean b) {\n                Log.d(TAG, &quot;onIceConnectionReceivingChange: Boolean = &quot;+b);\n            }\n\n            @Override\n            public void onIceGatheringChange(PeerConnection.IceGatheringState iceGatheringState) {\n                Log.d(TAG, &quot;onIceGatheringChange: &quot;+iceGatheringState);\n            }\n\n            @Override\n            public void onIceCandidate(IceCandidate iceCandidate) {\n                Log.d(TAG, &quot;onIceCandidate: 458 &quot;+Session.getUserID());\n                String ice = generateJSON(iceCandidate.toString(),false,&quot;offer&quot;);\n                Websocket.sendMessage(ice);\n            }\n\n            @Override\n            public void onIceCandidatesRemoved(IceCandidate[] iceCandidates) {\n                Log.d(TAG, &quot;onIceCandidatesRemoved: &quot;+iceCandidates);\n            }\n\n            @Override\n            public void onAddStream(MediaStream mediaStream) {\n                Log.d(TAG, &quot;onAddStream: &quot;+mediaStream);\n            }\n\n            @Override\n            public void onRemoveStream(MediaStream mediaStream) {\n                Log.d(TAG, &quot;onRemoveStream: &quot;+mediaStream);\n            }\n\n            @Override\n            public void onDataChannel(DataChannel dataChannel) {\n                Log.d(TAG, &quot;onDataChannel: &quot;+dataChannel);\n            }\n\n            @Override\n            public void onRenegotiationNeeded() {\n                Log.d(TAG, &quot;onRenegotiationNeeded: &quot;);\n            }\n\n            @Override\n            public void onAddTrack(RtpReceiver rtpReceiver, MediaStream[] mediaStreams) {\n                Log.d(TAG, &quot;onAddTrack: &quot;+rtpReceiver+&quot;--- &quot;+mediaStreams);\n            }\n        };\n\n        return peerConnectionFactory.createPeerConnection(rtcConfig,observer);\n        }\n\n\n\n    private void endCall() {\n        // End the call and release resources\n        // Code to end the call goes here\n        if (peerConnection!=null){\n            Log.d(TAG, &quot;endCall: Connection State =&quot;+peerConnection.connectionState());\n            Log.d(TAG, &quot;endCall: Ice Connection State =&quot;+peerConnection.iceConnectionState());\n            Log.d(TAG, &quot;endCall: Ice Gathering State =&quot;+peerConnection.iceGatheringState());\n        }\n\n    }\n\n  \n\n    private class CustomPeerConnectionObserver implements PeerConnection.Observer {\n        @Override\n        public void onSignalingChange(PeerConnection.SignalingState signalingState) {\n            // Handle signaling state change\n            Log.d(TAG, &quot;onSignalingChange: &quot;+signalingState);\n        }\n\n        @Override\n        public void onIceConnectionChange(PeerConnection.IceConnectionState iceConnectionState) {\n            // Handle ICE connection state change\n            Log.d(TAG, &quot;onIceConnectionChange: &quot;+iceConnectionState);\n        }\n\n        @Override\n        public void onIceConnectionReceivingChange(boolean b) {\n            // Handle ICE connection receiving change\n            Log.d(TAG, &quot;onIceConnectionReceivingChange: &quot;+b);\n        }\n\n        @Override\n        public void onIceGatheringChange(PeerConnection.IceGatheringState iceGatheringState) {\n            // Handle ICE gathering state change\n            Log.d(TAG, &quot;onIceGatheringChange: &quot;+iceGatheringState);\n        }\n\n        @Override\n        public void onIceCandidate(IceCandidate iceCandidate) {\n            // Handle ICE candidate\n            Log.d(TAG, &quot;onIceCandidate: &quot;+iceCandidate);\n        }\n\n        @Override\n        public void onIceCandidatesRemoved(IceCandidate[] iceCandidates) {\n            Log.d(TAG, &quot;onIceCandidatesRemoved: &quot;+iceCandidates.length);\n        }\n\n        @Override\n        public void onAddStream(MediaStream mediaStream) {\n            // Handle new stream added\n            Log.d(TAG, &quot;onAddStream: &quot;+mediaStream);\n        }\n\n        @Override\n        public void onRemoveStream(MediaStream mediaStream) {\n            // Handle stream removed\n            Log.d(TAG, &quot;onRemoveStream: &quot;+mediaStream);\n        }\n\n        @Override\n        public void onDataChannel(DataChannel dataChannel) {\n            // Handle data channel\n            Log.d(TAG, &quot;onDataChannel: &quot;+dataChannel);\n        }\n\n        @Override\n        public void onRenegotiationNeeded() {\n            // Handle renegotiation needed\n        }\n\n        @Override\n        public void onAddTrack(RtpReceiver rtpReceiver, MediaStream[] mediaStreams) {\n\n        }\n    }\n\n\n    // Helper class for handling SDP observer events\n    private static class SimpleSdpObserver implements SdpObserver {\n        @Override\n        public void onCreateSuccess(SessionDescription sessionDescription) {\n            Log.d(TAG, &quot;onCreateSuccess: Class Session Description = &quot;+sessionDescription.description);\n        }\n\n        @Override\n        public void onSetSuccess() {\n            Log.d(TAG, &quot;onSetSuccess: &quot;);\n        }\n\n        @Override\n        public void onCreateFailure(String s) {}\n\n        @Override\n        public void onSetFailure(String s) {}\n    }\n\n   \n\n    private void addIceCandidates(String iceCandidates){\n        IceCandidate iceCandidateObject = new IceCandidate(&quot;sdpMid&quot;, 0,iceCandidates);\n        // Add the IceCandidate object to the PeerConnection\n        peerConnection.addIceCandidate(iceCandidateObject);\n    }\n\n    \n}\n</code></pre>\n<p>Despite the ICE candidates being exchanged, the connection doesn't transition to a &quot;Connected&quot; state. I've verified that both users are sending and receiving ICE candidates.</p>\n<p>Has anyone encountered a similar issue with WebRTC on Android? What might prevent the ICE connection from progressing beyond the &quot;Checking&quot; state?</p>\n<p>I am using this webrtc library <a href=\"https://github.com/rno/WebRTC\" rel=\"nofollow noreferrer\">https://github.com/rno/WebRTC</a></p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}