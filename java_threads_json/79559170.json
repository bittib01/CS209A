{
  "question": {
    "tags": [
      "java",
      "pdf",
      "itext",
      "digital-signature"
    ],
    "owner": {
      "account_id": 29768047,
      "reputation": 21,
      "user_id": 22813973,
      "user_type": "registered",
      "profile_image": "https://lh3.googleusercontent.com/a/ACg8ocLA8opsl_DED0Ee_aq8ZS-gaCh8eSUezRfDLNV6pXydCJM=k-s256",
      "display_name": "Igor Stajic",
      "link": "https://stackoverflow.com/users/22813973/igor-stajic"
    },
    "is_answered": true,
    "view_count": 121,
    "answer_count": 1,
    "score": 2,
    "last_activity_date": 1745312936,
    "creation_date": 1744005710,
    "last_edit_date": 1745021288,
    "question_id": 79559170,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79559170/hash-mismatch-before-qes-signing-with-swisscom-and-itext-7-hash-mismatch-exp",
    "title": "Hash mismatch before QES signing with Swisscom and iText 7 – &quot;Hash mismatch! Expected ... Got",
    "body": "<p>I'm implementing a Qualified Electronic Signature (QES) flow using Swisscom Trust Services and iText 7.2.5 in Java. I'm stuck on the step where I compare the SHA-256 hash generated during PrepareHash with the expected hash (used to generate the signature via Swisscom). The hashes do not match, and therefore, the signing fails.</p>\n<p>Steps:</p>\n<ol>\n<li>Prepare the PDF and hash:\nUse PdfSigner in append mode.</li>\n</ol>\n<p>Add a blank signature field with ExternalBlankSignatureContainer.</p>\n<p>Save the resulting <code>_prepared.pdf</code>.</p>\n<p>Calculate the SHA-256 hash of the full prepared PDF file and send it to Swisscom.</p>\n<ol start=\"2\">\n<li>Sign:</li>\n</ol>\n<p>After receiving the <code>SignatureObject.cms</code> from Swisscom, I reopened the prepared PDF, verified the hash again, and tried to embed the signature using signDeferred.</p>\n<p>My main classes:</p>\n<pre class=\"lang-java prettyprint-override\"><code>import com.itextpdf.io.image.ImageData;\nimport com.itextpdf.io.image.ImageDataFactory;\nimport com.itextpdf.kernel.geom.Rectangle;\nimport com.itextpdf.kernel.pdf.*;\nimport com.itextpdf.layout.Canvas;\nimport com.itextpdf.layout.element.Image;\nimport com.itextpdf.signatures.*;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\n\nimport java.io.*;\nimport java.security.MessageDigest;\nimport java.security.Security;\nimport java.util.*;\n\npublic class PrepareHash {\n    public static void main(String[] args) {\n        if (args.length &lt; 3) {\n            System.err.println(&quot;Usage: java PrepareHash &lt;inputPDF&gt; &lt;outputPDF&gt; &lt;signatureImagePath&gt;...&quot;);\n            return;\n        }\n\n        String inputPDF = args[0];\n        String outputPDF = args[1];\n        String[] signatureImagePaths = Arrays.copyOfRange(args, 2, args.length);\n\n        try {\n            Security.addProvider(new BouncyCastleProvider());\n\n            // Add visual overlays\n            ByteArrayOutputStream visualized = new ByteArrayOutputStream();\n            PdfDocument pdfDoc = new PdfDocument(new PdfReader(inputPDF), new PdfWriter(visualized));\n\n            for (int i = 0; i &lt; signatureImagePaths.length; i++) {\n                ImageData imageData = ImageDataFactory.create(signatureImagePaths[i]);\n                Image image = new Image(imageData);\n\n                Rectangle pageSize = pdfDoc.getPage(i + 1).getPageSize();\n                image.setFixedPosition(i + 1, 0, 0);\n                image.setWidth(pageSize.getWidth());\n                image.setHeight(pageSize.getHeight());\n\n                new Canvas(pdfDoc.getPage(i + 1), pageSize).add(image);\n            }\n            pdfDoc.close();\n\n            // Hash and prepare the signed placeholder PDF\n            ByteArrayInputStream hashInput = new ByteArrayInputStream(visualized.toByteArray());\n            FileOutputStream signedOut = new FileOutputStream(outputPDF);\n            PdfSigner signer = new PdfSigner(new PdfReader(hashInput), signedOut, new StampingProperties().useAppendMode());\n            signer.setFieldName(&quot;Signature1&quot;);\n\n            MessageDigest digest = MessageDigest.getInstance(&quot;SHA-256&quot;);\n\n            IExternalSignatureContainer dummyContainer = new IExternalSignatureContainer() {\n                @Override\n                public byte[] sign(InputStream is) {\n                    try {\n                        byte[] buffer = new byte[8192];\n                        int read;\n                        while ((read = is.read(buffer)) != -1) {\n                            digest.update(buffer, 0, read);\n                        }\n                        byte[] hash = digest.digest();\n                        String base64Hash = Base64.getEncoder().encodeToString(hash);\n                        System.out.println(&quot;✅ SHA-256 hash generated (Base64): &quot; + base64Hash);\n                        return new byte[0];\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n\n                @Override\n                public void modifySigningDictionary(PdfDictionary dic) {\n                    dic.put(PdfName.Filter, PdfName.Adobe_PPKLite);\n                    dic.put(PdfName.SubFilter, PdfName.ETSI_CAdES_DETACHED);\n                    dic.put(PdfName.M, new PdfString(new PdfDate().toString()));\n                    dic.put(PdfName.Reason, new PdfString(&quot;Visual signature + Hash&quot;));\n                    dic.put(PdfName.Location, new PdfString(&quot;DS | SIGN&quot;));\n                }\n            };\n\n            signer.signExternalContainer(dummyContainer, 25000);\n            System.out.println(&quot;✅ Placeholder signature field added and PDF saved to: &quot; + outputPDF);\n\n        } catch (Exception e) {\n            System.err.println(&quot;❌ Error: &quot; + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n}\n\n\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>\nimport com.itextpdf.kernel.pdf.*;\nimport com.itextpdf.signatures.*;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\n\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.security.Security;\n\npublic class SignQES {\n    public static void main(String[] args) {\n        if (args.length &lt; 4) {\n            System.err.println(&quot;Usage: java SignQES &lt;prepared.pdf&gt; &lt;output_signed.pdf&gt; &lt;signatureObject.cms&gt; &lt;reason&gt;&quot;);\n            System.exit(1);\n        }\n\n        String inputPdf = args[0];\n        String outputPdf = args[1];\n        String signatureCmsPath = args[2];\n        String reason = args[3];\n\n        try {\n            Security.addProvider(new BouncyCastleProvider());\n            byte[] signatureBytes = Files.readAllBytes(Paths.get(signatureCmsPath));\n\n            PdfReader reader = new PdfReader(inputPdf);\n            PdfSigner signer = new PdfSigner(reader, new FileOutputStream(outputPdf), new StampingProperties().useAppendMode());\n\n            IExternalSignatureContainer container = new IExternalSignatureContainer() {\n                @Override\n                public byte[] sign(InputStream data) {\n                    return signatureBytes;\n                }\n\n                @Override\n                public void modifySigningDictionary(PdfDictionary dic) {\n                    dic.put(PdfName.Filter, PdfName.Adobe_PPKLite);\n                    dic.put(PdfName.SubFilter, PdfName.ETSI_CAdES_DETACHED);\n                }\n            };\n\n            signer.signDeferred(signer.getDocument(), &quot;Signature1&quot;, new FileOutputStream(outputPdf), container);\n            System.out.println(&quot;QES Signature applied to: &quot; + outputPdf);\n\n        } catch (Exception e) {\n            System.err.println(&quot;Signing error: &quot; + e.getMessage());\n            e.printStackTrace();\n            System.exit(2);\n        }\n    }\n}\n\n\n\n</code></pre>\n<p>UPDATE3.0\nI'm using iText 7 (v7.2.5, AGPL version) and BouncyCastle (v1.74) to implement Qualified Electronic Signatures (QES) in Java. I generate the signature hash using signDeferred() and later receive a CMS signature from an external Trust Service Provider (Swisscom) which I then embed using signExternalContainer.</p>\n<p>Everything works fine, but I need to ensure the signing-time attribute is explicitly present in the CMS signature. Since I'm manually assembling the CMS structure via BouncyCastle before embedding it, I'm wondering:</p>\n<p>How can I add the signing-time attribute manually when using the signDeferred() method?</p>\n<p>Is there a clean way to inject signing-time using BouncyCastle (since SignerInformation.replaceSignedAttributes() is not available in v1.74)?</p>\n<p>Can this be done before embedding with signExternalContainer()?</p>\n<p>Dependencies:</p>\n<ul>\n<li><p>iText 7.2.5</p>\n</li>\n<li><p>BouncyCastle 1.74</p>\n</li>\n<li><p>Swisscom QES API (ETSI format)\n<img src=\"https://i.sstatic.net/AJFk3Kf8.png\" alt=\"enter image description here\" />\n<img src=\"https://i.sstatic.net/V0sqc31t.png\" alt=\"enter image description here\" />\n<a href=\"https://i.sstatic.net/Cbqd1JVr.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/Cbqd1JVr.png\" alt=\"enter image description here\" /></a>\n<a href=\"https://i.sstatic.net/82WuI2IT.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/82WuI2IT.png\" alt=\"enter image description here\" /></a></p>\n</li>\n</ul>\n<p>Everything else is green and valid.</p>\n<p>Any ideas or working examples would be deeply appreciated!</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}