{
  "question": {
    "tags": [
      "java",
      "encryption",
      "aes",
      "bouncycastle",
      "aes-gcm"
    ],
    "owner": {
      "account_id": 34176597,
      "reputation": 9,
      "user_id": 26426704,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/d1bcadd60008f583d52c4cd51133f6e9?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Suraj Putta",
      "link": "https://stackoverflow.com/users/26426704/suraj-putta"
    },
    "is_answered": true,
    "view_count": 208,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1725633763,
    "creation_date": 1721340400,
    "last_edit_date": 1721472384,
    "question_id": 78766841,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78766841/aes-gcm-java-bouncycastle-decryption-fails-second-time",
    "title": "AES GCM Java BouncyCastle decryption fails second time",
    "body": "<p>Using the below lines of code for Encrypting and Decrypting using BouncyCastle for decrypting data received from a 3rd party source based on C. First encryption and decryption works fine(basis the initial key and iv shared by the 3rd party which they have asked to use through out the session), second encryption and decryption fails.. mostly because I am using the same IV again if you notice. Looking for what might be the logic for the new IV creation and how am i supposed to send it to the 3rd party (if i do not send it, how can they decrypt without knowing the created IV)</p>\n<pre><code>public byte[] encrypt(byte[] plainBytes) {\n        byte[] encryptedBytes = new byte[0];\n        try {\n            GCMBlockCipher cipher = new GCMBlockCipher(new AESFastEngine());\n            AEADParameters parameters =\n                    new AEADParameters(new KeyParameter(key), MacBitSize, iv);\n\n            cipher.init(true, parameters);\n\n            encryptedBytes = new byte[cipher.getOutputSize(plainBytes.length)];\n            int retLen = cipher.processBytes\n                    (plainBytes, 0, plainBytes.length, encryptedBytes, 0);\n            cipher.doFinal(encryptedBytes, retLen);\n        } catch (IllegalArgumentException |\n                 IllegalStateException | DataLengthException |\n                 InvalidCipherTextException ex) {\n            System.out.println(ex.getMessage());\n        }\n        System.arraycopy(aad, 0, encryptedBytes, plainBytes.length, 16);\n        byte[] final_encr = new byte[plainBytes.length];\n        System.arraycopy(encryptedBytes, 0, final_encr, 0, plainBytes.length);\n        return final_encr;\n    }\n\n    public byte[] decrypt(byte[] encryptedBytes) {\n        byte[] plainBytes = new byte[0];\n        try {\n            GCMBlockCipher cipher = new GCMBlockCipher(new AESFastEngine());\n            AEADParameters parameters =\n                    new AEADParameters(new KeyParameter(key), MacBitSize, iv);\n\n            cipher.init(false, parameters);\n            cipher.processAADBytes(aad, 0, aad.length);\n            plainBytes = new byte[encryptedBytes.length];\n            int retLen = cipher.processBytes\n                    (encryptedBytes, 0, encryptedBytes.length, plainBytes, 0);\n            retLen += cipher.processBytes(aad, 0, aad.length, plainBytes, retLen);\n            retLen += cipher.doFinal(plainBytes, retLen);\n        } catch (IllegalArgumentException | IllegalStateException |\n                 DataLengthException | InvalidCipherTextException ex) {\n            System.out.println(ex.getMessage());\n        }\n        return plainBytes;\n    }\n</code></pre>\n<ol>\n<li>Have tried to replace the last four digits of the iv and increase it incrementally</li>\n<li>Tried C JNI library implementaion</li>\n<li>Other libraries like kalium, JCE.. didn't work</li>\n</ol>\n<p><strong>Methodology provided by third party in the doc</strong><br />\nFor symmetric encryption/decryption methodology –<br />\n<em>Encryption:</em><br />\nInitialization →</p>\n<pre><code>void encrypt_EVP_aes_256_cbc_init(EVP_CIPHER_CTX ** ctx, unsigned char * key,\n    unsigned char * iv) {\n    if (!( * ctx = EVP_CIPHER_CTX_new()))\n        handleErrors();\n\n    if (1 != EVP_EncryptInit_ex( * ctx, EVP_aes_256_gcm(), NULL, key, iv))\n        handleErrors();\n}\n</code></pre>\n<p>Encryption →</p>\n<pre><code>void encrypt(EVP_CIPHER_CTX * ctx, unsigned char * plaintext, int plaintext_len,\n    unsigned char * ciphertext, int * ciphertext_len) {\n    int len;\n\n    if (1 != EVP_EncryptUpdate(ctx, ciphertext, &amp; len, plaintext, plaintext_len))\n        handleErrors();\n    * ciphertext_len = len;\n}\n</code></pre>\n<p><em>Decryption:</em></p>\n<p>Initialization→</p>\n<pre><code>void decrypt_EVP_aes_256_cbc_init(EVP_CIPHER_CTX ** ctx, unsigned char * key,\n    unsigned char * iv) {\n    if (!( * ctx = EVP_CIPHER_CTX_new()))\n        handleErrors();\n\n    if (1 != EVP_DecryptInit_ex( * ctx, EVP_aes_256_gcm(), NULL, key, iv))\n        handleErrors();\n}\n</code></pre>\n<p>Decryption→</p>\n<pre><code>int decrypt(EVP_CIPHER_CTX * ctx, unsigned char * ciphertext, int ciphertext_len,\n    unsigned char * plaintext, int * plaintext_len) {\n    int len;\n\n    if (1 != EVP_DecryptUpdate(ctx, plaintext, &amp; len, ciphertext, ciphertext_len))\n        handleErrors();\n    * plaintext_len = len;\n}\n</code></pre>\n<p><strong>Note –</strong></p>\n<ul>\n<li>The ones highlighted in bold are OpenSSL library functions.</li>\n<li>plaintext is the actual message buffer.</li>\n<li>ciphertext is the encrypted message buffer.</li>\n</ul>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}