{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "tomcat",
      "error-handling"
    ],
    "owner": {
      "account_id": 17724494,
      "reputation": 63,
      "user_id": 13447729,
      "user_type": "registered",
      "profile_image": "https://lh3.googleusercontent.com/a-/AAuE7mATMmQbGSpmFDV99qem84G3SPZ8XeI8VDjhIRF6ZA=k-s256",
      "display_name": "wanderbild",
      "link": "https://stackoverflow.com/users/13447729/wanderbild"
    },
    "is_answered": true,
    "view_count": 549,
    "accepted_answer_id": 78985367,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1726324288,
    "creation_date": 1715281752,
    "last_edit_date": 1721287178,
    "question_id": 78456516,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78456516/how-to-override-default-tomcat-404-not-found-html-page-in-spring-boot-3-2",
    "title": "How to override default Tomcat 404 not found html page in Spring Boot 3.2?",
    "body": "<p>I'm working on a Spring Boot 3.2 (Apache Tomcat 10) application and have set a custom context path (<code>/api</code>). I want to replace the default HTML error responses from Tomcat with JSON/status-only responses. However, I am encountering difficulties handling 404 errors that occur outside of the context path - on a bare base URL, for example. I get this:</p>\n<pre><code>...\n&lt;body&gt;\n    &lt;h1&gt;HTTP Status 404 â€“ Not Found&lt;/h1&gt;\n    &lt;hr class=&quot;line&quot; /&gt;\n    &lt;p&gt;&lt;b&gt;Type&lt;/b&gt; Status Report&lt;/p&gt;\n    &lt;p&gt;&lt;b&gt;Description&lt;/b&gt; The origin server did not find a current representation for the target resource or is not\n        willing to disclose that one exists.&lt;/p&gt;\n    &lt;hr class=&quot;line&quot; /&gt;\n    &lt;h3&gt;Apache Tomcat/10.1.19&lt;/h3&gt;\n&lt;/body&gt;\n...\n</code></pre>\n<p>My configs:</p>\n<p><strong>Global Exception Handler</strong></p>\n<pre><code>@Slf4j\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n\n    @ExceptionHandler(Exception.class)\n    public ResponseEntity&lt;?&gt; handleGlobalException(Exception ex) {\n        log.error(&quot;An error occurred: {}&quot;, ex.getMessage(), ex);\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(new ApiResponse(false, ex.getMessage()));\n    }\n\n    @ExceptionHandler(NoResourceFoundException.class)\n    public ResponseEntity&lt;?&gt; handleNoResourceFoundException(NoResourceFoundException ignored) {\n        return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);\n    }\n}\n\n</code></pre>\n<p><strong>Security Configuration</strong></p>\n<pre><code>@Bean\npublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n    return http.csrf(AbstractHttpConfigurer::disable)\n            .cors(Customizer.withDefaults())\n            .exceptionHandling(exception -&gt;\n                    exception.authenticationEntryPoint(new HttpStatusEntryPoint(HttpStatus.NOT_FOUND)))\n            .authorizeHttpRequests(auth -&gt; auth.requestMatchers(PERMIT_ALL_URL_PATTERNS.toArray(new String[0]))\n                    .permitAll()\n                    .anyRequest()\n                    .authenticated())\n            .sessionManagement(manager -&gt; manager.sessionCreationPolicy(STATELESS))\n            .formLogin(AbstractHttpConfigurer::disable)\n            .httpBasic(AbstractHttpConfigurer::disable)\n            .oauth2Login(loginConfigurer -&gt; loginConfigurer\n                    .userInfoEndpoint(endpointConfig -&gt; endpointConfig.userService(customOAuth2UserService))\n                    .successHandler(oAuth2AuthenticationSuccessHandler)\n                    .authorizationEndpoint(authEndPoint -&gt;\n                            authEndPoint.authorizationRequestRepository(authorizationRequestRepository))\n                    .failureHandler(oAuth2AuthenticationFailureHandler))\n            .build();\n}\n\n</code></pre>\n<p>Observed Issues:</p>\n<ul>\n<li>For URLs within the context path, everything is handled as expected.</li>\n<li>For URLs outside the context path, Tomcat's default HTML error pages are returned.</li>\n</ul>\n<p>What I tried:</p>\n<ul>\n<li><code>spring.mvc.throw-exception-if-no-handler-found</code> - it's deprecated, IIUC NoHandlerFoundException is no longer thrown in new Spring Boot versions.</li>\n<li><code>error.whitelabel.enabled=false</code> - useless for me, since all errors that can happen in my application are handled with a global exception handler anyway.</li>\n</ul>\n<p><strong>CustomErrorController</strong></p>\n<pre><code>import org.springframework.boot.web.servlet.error.ErrorController;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Controller\npublic class CustomErrorController implements ErrorController {\n\n    @RequestMapping(&quot;/error&quot;)\n    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleError(HttpServletRequest request) {\n        Object status = request.getAttribute(&quot;javax.servlet.error.status_code&quot;);\n        HttpStatus httpStatus = HttpStatus.valueOf(Integer.parseInt(status.toString()));\n\n        Map&lt;String, String&gt; response = new HashMap&lt;&gt;();\n        response.put(&quot;error&quot;, httpStatus.getReasonPhrase());\n        response.put(&quot;message&quot;, &quot;The requested URL was not found on this server.&quot;);\n\n        return new ResponseEntity&lt;&gt;(response, httpStatus);\n    }\n\n    @Override\n    public String getErrorPath() {\n        return &quot;/error&quot;;\n    }\n}\n\n</code></pre>\n<p><strong>Custom ErrorReportValve</strong></p>\n<pre><code>@Slf4j\npublic class CustomTomcatErrorValve extends ErrorReportValve {\n\n    @Override\n    protected void report(Request request, Response response, Throwable throwable) {\n\n        if (!response.setErrorReported()) return;\n\n        if (log.isDebugEnabled())\n            log.debug(\n                    &quot;Tomcat failed to prepare the request for spring (set response code to {}).&quot;,\n                    response.getStatus(),\n                    throwable);\n\n        HttpStatus status = HttpStatus.valueOf(response.getStatus());\n\n        try {\n\n            response.setContentType(&quot;application/problem+json&quot;);\n            Writer writer = response.getReporter();\n            writer.write(String.format(\n                    &quot;&quot;&quot;\n                    {\n                        &quot;title&quot;: &quot;%s&quot;,\n                        &quot;status&quot;: %d\n                    }&quot;&quot;&quot;,\n                    status.getReasonPhrase(), status.value()));\n            response.finishResponse();\n        } catch (IOException ignored) {\n        }\n    }\n}\n\n</code></pre>\n<p><strong>Exception handler filter:</strong></p>\n<pre><code>@Slf4j\n@Component\npublic class UnhandledExceptionHandlerFilter extends OncePerRequestFilter {\n\n    private static class StatusCodeCaptureWrapper extends HttpServletResponseWrapper {\n\n        @Getter\n        private Integer statusCode;\n\n        @Getter\n        private final HttpServletRequest request;\n\n        @Getter\n        private final HttpServletResponse response;\n\n        public StatusCodeCaptureWrapper(HttpServletRequest request, HttpServletResponse response) {\n            super(response);\n            this.request = request;\n            this.response = response;\n        }\n    }\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n            throws IOException {\n        StatusCodeCaptureWrapper responseWrapper = new StatusCodeCaptureWrapper(request, response);\n        Throwable exception = null;\n\n        try {\n            chain.doFilter(request, responseWrapper);\n        } catch (ServletException e) {\n            exception = e.getRootCause();\n        } catch (Throwable e) {\n            exception = e;\n        }\n\n        if (exception != null\n                &amp;&amp; !&quot;ClientAbortException&quot;.equals(exception.getClass().getSimpleName())) {\n            ensureErrorStatusCodeSet(responseWrapper);\n            response.setStatus(responseWrapper.getStatusCode());\n            handleException(request, response, responseWrapper.getStatusCode(), exception);\n        }\n\n        response.flushBuffer();\n    }\n\n    private void ensureErrorStatusCodeSet(StatusCodeCaptureWrapper responseWrapper) {\n        if (responseWrapper.getStatusCode() == null) {\n            responseWrapper.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n        }\n    }\n\n    private void handleException(\n            HttpServletRequest request, HttpServletResponse response, int statusCode, Throwable throwable)\n            throws IOException {\n        log.error(&quot;Sending error response status {} for {} because of&quot;, statusCode, request.getRequestURI(), throwable);\n        response.setContentType(&quot;application/json&quot;);\n        response.setCharacterEncoding(&quot;UTF-8&quot;);\n\n        Map&lt;String, String&gt; responseBody = new HashMap&lt;&gt;();\n        responseBody.put(&quot;error&quot;, HttpStatus.valueOf(statusCode).getReasonPhrase());\n        responseBody.put(&quot;message&quot;, throwable.getMessage());\n        response.getWriter().write(new ObjectMapper().writeValueAsString(responseBody));\n    }\n}\n\n</code></pre>\n<p>How can I configure Spring Boot 3.2 to always return JSON error responses, especially for 404 errors, instead of Tomcat's default HTML error pages, even for URLs outside of the context path?</p>\n<p>Any guidance or solutions would be greatly appreciated!</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}