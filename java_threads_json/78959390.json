{
  "question": {
    "tags": [
      "java",
      "language-lawyer",
      "jls"
    ],
    "owner": {
      "account_id": 31912355,
      "reputation": 623,
      "user_id": 24723440,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/9ade3a8a08bf1b587f4f7294d28b35df?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "user24723440",
      "link": "https://stackoverflow.com/users/24723440/user24723440"
    },
    "is_answered": true,
    "view_count": 96,
    "answer_count": 1,
    "score": -1,
    "last_activity_date": 1728303425,
    "creation_date": 1725686131,
    "last_edit_date": 1728303425,
    "question_id": 78959390,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78959390/how-can-i-correctly-understand-the-concepts-of-fully-qualified-name-and-canonica",
    "title": "How can I correctly understand the concepts of fully qualified name and canonical name?",
    "body": "<p>My question comes from the example at the end of <a href=\"https://docs.oracle.com/javase/specs/jls/se22/html/jls-6.html#jls-6.7\" rel=\"nofollow noreferrer\">Chapter 6.7</a> of the <a href=\"https://docs.oracle.com/javase/specs/\" rel=\"nofollow noreferrer\"><em>Java Language Specification</em></a> ：</p>\n<blockquote>\n<p>The difference between a <em>fully qualified name</em> and a <em>canonical name</em> can\nbe seen in code such as:</p>\n</blockquote>\n<pre><code>package p; \nclass O1 { class I {} } \nclass O2 extends O1 {}\n</code></pre>\n<blockquote>\n<p>Both <code>p.O1.I</code> and <code>p.O2.I</code> are <em>fully qualified names</em> that denote the\nmember class I, but only <code>p.O1.I</code> is its <em>canonical name</em>.</p>\n</blockquote>\n<p>I don't quite understand why <code>p.O2.I</code> is not a <em>canonical name</em>.</p>\n<p>According to 6.7:</p>\n<blockquote>\n<p>Every primitive type, named package, top level class, and top level\ninterface has a <em>canonical name</em>:</p>\n<p>• For every primitive type, named package, top level class, and top\nlevel interface, the canonical name is the same as the fully qualified\nname.</p>\n<p>Each member class, member interface, and array type may have a\ncanonical name:</p>\n<p>• <em>A member class or member interface M declared in another class or\ninterface C has a  canonical name if and only if C has a canonical\nname.</em></p>\n</blockquote>\n<p>My understanding is that <code>p.O2.I</code> is &quot;<em>a member class or interface M declared in another class C</em>&quot;, Class <code>O2</code> is a top-level class, so it has a <em>canonical name</em> <code>p.O2</code>. Then according to the rule,Why isn't <code>p.O2.I</code> a <em>canonical name</em>?</p>\n<p>In addition, I also can't see the difference between a <em>canonical name</em> and a <em>fully qualified name</em> (compared to the previous quoted paragraph):</p>\n<blockquote>\n<p>Each member class, member interface, and array type may have a <em>fully\nqualified name</em>:</p>\n<p>• A member class or member interface M of another class or interface C\nhas a <em>fully qualified name</em> if and only if C has a <em>fully qualified\nname.</em></p>\n</blockquote>\n<p>Can anyone explain this to me in detail?\nThank you for your reading.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}