{
  "question": {
    "tags": [
      "java",
      "java-ffm",
      "java-22"
    ],
    "owner": {
      "account_id": 8416879,
      "reputation": 883,
      "user_id": 6317008,
      "user_type": "registered",
      "accept_rate": 78,
      "profile_image": "https://www.gravatar.com/avatar/6f0766de5f4a9354cd0f010e68f7ec96?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "SGiux",
      "link": "https://stackoverflow.com/users/6317008/sgiux"
    },
    "is_answered": true,
    "view_count": 331,
    "accepted_answer_id": 79521845,
    "answer_count": 2,
    "score": 6,
    "last_activity_date": 1742551215,
    "creation_date": 1742344076,
    "last_edit_date": 1742381686,
    "question_id": 79518865,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79518865/new-java-foreign-function-api-jep-454-working-with-c-strings-and-array-of-c-st",
    "title": "New Java Foreign Function Api JEP 454 - Working with c strings and array of c strings",
    "body": "<p>I'm playing with the new Foreign Function API. I followed the example in <a href=\"https://openjdk.org/jeps/454\" rel=\"nofollow noreferrer\">JEP 454</a>, showed in the description section. I tried using qsort instead of radix sort.</p>\n<p>Unfortunately, the document doesn't remain consistent with this example. In the Upcalls instead of building upon this example, it describes the qsort function in Java with ints (while the first non complete example - some code is missing - uses strings and qsort).</p>\n<p>I noticed that the FunctionDescriptor is different between downcalls and Upcalls. When there is the need to describe a pointer, in the downcall you can express it via <code>ADDRESS</code> while for Upcalls you have to specify the total size of the <code>MemorySegment</code>:</p>\n<pre><code>MethodHandle qsort = linker.downcallHandle(\n    linker.defaultLookup().find(&quot;qsort&quot;).get(),\n    FunctionDescriptor.ofVoid(ADDRESS, JAVA_LONG, JAVA_LONG, ADDRESS)\n);\n\nMemorySegment comparFunc\n    = linker.upcallStub(comparHandle,\n                        FunctionDescriptor.of(JAVA_INT,\n                                              ADDRESS.withTargetLayout(JAVA_INT),\n                                              ADDRESS.withTargetLayout(JAVA_INT)),\n                        Arena.ofAuto());\n</code></pre>\n<p>Instead of:</p>\n<pre><code>MemorySegment comparFunc\n    = linker.upcallStub(comparHandle,\n                        FunctionDescriptor.of(JAVA_INT,\n                                              ADDRESS,\n                                              ADDRESS,\n                        Arena.ofAuto());\n</code></pre>\n<p>Following this, I wrote my upcall code:</p>\n<pre><code>static MemorySegment compareStringsFuncDescriptor(Arena arena) {\n    return nativeLinker().upcallStub(compareStringFunction(),\n        // qsort needs takes a function &quot;int (*compar)(const void*,const void*)&quot; but in our case there is a cast therefore is int (*compar)(const char*, const char*)\n        FunctionDescriptor.of(\n            JAVA_INT, // Return type\n            ADDRESS.withTargetLayout(MemoryLayout.sequenceLayout(10, JAVA_CHAR)),\n            ADDRESS.withTargetLayout(MemoryLayout.sequenceLayout(10, JAVA_CHAR))\n        ), arena);\n}\n\nprivate static MethodHandle compareStringFunction() {\n    try {\n        return MethodHandles.lookup().findStatic(CFunctionImplementations.class,\n            &quot;strcmpJavaImpl&quot;, methodType(int.class, MemorySegment.class, MemorySegment.class));\n    } catch (NoSuchMethodException | IllegalAccessException e) {\n        throw new RuntimeException(e);\n    }\n}\n\nprivate static int strcmpJavaImpl(MemorySegment pString1, MemorySegment pString2) {\n    String s1 = pString1.getAtIndex(ADDRESS.withTargetLayout(MemoryLayout.sequenceLayout(10, JAVA_CHAR)), 0).getString(0);\n    String s2 = pString2.getAtIndex(ADDRESS.withTargetLayout(MemoryLayout.sequenceLayout(10, JAVA_CHAR)), 0).getString(0);\n\n    assert s1 != null;\n    assert s2 != null;\n    System.out.println(&quot;Comparing: &quot; + s1 + &quot; with &quot; + s2);\n    return s1.compareTo(s2); // Use java method\n} \n</code></pre>\n<p>and this is the method to copy the sorted array from native memory to heap:</p>\n<pre><code>private static void copySortedArrayFromNativeMemoryToHeap(String[] strings, MemorySegment pStrings) {\n    for (int i = 0; i &lt; strings.length; i++) {\n        strings[i] = pStrings.getAtIndex(ADDRESS.withTargetLayout(MemoryLayout.sequenceLayout(10, JAVA_CHAR)), i)\n            .getString(0);\n    }\n}\n</code></pre>\n<p>The question regards the AddressLayout used:</p>\n<pre><code>ADDRESS.withTargetLayout(MemoryLayout.sequenceLayout(10, JAVA_CHAR)) \n</code></pre>\n<p>I'm not convinced about my own implementation but I didn't find a better way to do it. The array used to test my code is:</p>\n<pre><code>string[] strings = {&quot;mouse&quot;, &quot;cat&quot;, &quot;crocodile&quot;, &quot;dog&quot;, &quot;car&quot;}\n</code></pre>\n<p>A the beginning I was using:</p>\n<pre><code>ADDRESS.withTargetLayout(ADDRESS)\n</code></pre>\n<p>but it started to fail when I added <em>&quot;crocodile&quot;</em> because this string doesn't fit in just 8 bytes.</p>\n<p>How to make this code more &quot;dynamic&quot;? Should someone uses the max string length in the array and replace the static <code>10</code> number with it? I'm not convinced! What a waste of memory if I use a memory layout of <code>10 * JAVA_CHAR</code> or even worse <code>MAX_STRING_LENGTH * JAVA_CHAR</code></p>\n<p>I saw that in the example in <a href=\"https://openjdk.org/jeps/454\" rel=\"nofollow noreferrer\">JEP 454</a>,copies from off-heap to on-heap is done in this way:</p>\n<pre><code>// 7. Copy the (reordered) strings from off-heap to on-heap\nfor (int i = 0; i &lt; javaStrings.length; i++) {\n    MemorySegment cString = pointers.getAtIndex(ValueLayout.ADDRESS, i);\n    javaStrings[i] = cString.reinterpret(...).getString(0);\n}\n</code></pre>\n<p>The author didn't specify the parameter of the <code>reinterpret</code> function and in fact how it is possible to specify it if we are not sure of the size of the string we are trying to copy since the array is now sorted in a way that is possibly different from the input array??? That's why I didn't use <code>reinterpret</code> in my solution.</p>\n<p><strong>EDIT:</strong></p>\n<p>I updated the code. Now:</p>\n<pre><code>ADDRESS.withTargetLayout(MemoryLayout.sequenceLayout(10, JAVA_CHAR)) \n</code></pre>\n<p>has been replaced with:</p>\n<pre><code>ADDRESS.withTargetLayout(MemoryLayout.sequenceLayout(maxtringByteSizeWithCEndChar, JAVA_BYTE));\n</code></pre>\n<p>In my example <code>stringByteSizeWithCEndChar</code> is equals to <code>crocodile.length + 1</code>. Given the hypotheses that the Charset is <code>UTF_8</code> the byte size for a char is 1 instead of <code>JAVA_CHAR.byteSize()</code> which is 2 for my platform. So the target layout size is 10 bytes instead of 20 bytes. Still the question remains. Can I do any better? And does it make sense to do any better? The total off heap allocation for the array should now arraySize * 10 bytes = 50 bytes!</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}