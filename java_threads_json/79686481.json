{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "open-telemetry",
      "open-telemetry-java"
    ],
    "owner": {
      "account_id": 14482834,
      "reputation": 5478,
      "user_id": 10461625,
      "user_type": "registered",
      "profile_image": "https://i.sstatic.net/fgo5D.jpg?s=256",
      "display_name": "PatPanda",
      "link": "https://stackoverflow.com/users/10461625/patpanda"
    },
    "is_answered": true,
    "view_count": 219,
    "accepted_answer_id": 79699789,
    "answer_count": 1,
    "score": 3,
    "last_activity_date": 1752485028,
    "creation_date": 1751394917,
    "last_edit_date": 1751395266,
    "question_id": 79686481,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79686481/create-an-extra-trace-representing-the-time-spent-inside-kafka-using-spring-ka",
    "title": "Create an extra trace representing the &quot;time spent inside Kafka&quot; using Spring Kafka / OpenTelemetry",
    "body": "<p>I'm working with a Spring Boot Kafka consumer that uses OpenTelemetry for tracing.</p>\n<p>Currently, I have a single span that covers the entire message processing, but I want to create a separate, an extra span, dedicated span specifically for measuring the time the message was inside Kafka before being processed.</p>\n<p>Here's my current implementation:</p>\n<pre><code>package org.example;\n\nimport org.springframework.kafka.annotation.KafkaListener;\nimport org.springframework.stereotype.Service;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport io.opentelemetry.api.trace.Span;\nimport io.opentelemetry.api.trace.Tracer;\nimport io.opentelemetry.api.trace.StatusCode;\nimport io.opentelemetry.context.Context;\nimport io.opentelemetry.context.propagation.TextMapGetter;\nimport io.opentelemetry.context.propagation.TextMapPropagator;\nimport io.opentelemetry.api.OpenTelemetry;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport java.time.Instant;\nimport java.util.Map;\nimport java.util.HashMap;\n\n@Service\npublic class ConsumerService {\n\n    @Autowired\n    private Tracer tracer;\n\n    @Autowired\n    private OpenTelemetry openTelemetry;\n\n    @KafkaListener(topics = &quot;sample-topic&quot;, groupId = &quot;group-2&quot;)\n    public void consumeLinksWithRecord(ConsumerRecord&lt;String, String&gt; record) {\n        String word = record.value();\n\n        String traceparent = record.headers().lastHeader(&quot;traceparent&quot;) != null\n                ? new String(record.headers().lastHeader(&quot;traceparent&quot;).value())\n                : &quot;No traceparentid header found&quot;;\n\n        // Create a span for Kafka message processing with ConsumerRecord\n        Span span = tracer.spanBuilder(&quot;inside-kafka&quot;)\n                .setAttribute(&quot;service.name&quot;, &quot;insidekafkaservice&quot;)\n                .setAttribute(&quot;kafka.topic&quot;, record.topic())\n                .setAttribute(&quot;kafka.partition&quot;, record.partition())\n                .setAttribute(&quot;kafka.offset&quot;, record.offset())\n                .setAttribute(&quot;kafka.key&quot;, record.key() != null ? record.key() : &quot;null&quot;)\n                .setAttribute(&quot;kafka.message&quot;, word)\n                .setAttribute(&quot;kafka.traceparent&quot;, traceparent)\n                .setStartTimestamp(Instant.ofEpochMilli(record.timestamp()))\n                .startSpan();\n\n        try (var scope = span.makeCurrent()) {\n\n                extractTraceContext(traceparent, span);\n\n            System.out.println(&quot;Received Message: &quot; + word + &quot; from partition: &quot; + record.partition());\n            System.out.println(&quot;Trace Parent ID: &quot; + traceparent);\n\n            // Add custom attributes to the span\n            span.setAttribute(&quot;message.length&quot;, word.length());\n            span.setAttribute(&quot;header.count&quot;, record.headers().spliterator().getExactSizeIfKnown());\n\n            try {\n                Thread.sleep(80);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                span.setStatus(StatusCode.ERROR, &quot;Processing interrupted&quot;);\n                return;\n            }\n            \n            span.setStatus(StatusCode.OK);\n            \n        } catch (Exception e) {\n            span.setStatus(StatusCode.ERROR, e.getMessage());\n            span.recordException(e);\n            throw e;\n        } finally {\n            span.end();\n        }\n    }\n\n    private void extractTraceContext(String traceparentId, Span span) {\n        try {\n            // Create a carrier map with the traceparentid\n            Map&lt;String, String&gt; carrier = new HashMap&lt;&gt;();\n            carrier.put(&quot;traceparent&quot;, traceparentId);\n            \n            // Extract the context using the W3C trace context propagator\n            TextMapPropagator propagator = openTelemetry.getPropagators().getTextMapPropagator();\n            Context extractedContext = propagator.extract(Context.current(), carrier, new TextMapGetter&lt;Map&lt;String, String&gt;&gt;() {\n                @Override\n                public String get(Map&lt;String, String&gt; carrier, String key) {\n                    return carrier.get(key);\n                }\n                \n                @Override\n                public Iterable&lt;String&gt; keys(Map&lt;String, String&gt; carrier) {\n                    return carrier.keySet();\n                }\n            });\n            \n            // Link the extracted context to the current span\n            if (extractedContext != Context.current()) {\n                span.addLink(Span.fromContext(extractedContext).getSpanContext());\n            }\n            \n        } catch (Exception e) {\n            // Log the error but don't fail the processing\n            System.err.println(&quot;Failed to extract trace context: &quot; + e.getMessage());\n        }\n    }\n}\n\n</code></pre>\n<p>For instance, if:</p>\n<ul>\n<li>the producer starts their logic at 00:00</li>\n<li>the producer finishes their logic and puts the message inside Kafka at 00:01</li>\n<li>the consumer picked up the message at 00:04</li>\n<li>the consumer finished their business logic on the message at 00:05</li>\n</ul>\n<p>that would mean the message stayed inside Kafka from 00:01 to 00:04.</p>\n<p>I would expect to see traces like this:</p>\n<p><a href=\"https://i.sstatic.net/6HldxjMB.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/6HldxjMB.png\" alt=\"enter image description here\" /></a></p>\n<p>But instead, I am currently seeing this:</p>\n<p><a href=\"https://i.sstatic.net/yFlSLt0w.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/yFlSLt0w.png\" alt=\"enter image description here\" /></a></p>\n<p>How to create the extra trace representing the time spent in Kafka?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}