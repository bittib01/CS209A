{
  "question": {
    "tags": [
      "java",
      "spring",
      "hibernate",
      "jpa"
    ],
    "owner": {
      "account_id": 10187542,
      "reputation": 2735,
      "user_id": 20692967,
      "user_type": "registered",
      "profile_image": "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name": "Sergey Zolotarev",
      "link": "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "is_answered": false,
    "view_count": 57,
    "answer_count": 0,
    "score": 1,
    "last_activity_date": 1747926869,
    "creation_date": 1747848727,
    "last_edit_date": 1747926869,
    "question_id": 79632498,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79632498/updating-jpa-entity-graphs-automatically",
    "title": "Updating JPA entity graphs automatically",
    "body": "<p>Imagine my backend's <code>PUT</code> endpoint receives this <code>UserRequestDto</code>:</p>\n<pre class=\"lang-json prettyprint-override\"><code>{\n  &quot;id&quot;: 12345,\n  &quot;name&quot;: &quot;steve123&quot;,\n  &quot;emailData&quot;: [\n    &quot;steve@gmail.com&quot;,\n    &quot;steve@outlook.com&quot;\n  ]\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.List;\n\n@Getter\n@Setter\npublic class UserRequestDto {\n\n    private Long id;\n    private String name;\n    private List&lt;String&gt; emailData;\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.GenerationType;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.OneToMany;\nimport jakarta.persistence.Table;\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.List;\n\n@Entity\n@Getter\n@Setter\n@Table(name = &quot;\\&quot;user\\&quot;&quot;)\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    private String name;\n    @OneToMany(mappedBy = &quot;user&quot;, cascade = CascadeType.ALL)\n    private List&lt;EmailData&gt; emailData;\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import jakarta.persistence.Entity;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.GenerationType;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.JoinColumn;\nimport jakarta.persistence.ManyToOne;\nimport jakarta.persistence.Table;\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Entity\n@Getter\n@Setter\n@Table(name = &quot;email_data&quot;)\npublic class EmailData {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    @ManyToOne\n    @JoinColumn(name = &quot;user_id&quot;)\n    private User user;\n    private String email;\n}\n</code></pre>\n<pre class=\"lang-sql prettyprint-override\"><code>-- schema.sql\nCREATE TABLE IF NOT EXISTS &quot;user&quot;\n(\n    id                      BIGINT GENERATED BY DEFAULT AS IDENTITY,\n    name                    VARCHAR(500) UNIQUE NOT NULL,\n    PRIMARY KEY (id)\n);\n\nCREATE TABLE IF NOT EXISTS email_data\n(\n    id                      BIGINT GENERATED BY DEFAULT AS IDENTITY,\n    user_id                 BIGINT NOT NULL REFERENCES &quot;user&quot;(id),\n    email                   VARCHAR(200) UNIQUE NOT NULL,\n    PRIMARY KEY (id)\n);\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import com.example.pixel_user_api.data.dto.request.UserRequestDto;\nimport com.example.pixel_user_api.data.dto.response.UserResponseDto;\nimport com.example.pixel_user_api.service.UserService;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.PutMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(&quot;/api/user&quot;)\n@RequiredArgsConstructor\npublic class UserController {\n\n    private final UserService userService;\n\n    @PutMapping\n    public ResponseEntity&lt;UserResponseDto&gt; updateUser(@RequestBody UserRequestDto userRequestDto) {\n        UserResponseDto userResponseDto = userService.update(userRequestDto);\n        return ResponseEntity.ok(userResponseDto);\n    }\n}\n</code></pre>\n<p>Also imagine Steve's current state corresponds to this:</p>\n<pre class=\"lang-json prettyprint-override\"><code>{\n  &quot;id&quot;: 12345,\n  &quot;name&quot;: &quot;steve123&quot;,\n  &quot;emailData&quot;: [\n    &quot;steve@gmail.com&quot;,\n    &quot;steve@yahoo.com&quot;\n  ]\n}\n</code></pre>\n<p>Here's what my backend is expected to do:</p>\n<ol>\n<li>Keep <code>steve@gmail.com</code> (never try to insert it into <code>email_data</code> again).</li>\n<li>Remove <code>steve@yahoo.com</code>.</li>\n<li>Insert <code>steve@outlook.com</code> if it's not occupied by another user - else return an error response (I can write an advice that catches the DB's errors).</li>\n</ol>\n<p>In my specific (simple) scenario my <code>UserService</code> could:</p>\n<ol>\n<li>Load all of Steve's emails (a DB hit).</li>\n<li>Manually manipulate his <code>EmailData</code> list so that only <code>steve@gmail.com</code> is retained, <code>steve@outlook.com</code> is added (with a null <code>id</code> and non-null <code>user</code>).</li>\n<li>Then let my JPA provider automatically perform all the DML it needs.</li>\n</ol>\n<p>It's straightforward.</p>\n<p>However, imagine there are lots of fields like that one, for example <code>PhoneData</code>:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Entity\n@Getter\n@Setter\n@Table(name = &quot;phone_data&quot;)\npublic class PhoneData {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    @ManyToOne\n    @JoinColumn(name = &quot;user_id&quot;)\n    private User user;\n    private String phone;\n}\n</code></pre>\n<p>Object graph could be much more complex either. One value wrapper, like <code>EmailData</code>, could reference another one. Let's say it references <code>DomainData</code>.</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Entity\n@Getter\n@Setter\n@Table(name = &quot;domain_data&quot;)\npublic class DomainData {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    private String domain; // outlook.com, gmail.com, etc.\n}\n</code></pre>\n<p>The point is if I manually manage all those details, the code may quickly become verbose and hard to maintain.</p>\n<p><strong>How do I achieve my goals concisely and efficiently, keeping manually written code to a minimum?</strong></p>\n<p>Here's what wouldn't work. A first <code>PUT</code> would be fine, but if you tried to <code>PUT</code> the same JSON again, you'd get a unique constraint violation (since <code>email</code> in <code>email_data</code> must be <code>UNIQUE</code>).</p>\n<pre class=\"lang-java prettyprint-override\"><code>import com.example.pixel_user_api.data.dto.request.UserRequestDto;\nimport com.example.pixel_user_api.data.dto.response.UserResponseDto;\n\npublic interface UserService {\n\n    UserResponseDto update(UserRequestDto userRequestDto);\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import com.example.pixel_user_api.data.dto.request.UserRequestDto;\nimport com.example.pixel_user_api.data.dto.response.UserResponseDto;\nimport com.example.pixel_user_api.data.entity.User;\nimport com.example.pixel_user_api.mapper.UserMapper;\nimport com.example.pixel_user_api.repository.UserRepository;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Service\n@Transactional(readOnly = true)\n@RequiredArgsConstructor\npublic class UserServiceImpl implements UserService {\n\n    private final UserRepository repository;\n    private final UserMapper mapper;\n\n    @Override\n    @Transactional(readOnly = false)\n    public UserResponseDto update(UserRequestDto userRequestDto) {\n        User user = mapper.toUser(userRequestDto);\n        User updatedUser = repository.save(user);\n        return mapper.toResponseDto(updatedUser);\n    }\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import com.example.pixel_user_api.data.dto.request.UserRequestDto;\nimport com.example.pixel_user_api.data.dto.response.UserResponseDto;\nimport com.example.pixel_user_api.data.entity.User;\nimport org.mapstruct.Mapper;\n\n@Mapper(uses = EmailMapper.class, componentModel = &quot;spring&quot;)\npublic interface UserMapper {\n\n    User toUser(UserRequestDto userRequestDto);\n    UserResponseDto toResponseDto(User user);\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import com.example.pixel_user_api.data.entity.EmailData;\nimport org.mapstruct.Mapper;\nimport org.mapstruct.Mapping;\n\n@Mapper(componentModel = &quot;spring&quot;)\npublic interface EmailMapper {\n\n    default String toString(EmailData emailData) {\n        return emailData == null ? null : emailData.getEmail();\n    }\n\n    @Mapping(source = &quot;.&quot;, target = &quot;email&quot;)\n    EmailData toEmailData(String email);\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}