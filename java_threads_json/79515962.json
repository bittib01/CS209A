{
  "question": {
    "tags": [
      "java",
      "concurrency",
      "executorservice",
      "threadpoolexecutor"
    ],
    "owner": {
      "account_id": 6508,
      "reputation": 16597,
      "user_id": 10973,
      "user_type": "registered",
      "accept_rate": 94,
      "profile_image": "https://www.gravatar.com/avatar/6d8b216e6afd93a0bf480d3cb9fe9707?s=256&d=identicon&r=PG",
      "display_name": "Kevin Day",
      "link": "https://stackoverflow.com/users/10973/kevin-day"
    },
    "is_answered": true,
    "view_count": 154,
    "accepted_answer_id": 79516063,
    "answer_count": 1,
    "score": 3,
    "last_activity_date": 1742649082,
    "creation_date": 1742254050,
    "last_edit_date": 1742350178,
    "question_id": 79515962,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79515962/iterating-a-folder-structure-in-parallel-with-files-newdirectorystream-waiting",
    "title": "Iterating a folder structure in parallel with Files.newDirectoryStream, waiting for ExecutorService with recursive task submission to complete",
    "body": "<p>I am using Files.newDirectoryStream to iterate a directory structure recursively.  I want to use an ExecutorService to walk the directory in parallel (files are over a slow network connection and latency is causing our original single threaded search approach to be blocked most of the time).</p>\n<p>If the found Path is a directory, I submit a new task to an executor, recursively:</p>\n<pre><code>ExecutorService executorService = Executors.newFixedThreadPool(numThreads);\n\npublic void walkDirectory(Path directory) {\n    try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(directory)) {\n        for (Path entry : stream) {\n            \n            DosFileAttributes attribs =  getBasicFileAttributes(entry);\n            if (attribs.isDirectory()) {\n                executorService.submit(() -&gt; walkDirectory(entry));\n            } else {\n                process(entry, attribs);\n            }\n        }\n    }\n}\n</code></pre>\n<p>I now need to block until the iteration is complete.</p>\n<p>The naive approach to call executorService.shutdown() then awaitTermination() does not work because the iteration needs to add new jobs to the service as it continues to walk the tree.  Also note that the threads of the executor service are needing to submit jobs to that same executor service.</p>\n<p>CountDownLatch doesn't work because we have no idea how many tasks are going to be submitted in advance.</p>\n<p>Does anyone have suggestions on how to wait for the traversal to finish without preventing new jobs from being added to the executor service?</p>\n<p>Or is there a better/more elegant way to achieve this parallelization goal?</p>\n<p>PS - I'm already thinking that I should be looking at configuring the executor service with setting a bounded queue with a CallerRunsPolicy rejection policy so I don't wind up with billions of queued tasks... Any best practices would be greatly appreciated.</p>\n<hr />\n<p>Here's the latest strategy that we are testing:</p>\n<p>I create an AtomicInteger counter that keeps track of the # of directories being walked.  When that counter drops to zero, we know that the traversal is complete.</p>\n<p>We increment the counter before submitting a new directory to the executor service, and we decrement as the task finishes.</p>\n<p>This appears to be working as desired.</p>\n<p>I'm using raw synchronized constructs for the notifications - not sure if there is a more elegant way to handle that.</p>\n<p>If anyone has feedback, I'd appreciate hearing it.</p>\n<pre><code>public class FolderWalker {\n\n    private final ExecutorService executorService;\n    private final PathProcessor processor;\n    private final PathFilter fileFilter;\n    private final PathFilter directoryFilter;\n    private final ExceptionHandler exceptionHandler;\n    private final AtomicInteger activeThreads = new AtomicInteger(0);\n    private final Object lock = new Object();\n    \n    private boolean keepRunning = true;\n\n    public static interface PathProcessor{\n        public void process(Path p, DosFileAttributes attribs) throws Exception;\n    }\n    \n    public static interface ExceptionHandler{\n        public boolean handle(Path p, Exception e); // return true to continue traversal\n    }\n    \n    public static interface PathFilter{\n        public boolean accept(Path p, DosFileAttributes attribs);\n        \n        public static PathFilter ACCEPT_ALL = (p, attribs) -&gt; true;\n    }\n\n    public FolderWalker(int numThreads, PathFilter directoryFilter, PathFilter fileFilter, PathProcessor processor, ExceptionHandler exceptionHandler) {\n        this.executorService = createExecutorService(numThreads);\n        this.directoryFilter = directoryFilter;\n        this.fileFilter = fileFilter;\n        this.processor = processor;\n        this.exceptionHandler = exceptionHandler;\n    }\n    \n    private static ExecutorService createExecutorService(int numThreads) {\n        \n        // if threads are all in use, then the calling thread has to do the work - this will keep us from having excessive memory overhead of submitted jobs\n        return new ThreadPoolExecutor(numThreads, numThreads, 0, TimeUnit.MILLISECONDS, \n                  new SynchronousQueue&lt;&gt;(), \n                  new ThreadPoolExecutor.CallerRunsPolicy());\n    }\n\n    public void walkDirectory(Path directory) {\n        activeThreads.incrementAndGet();\n        executorService.submit(() -&gt; walkDirectoryInternal(directory));\n    }\n    \n    private void walkDirectoryInternal(Path directory) {\n        int activeThreadCount = activeThreads.get();\n        System.out.println(Thread.currentThread() + &quot; - Before: Looking in &quot; + directory + &quot; - Active folders: &quot; + activeThreadCount);\n        \n        try {\n            try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(directory)) {\n                for (Path entry : stream) {\n                    // TODO: How do we want to handle exceptions?\n                    //if (thrownException != null) return;\n                    if (Thread.interrupted()) return;\n                    if (!keepRunning) return;\n                    \n                    try {\n                        DosFileAttributes attribs =  getBasicFileAttributes(entry);\n                        if (attribs.isDirectory() &amp;&amp; directoryFilter.accept(entry, attribs)) {\n                            activeThreads.incrementAndGet();\n                            executorService.submit(() -&gt; walkDirectoryInternal(entry));\n                        } else if (fileFilter.accept(entry, attribs)) {\n                            processor.process(entry, attribs);\n                        }\n                    } catch (Exception e) {\n                        if (!exceptionHandler.handle(entry, e))\n                            keepRunning = false;\n                    }\n                }\n            } catch (Exception e) {\n                if (!exceptionHandler.handle(directory, e))\n                    keepRunning = false;\n            }\n        } finally {\n            activeThreadCount = activeThreads.decrementAndGet();\n            System.out.println(Thread.currentThread() + &quot; - After: Looking in &quot; + directory + &quot; - Active folders: &quot; + activeThreadCount);\n            if (activeThreadCount == 0) {\n                synchronized(lock) {\n                    lock.notifyAll();\n                }\n            }\n        }           \n            \n    }\n\n    private DosFileAttributes getBasicFileAttributes(Path p) throws IOException {\n        return Files.getFileAttributeView(p, DosFileAttributeView.class).readAttributes();\n    }\n    \n    public void await() throws Exception {\n        synchronized(lock) {\n            while (activeThreads.get() != 0)\n                lock.wait();\n        }\n        \n        executorService.shutdown();\n        System.out.println(&quot;Thread pool is shut down&quot;);\n        try {\n            if (!executorService.awaitTermination(60, TimeUnit.SECONDS)) {\n                executorService.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            executorService.shutdownNow();\n        }\n        System.out.println(&quot;Thread pool is terminated&quot;);\n        \n    }\n\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}