{
  "question": {
    "tags": [
      "java",
      "javafx",
      "javafx-8"
    ],
    "owner": {
      "account_id": 10187542,
      "reputation": 2735,
      "user_id": 20692967,
      "user_type": "registered",
      "profile_image": "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name": "Sergey Zolotarev",
      "link": "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "is_answered": true,
    "view_count": 172,
    "closed_date": 1765106774,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1765185377,
    "creation_date": 1764937122,
    "last_edit_date": 1765185377,
    "question_id": 79838872,
    "link": "https://stackoverflow.com/questions/79838872/nested-javafx-services",
    "closed_reason": "Needs more focus",
    "title": "Nested JavaFX Services",
    "body": "<p>How do I nest <code>Service</code>s / <code>Task</code>s in JavaFX — or achieve the same effect by other means?</p>\n<p>I created a simplistic form for &quot;saving&quot; DB connection settings. Here's what it should be.</p>\n<ol>\n<li>It has two fields: URL and password. Valid credentials are &quot;test&quot; and &quot;test&quot;.</li>\n<li>It has two buttons: <code>Test connection</code> and <code>Save</code>.</li>\n<li><code>Test connection</code> attempts to connect using provided credentials (that is, imagine it does). If they are not, then the fields get outlined in red.</li>\n<li><code>Save</code> first performs step 3 (<em>including the handling</em>) and, if successful, saves the settings. Notice how the testing task is <em>nested</em> in the saving task (while still being an independent task on its own).</li>\n</ol>\n<p>Important: testing connection can be done clicking either button, but saving must be performed only on clicking <code>Save</code>.</p>\n<h1>Approach #1</h1>\n<p>I can declare two separate <code>Service</code>s. It means the saving listener is not activated on testing.</p>\n<p>However, the connection failure handling (red outlining) must either be duplicated in the save listener or be missing (in my MRE it's missing). Both scenarios are undesirable. In the real application, the testing functionality belongs to a child component's scope (imagine, for example, the testing button would be inside some container with a tiny spinner to boot that reflected the test status). It would be a bit weird if my form would be nosing around in the child component's scope repeating the same failure handling.</p>\n<pre class=\"lang-java prettyprint-override\"><code>import javafx.application.Application;\nimport javafx.concurrent.Service;\nimport javafx.concurrent.WorkerStateEvent;\nimport javafx.css.PseudoClass;\nimport javafx.geometry.Insets;\nimport javafx.geometry.Pos;\nimport javafx.scene.Parent;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Button;\nimport javafx.scene.control.Label;\nimport javafx.scene.control.TextField;\nimport javafx.scene.layout.Background;\nimport javafx.scene.layout.BackgroundFill;\nimport javafx.scene.layout.CornerRadii;\nimport javafx.scene.layout.GridPane;\nimport javafx.scene.layout.HBox;\nimport javafx.scene.paint.Color;\nimport javafx.scene.text.Font;\nimport javafx.stage.Stage;\n\nimport java.net.URL;\nimport java.time.Duration;\nimport java.util.Optional;\n\n\npublic class FXServiceDemo extends Application {\n\n    static TextField urlField;\n    static TextField passwordField;\n\n    @Override\n    public void start(Stage primaryStage) {\n        primaryStage.setScene(createScene());\n        primaryStage.setTitle(&quot;DB Settings&quot;);\n        primaryStage.show();\n    }\n\n    private Scene createScene() {\n        Parent root = createRoot();\n        Scene scene = new Scene(root);\n        findStylesheet().ifPresent(s -&gt; scene.getStylesheets().add(s));\n        return scene;\n    }\n\n    private static Optional&lt;String&gt; findStylesheet() {\n        URL nullableStylesheet = FXServiceDemo.class.getResource(&quot;/styles/styles.css&quot;);\n        Optional&lt;URL&gt; stylesheetOptional = Optional.ofNullable(nullableStylesheet);\n        return stylesheetOptional.map(URL::toExternalForm);\n    }\n\n    private Parent createRoot() {\n        GridPane root = new GridPane();\n        root.setAlignment(Pos.CENTER);\n        root.setPadding(new Insets(5));\n        root.hgapProperty().set(5);\n        root.vgapProperty().set(5);\n        Label header = new Label(&quot;DB settings&quot;);\n        header.setFont(Font.font(20));\n        root.add(header, 0, 0, 2, 1);\n        root.addRow(1, new Label(&quot;URL&quot;), urlField = new TextField());\n        root.addRow(2, new Label(&quot;Password&quot;), passwordField = new TextField());\n        root.add(createButtonRow(), 1, 3, 2, 1);\n        return root;\n    }\n\n    private HBox createButtonRow() {\n        HBox row = new HBox();\n        row.setSpacing(5);\n        row.setAlignment(Pos.CENTER_RIGHT);\n        row.getChildren().add(createTestConnectionButton());\n        row.getChildren().add(createSaveButton());\n        return row;\n    }\n\n    Service&lt;Void&gt; testConnectionService = Services.from(this::testConnection);\n    private Button createTestConnectionButton() {\n        Button button = new Button();\n        button.textProperty().set(&quot;Test Connection&quot;);\n        button.setOnAction(e -&gt; testConnectionService.restart());\n        button.disableProperty().bind(testConnectionService.runningProperty());\n        testConnectionService.addEventHandler(WorkerStateEvent.WORKER_STATE_SUCCEEDED, FXServiceDemo::onConnectionSuccess);\n        testConnectionService.addEventHandler(WorkerStateEvent.WORKER_STATE_FAILED, FXServiceDemo::onConnectionFailure);\n        return button;\n    }\n\n    private static void onConnectionSuccess(WorkerStateEvent e) {\n        setValid(true);\n        System.out.println(&quot;Connection was not established.&quot;);\n    }\n\n    private static void onConnectionFailure(WorkerStateEvent e) {\n        setValid(false);\n        System.out.println(&quot;Connection was not established.&quot;);\n    }\n\n    private static void setValid(boolean valid) {\n        PseudoClass invalid = PseudoClass.getPseudoClass(&quot;invalid&quot;);\n        urlField.pseudoClassStateChanged(invalid, !valid);\n        passwordField.pseudoClassStateChanged(invalid, !valid);\n    }\n\n    Service&lt;Void&gt; saveSettingsService = Services.from(this::saveSettings);\n    private Button createSaveButton() {\n        Button button = new Button();\n        button.textFillProperty().set(Color.WHITE);\n        button.backgroundProperty().set(new Background(new BackgroundFill(Color.GREEN, new CornerRadii(3), null)));\n        button.textProperty().set(&quot;Save&quot;);\n        button.setOnAction(e -&gt; saveSettingsService.restart());\n        button.disableProperty().bind(testConnectionService.runningProperty().or(saveSettingsService.runningProperty()));\n        saveSettingsService.addEventHandler(WorkerStateEvent.WORKER_STATE_SUCCEEDED, FXServiceDemo::onSaveSuccess);\n        saveSettingsService.addEventHandler(WorkerStateEvent.WORKER_STATE_FAILED, FXServiceDemo::onSaveFailure);\n        return button;\n    }\n\n    private static void onSaveSuccess(WorkerStateEvent e) {\n        System.out.println(&quot;Connection settings successfully saved.&quot;);\n    }\n\n    private static void onSaveFailure(WorkerStateEvent e) {\n        System.out.println(&quot;Connection settings could not saved.&quot;);\n    }\n\n    private void testConnection() {\n        System.out.println(&quot;Testing connection...&quot;);\n        sleep(Duration.ofSeconds(1));\n        if (credentialsValid()) return;\n        throw new IllegalArgumentException(&quot;Invalid Credentials&quot;);\n    }\n\n    private boolean credentialsValid() {\n        String correctUrl = &quot;test&quot;;\n        String correctPass = &quot;test&quot;;\n        return correctUrl.equals(urlField.textProperty().get()) &amp;&amp;\n                correctPass.equals(passwordField.textProperty().get());\n    }\n\n    private void saveSettings() {\n        testConnection();\n        System.out.println(&quot;Saving connection settings...&quot;);\n        sleep(Duration.ofSeconds(1));\n    }\n\n    private static void sleep(Duration duration) {\n        try {\n            Thread.sleep(duration.toMillis());\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n</code></pre>\n<pre class=\"lang-none prettyprint-override\"><code>import javafx.concurrent.Service;\nimport javafx.concurrent.Task;\n\npublic class Services {\n\n    public static Service&lt;Void&gt; from(Runnable task) {\n        return new Service&lt;Void&gt;() {\n            @Override\n            protected Task&lt;Void&gt; createTask() {\n                return new Task&lt;Void&gt;() {\n                    @Override\n                    protected Void call() {\n                        task.run();\n                        return null;\n                    }\n                };\n            }\n        };\n    }\n}\n</code></pre>\n<pre class=\"lang-css prettyprint-override\"><code>/* resources/styles/styles.css */\n\n.text-field:invalid {\n    -fx-border-color : salmon;\n}\n</code></pre>\n<p><a href=\"https://i.sstatic.net/F0BDQRWV.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/F0BDQRWV.png\" alt=\"enter image description here\" /></a></p>\n<h1>Approach #2</h1>\n<p>I can declare one <code>Service</code>. Then failure handling will be executed no matter which button triggers it.</p>\n<p>However, testing connection will then notify the same saving listener (since listeners would also be shared). In effect, it would mean the testing button would be saving as well — unacceptable.</p>\n<h1>Approach #3</h1>\n<p><strong>(theoretical)</strong></p>\n<p>If I could:</p>\n<ol>\n<li>Declare two separate services.</li>\n<li>But have the saving service &quot;contain&quot; the lifecycle of the testing service.</li>\n</ol>\n<p>I could meet all of my requirements.</p>\n<p>However, it seems, I can't have nested <code>Service</code>s in JavaFX (or nested <code>Task</code>s, for that matter).</p>\n<h1>Approach #4</h1>\n<p><strong>(theoretical)</strong></p>\n<p>I could call some <code>restartAndThen(resultConsumer)</code> method that would register no additional listeners but execute a one-off callback on that particular invocation – the invocation performed by the saving button's action listener.</p>\n<p>Again, it's imaginary. No such API exists.</p>\n<p>How do I achieve my goals?</p>\n<p>Java 8.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}