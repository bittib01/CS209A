{
  "question": {
    "tags": [
      "java",
      "search",
      "data-structures",
      "breadth-first-search",
      "circular-reference"
    ],
    "owner": {
      "account_id": 32913344,
      "reputation": 11,
      "user_id": 25562042,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/1959eb45f6c06eb6189d9db6ea435536?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "saanyay",
      "link": "https://stackoverflow.com/users/25562042/saanyay"
    },
    "is_answered": false,
    "view_count": 63,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1726531470,
    "creation_date": 1718319502,
    "last_edit_date": 1718319581,
    "question_id": 78620427,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78620427/issue-with-circular-reference-infinite-loop-when-doing-bfs-on-a-multidimensional",
    "title": "Issue with circular reference infinite loop when doing BFS on a multidimensional matrix",
    "body": "<p>When doing a Breadth First Search on a Multidimensional Matrix where some cells are blocked, I am getting a circular reference and going into an infinite loop.</p>\n<p>How would I backtrack my BFS search to return a path from Node B to node S?</p>\n<pre><code>\npublic class Main {\n\n    public static void main(String[] args) {\n\n        char[][] grid = {\n            {'x', 'x', 'x', 'x', 'o'},\n            {'x', 'o', 'o', 'o', 'B'},\n            {'s', 'o', 'x', 'o', 'o'},\n            {'x', 'x', 'o', 'o', 'o'},\n            {'x', 'o', 'x', 'x', 'o'}\n        };\n\n        for (int i = 0; i &lt; grid.length; i++){\n            for (int j = 0; j &lt; grid[i].length; j++) {\n                System.out.print(grid[i][j] + &quot; &quot;);\n            }\n            System.out.println();\n        }\n    }\n}\n\n\npublic class BFS{\n   public List&lt;Cell&gt; breadthFirstSearch(Cell bot, Cell button, Fire fire){\n        int row = ship.getSize(); //I've hardcoded an example matrix\n        int col = ship.getSize();\n\n        Queue &lt;Cell&gt; queue = new LinkedList&lt;&gt;();\n        Queue &lt;Cell&gt; visited = new LinkedList&lt;&gt;();\n        Cell[][] parent = new Cell[ship.getSize()][ship.getSize()];\n        //Map &lt;Cell, Cell&gt; parent = new HashMap&lt;&gt;(); // Stores child, parent\n        boolean matchFound = false;\n\n        //Starting Node\n        queue.add(bot);\n        visited.add(bot);\n        parent[bot.getX()][bot.getY()] = null;\n        Cell previous = null;\n        Cell current = null;\n\n        while(!queue.isEmpty()){        \n\n            // Assign current node &amp; Moves to next cell in queue\n            previous = current;\n            current = queue.poll();\n            System.out.println(&quot;LOOP Current : &quot; + current.toString());\n\n            // Check if bot = button\n            if(current.equals(button)){\n                parent[current.getX()][current.getY()] = previous;\n                List&lt;Cell&gt; path = new ArrayList&lt;&gt;();\n                Cell node = new Cell(current.getX(), current.getY());\n                Cell prevNode = null;\n                //path.add(node);\n                while(node != null){\n                    path.add(node);\n                    node = parent[node.getX()][node.getY()];\n                    System.out.print(&quot;CurrentNODE: &quot; + node);           \n                }\n                Collections.reverse(path);\n                return path;\n            }\n            \n            //Add children of bot to queue\n            else{\n                for(Cell neighbor : getBotNeighbors(current)){\n                    //System.out.println(neighbor);\n                    if((!(ship.isBurning(neighbor.getX(),neighbor.getY()))) &amp;&amp; \n                    (neighbor.isOpenCell(ship))){\n                        if (!visited.contains(neighbor)) {\n                            queue.add(neighbor);\n                            visited.add(neighbor);\n                        }\n                        parent[current.getX()][current.getY()]= neighbor;\n                        //System.out.println(&quot;parent (key): &quot; + current.toString() + &quot;; (value): &quot; + parent.get(current));\n                    }\n                }\n            }\n            System.out.println();\n        }\n        return new ArrayList&lt;&gt;();\n    }\n}\n\n</code></pre>\n<p>I want to go from nodeB to nodeS and for some reason even though it is finding the correct path, it is stuck in an infinite loop when backtracking.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}