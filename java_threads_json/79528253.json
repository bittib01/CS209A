{
  "question": {
    "tags": [
      "java",
      "lambda",
      "overloading",
      "type-inference"
    ],
    "owner": {
      "account_id": 1591474,
      "reputation": 323,
      "user_id": 1474709,
      "user_type": "registered",
      "accept_rate": 29,
      "profile_image": "https://www.gravatar.com/avatar/aed8242177c8dfad939f21d6f9205699?s=256&d=identicon&r=PG",
      "display_name": "Skifozoa",
      "link": "https://stackoverflow.com/users/1474709/skifozoa"
    },
    "is_answered": true,
    "view_count": 87,
    "accepted_answer_id": 79533077,
    "answer_count": 1,
    "score": 2,
    "last_activity_date": 1742891772,
    "creation_date": 1742685582,
    "question_id": 79528253,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79528253/lambda-compatible-with-two-functional-interfaces-does-not-give-ambiguous-method",
    "title": "Lambda compatible with two functional interfaces does not give ambiguous method call error on overloaded method, why not?",
    "body": "<p>My overload method is overloaded with 4 different functional interfaces. I have 3 examples in which I call this overloaded method with a lambda that is compatible with 2 of those functional interfaces. In the first example the compiler understandably tells me my method call is ambiguous.</p>\n<p>In scenario 2 and 3 however the compiler does not complain... why not?</p>\n<pre><code>public class AmbiguityTest {\n\n    private static void overload(Consumer&lt;String&gt; consumer) {\n    }\n\n    private static void overload(Function&lt;String, String&gt; function) {\n    }\n\n    private static void overload(Runnable runnable) {\n    }\n\n    private static void overload(Supplier&lt;String&gt; supplier) {\n    }\n\n    public static void testLambda1() {\n        //This lambda is compatible with 2 functional interfaces: Consumer&lt;String&gt; and Function&lt;String, String&gt;\n        //Calling the overload method gives an &quot;ambiguous method call&quot; error. Makes sense.\n        Consumer&lt;String&gt; consumer = ignored -&gt; Instant.now().toString();\n        Function&lt;String, String&gt; function = ignored -&gt; Instant.now().toString();\n        overload(ignored -&gt; Instant.now().toString());\n    }\n\n    public static void testLambda2() {\n        //This lambda is also compatible with 2 functional interfaces: Consumer&lt;String&gt; and Function&lt;String, String&gt;\n        //Yet here calling the overload method does not give a compile time error. ???WHY NOT???\n        Consumer&lt;String&gt; consumer = (String ignored) -&gt; Instant.now().toString();\n        Function&lt;String, String&gt; function = (String ignored) -&gt; Instant.now().toString();\n        overload((String ignored) -&gt; Instant.now().toString());\n    }\n\n    public static void testLambda3() {\n        //This lambda is compatible with 2 functional interfaces: Runnable and Supplier&lt;String&gt;\n        //Again there is no compile time error although 2 overloaded methods match. ???WHY NO AMBIGUITY???\n        Runnable runnable = () -&gt; Instant.now().toString();\n        Supplier&lt;String&gt; supplier = () -&gt; Instant.now().toString();\n        overload(() -&gt; Instant.now().toString());\n    }\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}