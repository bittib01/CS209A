{
  "question": {
    "tags": [
      "java",
      "spring",
      "spring-security"
    ],
    "owner": {
      "account_id": 44405791,
      "reputation": 23,
      "user_id": 31735937,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/68d3f080721d807c21c832d5aa94a327?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "jey doe",
      "link": "https://stackoverflow.com/users/31735937/jey-doe"
    },
    "is_answered": true,
    "view_count": 69,
    "closed_date": 1766244235,
    "accepted_answer_id": 79849659,
    "answer_count": 1,
    "score": 3,
    "last_activity_date": 1765991355,
    "creation_date": 1765989860,
    "question_id": 79849653,
    "link": "https://stackoverflow.com/questions/79849653/spring-security-http-only-cookies-authorization-problem",
    "closed_reason": "Duplicate",
    "title": "Spring security http only cookies authorization problem",
    "body": "<p>i have the following security config but it still triggers filter on a non security matched paths.<br />\nWhat's the problem here? Am i doing authentication correctly? I've tried reading docs but the writing is too dense and focuses on inner workings instead of everyday usage.</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n    @Autowired\n    private HttpCookieAuth httpCookieAuth;\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n                .securityMatcher(&quot;/api/auth/**&quot;)\n                .sessionManagement(session -&gt; session\n                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                )\n                .anonymous(AbstractHttpConfigurer::disable)\n                .csrf(AbstractHttpConfigurer::disable)\n\n                .httpBasic(AbstractHttpConfigurer::disable)\n                .formLogin(AbstractHttpConfigurer::disable)\n\n                .logout(l -&gt; l.addLogoutHandler(new ClearCookiesHandler()))\n\n                .authorizeHttpRequests(auth -&gt;\n                        auth.anyRequest().authenticated()\n                )\n                .addFilterBefore(httpCookieAuth, ExceptionTranslationFilter.class);\n        return http.build();\n    }\n\n}\n</code></pre>\n<pre><code>@Component\npublic class HttpCookieAuth extends OncePerRequestFilter {\n\n    @Autowired\n    private JwtCookieService cookieService;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n            throws ServletException, IOException {\n        var tokenCookie = Arrays.stream(request.getCookies()).filter(c -&gt; c.getName().equals(&quot;accessToken&quot;)).findFirst();\n        if(tokenCookie.isPresent()) {\n            var context = SecurityContextHolder.getContext();\n            var auth = context.getAuthentication();\n            if (auth == null || !auth.isAuthenticated()) {\n                var cookie = tokenCookie.get();\n                var claims = cookieService.parseCookie(cookie.getValue());\n                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(\n                        claims.get(&quot;sub&quot;), null, null);\n                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n                context.setAuthentication(authentication);\n            }\n        }\n\n\n\n        filterChain.doFilter(request, response);\n    }\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}