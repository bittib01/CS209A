{
  "question": {
    "tags": [
      "java",
      "spring",
      "hibernate",
      "mockito",
      "junit4"
    ],
    "owner": {
      "account_id": 23318699,
      "reputation": 223,
      "user_id": 17396960,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/429f76e27c80bdac7e45cbc2e42c6e7c?s=256&d=identicon&r=PG",
      "display_name": "SlipperyBarrel",
      "link": "https://stackoverflow.com/users/17396960/slipperybarrel"
    },
    "is_answered": false,
    "view_count": 95,
    "answer_count": 0,
    "score": 1,
    "last_activity_date": 1734891812,
    "creation_date": 1734874625,
    "last_edit_date": 1734891812,
    "question_id": 79301083,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79301083/cant-write-a-good-test-for-service-layer-in-java-application",
    "title": "Can&#39;t write a good test for service layer in java application",
    "body": "<p>I've tried to make some tests for <code>Service</code> layer in my java project. The test supposed to simply mock adding a new patient to database. After constantly failing, I simply gave up, and came here for seek help.</p>\n<p>My current code for the test class is following:</p>\n<pre><code>@ExtendWith(MockitoExtension.class)\npublic class PatientServiceTest {\n\n    @Mock\n    private PatientDao patientDao;\n\n    @InjectMocks\n    private PatientServiceImpl patientService;\n\n    @BeforeEach\n    public void setup() {\n        MockitoAnnotations.initMocks(this);\n    }\n\n    @Test\n    public void testSave() {\n        PatientEntity patient = new PatientEntity();\n        PatientTO patientTO = new PatientTO();\n        patientTO.setId(1L);\n\n        when(PatientMapper.mapToEntity(patientTO)).thenReturn(patient);\n        when(patientDao.save(patient)).thenReturn(patient);\n\n        PatientTO result = patientService.save(patientTO);\n\n        assertNotNull(result);\n        verify(patientDao, times(1)).save(patient);\n//        verify(PatientMapper.mapToEntity(patientTO), times(1));\n    }\n}\n</code></pre>\n<p><strong>Mapper</strong></p>\n<pre><code>public class PatientMapper {\n    public static PatientTO mapToTO(final PatientEntity patientEntity) {\n        if (patientEntity == null) return null;\n\n        final PatientTO patientTO = new PatientTO();\n        patientTO.setId(patientTO.getId());\n        patientTO.setFirstName(patientEntity.getFirstName());\n        patientTO.setLastName(patientEntity.getLastName());\n        patientTO.setTelephoneNumber(patientEntity.getTelephoneNumber());\n        patientTO.setEmail(patientEntity.getEmail());\n        patientTO.setPatientNumber(patientEntity.getPatientNumber());\n        patientTO.setDateOfBirth(patientEntity.getDateOfBirth());\n        patientTO.setDoesHaveChronicDiseases(patientEntity.getDoesHaveChronicDisease());\n\n        return patientTO;\n\n    }\n\n    public static PatientEntity mapToEntity(final PatientTO patientTO) {\n        if (patientTO == null) return null;\n\n        final PatientEntity patientEntity = new PatientEntity();\n        patientEntity.setId(patientTO.getId());\n        patientEntity.setFirstName(patientTO.getFirstName());\n        patientEntity.setLastName(patientTO.getLastName());\n        patientEntity.setTelephoneNumber(patientTO.getTelephoneNumber());\n        patientEntity.setEmail(patientTO.getEmail());\n        patientEntity.setPatientNumber(patientTO.getPatientNumber());\n        patientEntity.setDateOfBirth(patientTO.getDateOfBirth());\n        patientEntity.setDoesHaveChronicDisease(patientTO.getDoesHaveChronicDiseases());\n\n        return patientEntity;\n    }\n}\n</code></pre>\n<p><strong>DAO</strong></p>\n<pre><code> public interface PatientDao extends Dao&lt;PatientEntity, Long&gt;  { }\n</code></pre>\n<p><strong>DAO impl</strong></p>\n<pre><code>@Repository\npublic class PatientDaoImpl extends AbstractDao&lt;PatientEntity, Long&gt; implements PatientDao{ }\n</code></pre>\n<p><strong>Entity</strong></p>\n<pre><code>@Entity\n@Table(name = &quot;PATIENT&quot;)\npublic class PatientEntity {\n\n@Id\n@GeneratedValue(strategy = GenerationType.IDENTITY)\nprivate Long id;\n\n@Column(nullable = false)\nprivate String firstName;\n\n@Column(nullable = false)\nprivate String lastName;\n\n@Column(nullable = false)\nprivate String telephoneNumber;\n\nprivate String email;\n\n@Column(nullable = false)\nprivate String patientNumber;\n\n@Column(nullable = false)\nprivate LocalDate dateOfBirth;\n\n@Column(nullable = false)\nprivate Boolean doesHaveChronicDisease;\n\npublic Long getId() {\n    return id;\n}\n\npublic void setId(Long id) {\n    this.id = id;\n}\n\npublic String getFirstName() {\n    return firstName;\n}\n\npublic void setFirstName(String firstName) {\n    this.firstName = firstName;\n}\n\npublic String getLastName() {\n    return lastName;\n}\n\npublic void setLastName(String lastName) {\n    this.lastName = lastName;\n}\n\npublic String getTelephoneNumber() {\n    return telephoneNumber;\n}\n\npublic void setTelephoneNumber(String telephoneNumber) {\n    this.telephoneNumber = telephoneNumber;\n}\n\npublic String getEmail() {\n    return email;\n}\n\npublic void setEmail(String email) {\n    this.email = email;\n}\n\npublic String getPatientNumber() {\n    return patientNumber;\n}\n\npublic void setPatientNumber(String patientNumber) {\n    this.patientNumber = patientNumber;\n}\n\npublic LocalDate getDateOfBirth() {\n    return dateOfBirth;\n}\n\npublic void setDateOfBirth(LocalDate dateOfBirth) {\n    this.dateOfBirth = dateOfBirth;\n}\n\npublic Boolean getDoesHaveChronicDisease() {\n    return doesHaveChronicDisease;\n}\n\npublic void setDoesHaveChronicDisease(Boolean doesHaveChronicDisease) {\n    this.doesHaveChronicDisease = doesHaveChronicDisease;\n}\n</code></pre>\n<p>}</p>\n<p><strong>Service</strong></p>\n<pre><code>public interface PatientService {\nPatientTO findById(final Long ID);\nPatientTO save(final PatientTO patientTO);\n}\n</code></pre>\n<p><strong>Service impl</strong></p>\n<pre><code>@Service\n@Transactional\npublic class PatientServiceImpl implements PatientService {\n\nprivate final PatientDao patientDao;\n\n@Autowired\npublic  PatientServiceImpl(PatientDao patientDao){\n    this.patientDao = patientDao;\n}\n\n@Override\npublic PatientTO findById(Long ID) {\n    final PatientEntity patientEntity = patientDao.findOne(ID);\n    return PatientMapper.mapToTO(patientEntity);\n}\n\n@Override\npublic PatientTO save(PatientTO patientTO) {\n    final PatientEntity patientEntity = PatientMapper.mapToEntity(patientTO);\n    patientDao.save(patientEntity);\n    return PatientMapper.mapToTO(patientEntity);\n}\n}\n</code></pre>\n<p>I;ve already covered a lot of errors, but the most occuring one is:</p>\n<pre><code>org.mockito.exceptions.misusing.MissingMethodInvocationException: \nwhen() requires an argument which has to be 'a method call on a mock'.\nFor example:\nwhen(mock.getArticles()).thenReturn(articles);\n\nAlso, this error might show up because:\n1. you stub either of: final/private/equals()/hashCode() methods.\n   Those methods *cannot* be stubbed/verified.\n   Mocking methods declared on non-public parent classes is not supported.\n2. inside when() you don't call method on mock but on some other object.\n</code></pre>\n<p>which is pointing at:</p>\n<pre><code>when(patientMapper.mapToEntity(patientTO)).thenReturn(patient);\n</code></pre>\n<p>But I've already used it mocked, or as a concrete object. How I may improve? How I can write a test, where I can check if after deleting patient, all of his appointments were deleted too, with using cascades?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}