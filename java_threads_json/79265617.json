{
  "question": {
    "tags": [
      "java",
      "sql",
      "spring",
      "spring-boot",
      "jms"
    ],
    "owner": {
      "account_id": 18586978,
      "reputation": 3850,
      "user_id": 15000097,
      "user_type": "registered",
      "profile_image": "https://i.sstatic.net/yFl4M.jpg?s=256",
      "display_name": "Georgii Lvov",
      "link": "https://stackoverflow.com/users/15000097/georgii-lvov"
    },
    "is_answered": true,
    "view_count": 139,
    "accepted_answer_id": 79265916,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1736239711,
    "creation_date": 1733759299,
    "last_edit_date": 1736239711,
    "question_id": 79265617,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79265617/how-to-immediately-stop-execution-of-spring-jmslistener",
    "title": "How to immediately stop execution of Spring JmsListener?",
    "body": "<p>In my Java Spring Boot 3 application I have a simple <code>JmsListener</code> for Oracle AQ:</p>\n<pre class=\"lang-java prettyprint-override\"><code>import com.example.webfluxexample.model.MessageInfo;\nimport jakarta.jms.Message;\nimport jakarta.jms.ObjectMessage;\nimport lombok.extern.log4j.Log4j2;\nimport org.springframework.jms.annotation.JmsListener;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.reactive.function.client.WebClient;\n\n@Component\n@Log4j2\npublic class SomeJmsListener {\n\n    @JmsListener(\n            id = &quot;id_listener_1&quot;,\n            destination = &quot;wmstk_queue&quot;,\n            containerFactory = &quot;jmsListenerContainerFactory&quot;\n    )\n    public void listenMessage(Message message) throws Exception {\n        if (message instanceof ObjectMessage objectMessage) {\n            MessageInfo messageInfo = (MessageInfo) objectMessage.getObject();\n            \n            webClient.create()\n                    .post()\n                    .uri(&quot;some_url&quot;)\n                    .bodyValue(messageInfo)\n                    .retrieve()\n                    .toEntity(String.class)\n                    .block();\n        }\n    }\n}\n</code></pre>\n<p>This listener can be stopped at some point of the application execution using the <code>JmsListenerEndpointRegistry</code>, as follows:</p>\n<pre class=\"lang-java prettyprint-override\"><code>import lombok.RequiredArgsConstructor;\nimport lombok.extern.log4j.Log4j2;\nimport org.springframework.jms.config.JmsListenerEndpointRegistry;\nimport org.springframework.stereotype.Service;\n\n@Service\n@Log4j2\n@RequiredArgsConstructor\npublic class JmsListenerControlService {\n\n    private final JmsListenerEndpointRegistry registry;\n    \n    \n    public void stop(String listenerId) {\n        var container = registry.getListenerContainer(listenerId);\n        \n        if (container.isRunning()) {\n            container.stop();\n        }\n    }\n}\n</code></pre>\n<p>The goal to achieve is that if listener container is stopped, then execution of <code>listenMessage</code> must be <strong>immediately</strong> stopped (if it is running) and JMS <code>Session</code> must be rolled back.</p>\n<p>The only solution I found now is to observe container and manually interrupt the thread of <code>listenMessage</code>:</p>\n<pre class=\"lang-java prettyprint-override\"><code>import com.example.webfluxexample.model.MessageInfo;\nimport jakarta.jms.Message;\nimport jakarta.jms.ObjectMessage;\nimport lombok.extern.log4j.Log4j2;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jms.annotation.JmsListener;\nimport org.springframework.jms.config.JmsListenerEndpointRegistry;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.reactive.function.client.WebClient;\n\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n@Component\n@Log4j2\npublic class SomeJmsListener {\n\n    @Autowired\n    private JmsListenerEndpointRegistry registry;\n\n    private ScheduledExecutorService scheduledExecutorService;\n\n    @JmsListener(\n            id = &quot;id_listener_1&quot;,\n            destination = &quot;wmstk_queue&quot;,\n            containerFactory = &quot;jmsListenerContainerFactory&quot;\n    )\n    public void listenMessage(Message message) throws Exception {\n        observeContainer(Thread.currentThread());\n\n        if (message instanceof ObjectMessage objectMessage) {\n            MessageInfo messageInfo = (MessageInfo) objectMessage.getObject();\n\n            webClient.create()\n                    .post()\n                    .uri(&quot;some_url&quot;)\n                    .bodyValue(messageInfo)\n                    .retrieve()\n                    .toEntity(String.class)\n                    .block();\n        }\n        stopObservation();\n    }\n\n    /**\n     * Scheduled job observes jms listener and if it is not running - interrupts its thread\n     */\n    private void observeContainer (Thread thread){\n        String listenerId = &quot;id_listener_1&quot;;\n        var listenerContainer = registry.getListenerContainer(listenerId);\n\n        log.debug(&quot;Start observation for listener container with id: {}&quot;, listenerId);\n\n        scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();\n\n        scheduledExecutorService.scheduleAtFixedRate(\n                () -&gt; {\n                    if (!listenerContainer.isRunning()) {\n                        stopObservation();\n                        thread.interrupt(); // interrupt the thread to prevent further execution of listenMessage\n                    } else {\n                        log.debug(&quot;Listener active, id: {}&quot;, listenerId);\n                    }\n                },\n                10, // 10ms initial delay\n                100, // execute each 100ms\n                TimeUnit.MILLISECONDS\n        );\n    }\n\n    private void stopObservation () {\n        log.info(&quot;Stop observation for listener container with id: {}&quot;, &quot;wmstk-listener-endpoint-1&quot;);\n        if (scheduledExecutorService != null) {\n            scheduledExecutorService.close();\n            scheduledExecutorService = null;\n        }\n    }\n}\n</code></pre>\n<p>After interruption the message remains in the queue and processing is interrupted as expected, but at the very end of logs I see this exception and I am not sure if this is something to worry about or not:</p>\n<blockquote>\n<p>org.springframework.jms.listener.adapter.ListenerExecutionFailedException:\nListener method ' listenMessage throws java.lang.Exception'</p>\n</blockquote>\n<blockquote>\n<p>ERROR [er-endpoint-1-1] o.s.j.l.DefaultMessageListenerContainer  :\nApplication exception overridden by rollback error</p>\n</blockquote>\n<blockquote>\n<p>Caused by: java.io.InterruptedIOException:\nSocket read interrupted:\noracle.jakarta.jms.AQjmsException: IO Error: Socket read interrupted</p>\n</blockquote>\n<p>So, this exception occurs by rollback, and namely in:</p>\n<pre class=\"lang-java prettyprint-override\"><code>package oracle.jakarta.jms;\n\nclass AQjmsSession {\n\n     synchronized void forceRollback() throws JMSException {\n        Connection db_conn = null;\n        db_conn = this.getDBConnection();\n\n        try {\n            db_conn.rollback(); // here exception occurs\n            this.setConsistency(true);\n        } catch (SQLException var3) {\n            throw new AQjmsException(var3);\n        }\n\n        this.restartConsumers();\n    }\n}\n\n</code></pre>\n<p>Is it worth worrying about this exception if the message remains in the queue and is available for reading, although exception tells that exception occurred by rollback?\nAnd maybe there is some other way to smoothly make a rollback and interrupt the execution of the method?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}