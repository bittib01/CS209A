{
  "question": {
    "tags": [
      "java"
    ],
    "owner": {
      "account_id": 40396881,
      "reputation": 13,
      "user_id": 29759326,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/c04d5291c8dab81e6435e1e7a1e6c515?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "user29759326",
      "link": "https://stackoverflow.com/users/29759326/user29759326"
    },
    "is_answered": true,
    "view_count": 100,
    "accepted_answer_id": 79460774,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1740353619,
    "creation_date": 1740289923,
    "last_edit_date": 1740291955,
    "question_id": 79460750,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79460750/how-do-i-return-the-last-value-in-a-recursive-function",
    "title": "How do I return the last value in a recursive function?",
    "body": "<p>I'm a beginner and I'm currently learning about BST in Java. For this project, I'm trying to delete a node with 2 child nodes, but I'm having trouble getting the recursive method to return the correct value. This method is supposed to find the left-most value in the right-most subtree (successor) relevant to node 12. It does find the correct value (19) but it returns the initial value (0).</p>\n<pre><code>//Method that returns 0 instead of 19\n    public static int findHeir(Node node, int heir) {   \n        System.out.println(&quot;Loop&quot;);\n        if (node.rightChild != null &amp;&amp; node.leftChild != null) {\n            heir = node.leftChild.data;\n            System.out.print(&quot;Current node: &quot; + node.rightChild.data);\n            System.out.println(&quot; Current heir: &quot; + heir);\n            return findHeir(node.rightChild, heir);\n        }\n        \n        else if (node.rightChild == null) {\n                    System.out.println(&quot;Heir value before return: &quot; + heir);\n                    return heir;\n                }\n        \n        return heir;\n    }\n</code></pre>\n<p>I need findHeir to return 19 so that in the delete method I can switch the node's value (12) with heir (19), and delete the repeated node. Why does it keep returning the initial value? What can I do to make it return the last value?</p>\n<p>Full reproducible code:</p>\n<pre><code>import java.util.Scanner;\n\npublic class Main {\n    \n    static class Node {\n        int data;\n        int key;\n        Node leftChild;\n        Node rightChild;\n        \n        Node (int data) {\n            this.data = data;\n            leftChild = rightChild = null;\n        }\n    }\n    \n    static Node root;\n    \n    public Main() {\n        root = null;\n    }\n    \n    //Inserts the node in the right spot\n    public static void insert(int key) {\n        root = insertNode(root, key);\n    }\n    \n    public static Node insertNode(Node node, int key) {\n        if (node == null) {\n            node = new Node(key);\n            return node;\n        }\n        \n        else if (key &lt;= node.data) {\n            node.leftChild = insertNode(node.leftChild, key);\n        }\n        \n        else if (key &gt; node.data) {\n            node.rightChild = insertNode(node.rightChild, key);\n        }\n        return node;\n    }\n    \n    //Method that returns 0 instead of 19\n    public static int findHeir(Node node, int heir) {   \n        System.out.println(&quot;Loop&quot;);\n        if (node.rightChild != null &amp;&amp; node.leftChild != null) {\n            heir = node.leftChild.data;\n            System.out.print(&quot;Current node: &quot; + node.rightChild.data);\n            System.out.println(&quot; Current heir: &quot; + heir);\n            return findHeir(node.rightChild, heir);\n        }\n        \n        else if (node.rightChild == null) {\n            System.out.println(&quot;Heir value before return: &quot; + heir);\n            return heir;\n        }\n        \n        return heir;\n    }\n    \n    //Deletes the node\n    public static Node delete(Node node, int key) {\n        //Checks if the node exists\n        if (node == null) {\n            System.out.println(&quot;The node you entered does not exist.&quot;);\n            return node;\n        }\n        \n        //Looks for the correct node\n        else if (key &lt; node.data) {\n            node.leftChild = delete(node.leftChild, key);\n        }\n        \n        else if (key &gt; node.data) {\n            node.rightChild = delete(node.rightChild, key);\n        }\n        \n        //Found the correct node\n        else {\n            //Delete node if it has 2 children\n            if (node.leftChild != null &amp;&amp; node.rightChild != null) {\n                int heir = 0;\n                findHeir(node, heir);\n                System.out.println(&quot;Final node value: &quot; + node.data);\n                System.out.println(&quot;Final heir value: &quot; + heir + &quot; (should be 19)&quot;);\n                //TODO add code to switch heir and node.data and delete node\n            }\n        }\n        return node;\n    }\n    \n    public static void main(String [] args) {\n        int[] treeNodes = {5, 2, 12, -4, 3, 9, 21, 19, 25};\n        Main binaryTree = new Main();\n                \n        for (int i = 0; i &lt; treeNodes.length; i++) {\n            binaryTree.insert(treeNodes[i]);\n            System.out.print(treeNodes[i] + &quot; &quot;);\n        }\n        System.out.println();\n        \n        int key = 12;\n                \n        delete(root, key);\n    }\n}\n</code></pre>\n<p>The tree looks like this:</p>\n<pre><code>       5\n     /   \\\n   2       12\n  / \\     /  \\\n-4   3   9    21\n             /  \\\n            19  25\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}