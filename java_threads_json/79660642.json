{
  "question": {
    "tags": [
      "java",
      "c#",
      "encryption",
      "bouncycastle",
      "ecies"
    ],
    "owner": {
      "account_id": 21687780,
      "reputation": 29,
      "user_id": 30767305,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/2585ab95cc28d6f8ff3a65c5952998cb?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Ayan Panjal",
      "link": "https://stackoverflow.com/users/30767305/ayan-panjal"
    },
    "is_answered": true,
    "view_count": 278,
    "answer_count": 1,
    "score": 2,
    "last_activity_date": 1750425476,
    "creation_date": 1749565976,
    "last_edit_date": 1749576574,
    "question_id": 79660642,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79660642/error-while-decrypting-in-java-for-an-encrypted-string-generated-in-c-using-eci",
    "title": "Error while decrypting in Java for an encrypted string generated in C# using ECIES algorithm",
    "body": "<p>We have a target Java codebase responsible for decrypting an incoming payload. The payload is being encrypted within a .NET Core isolated Azure Function before being sent to the endpoint where the Java code attempts decryption. The encryption logic in .NET has been implemented to mirror the approach used in the Java code. However, during decryption on the Java side, we are encountering an <em>&quot;Invalid MAC&quot;</em> error.</p>\n<p>The Java code for encryption:</p>\n<pre class=\"lang-java prettyprint-override\"><code>package encrypt;\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.Security;\nimport java.security.Signature;\nimport java.security.SignatureException;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.time.Instant;\nimport java.util.Base64;\n\nimport javax.crypto.Cipher;\n\nimport org.bouncycastle.crypto.digests.Blake2bDigest;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\n\npublic class Encrypt {\n\n    public static void main(String[] args) throws Exception {\n        // plain-text request\n        String input = &quot;Encryption with ECIES&quot;;\n        String encryptedpayload = encryptECIES(input);\n        System.out.println(encryptedpayload);\n    }\n\n    public static String encryptECIES(String payLoad) throws Exception {\n        Security.addProvider(new BouncyCastleProvider());\n\n        String key = {{PUBLIC KEY}};\n\n        KeyFactory keyFactory = KeyFactory.getInstance(&quot;EC&quot;);\n        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(Base64.getDecoder().decode((base64PublicKey)));\n        PublicKey publicKey = keyFactory.generatePublic(x509EncodedKeySpec);\n        Cipher cipher = Cipher.getInstance(&quot;ECIESwithSHA512/NONE/NoPadding&quot;);\n        IESParameterSpec iesParamSpec = new IESParameterSpec(null, null, 256);\n        cipher.init(1, publicKey, iesParamSpec);\n        return Base64.getEncoder().encodeToString(cipher.doFinal(payLoad.getBytes()));\n    }\n}\n</code></pre>\n<p>The Java code snippet for decryption:</p>\n<pre class=\"lang-java prettyprint-override\"><code>package encrypt;\n\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.Security;\nimport java.security.Signature;\nimport java.security.SignatureException;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.time.Instant;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\n\nimport org.bouncycastle.crypto.digests.Blake2bDigest;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\nimport org.json.JSONObject;\n\npublic class Decrypt {\n\n    public static void main(String[] args) throws Exception{\n      // encrypted payload\n      String input = &quot;BEXNm796h82FKz79//6spJ/u9Aq7W+972N+vdx6dBnjiFibP+2XXHuHOzsLKqgKslj6NW8gIKk3//LPOckKnsWyETUtTKLF7LXRWzOp1jQbQfBHXqOu1J81N85r2PvHiL9vQG/oKxJMXXPLlSfJ0m1GTfG7FKzrELqhxAUoG3jUpIujjgycOHIw+iw9oQDcCGNZtpm7D&quot;;\n        String payload = createDecryptionCipher(input);\n    }\n\n    private static String createDecryptionCipher(String input) throws NoSuchPaddingException, NoSuchAlgorithmException, InterruptedException,\n            InvalidKeySpecException, InvalidAlgorithmParameterException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n        Security.addProvider(new BouncyCastleProvider());\n        Cipher cipher = Cipher.getInstance(&quot;ECIESwithSHA512/NONE/NoPadding&quot;);\n\n        String privateKey = &quot;{{PRIVATE KEY}}&quot;;\n        IESParameterSpec iesParamSpec = new IESParameterSpec(null, null,256);\n        cipher.init(2, getDecryptedPrivateKey(privateKey), iesParamSpec);\n        return new String(cipher.doFinal(Base64.getDecoder().decode(input.getBytes())));\n    }\n}\n</code></pre>\n<p>I've used similar encryption logic in C# that is used in the Java code snippet.</p>\n<p>The C# encryption logic that is used:</p>\n<pre class=\"lang-cs prettyprint-override\"><code>using Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Http.HttpResults;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Azure.Functions.Worker;\nusing Microsoft.Azure.Functions.Worker.Http;\nusing Microsoft.Extensions.Logging;\nusing Newtonsoft.Json;\nusing NSec.Cryptography;\nusing System.Text;\nusing System.Text.Json;\nusing System.Security.Cryptography;\nusing Org.BouncyCastle.Crypto.Digests;\nusing Org.BouncyCastle.Crypto.Parameters;\nusing Org.BouncyCastle.Crypto.Signers;\nusing Org.BouncyCastle.OpenSsl;\nusing System.Text.RegularExpressions;\nusing Org.BouncyCastle.Crypto;\nusing Org.BouncyCastle.Crypto.Agreement;\nusing Org.BouncyCastle.Crypto.Engines;\nusing Org.BouncyCastle.Crypto.Generators;\nusing Org.BouncyCastle.Crypto.Macs;\nusing Org.BouncyCastle.Security;\nusing Org.BouncyCastle.Asn1.X509;\nusing Org.BouncyCastle.Asn1;\nusing Org.BouncyCastle.Asn1.X9;\nusing Org.BouncyCastle.Crypto.EC;\nusing Org.BouncyCastle.Asn1.Anssi;\nusing Org.BouncyCastle.Asn1.Nist;\nusing Org.BouncyCastle.Asn1.TeleTrust;\nusing Org.BouncyCastle.Math.EC;\nusing Org.BouncyCastle.Asn1.Sec;\nusing Org.BouncyCastle.Asn1.X509;\nusing System.Security.Cryptography.X509Certificates;\nusing Org.BouncyCastle.Bcpg.OpenPgp;\n\nnamespace BharatConnectEncryption;\n\npublic class Encryption_Demo\n{\n    private readonly ILogger&lt;Encryption_Demo&gt; _logger;\n\n    public Encryption_Demo(ILogger&lt;Encryption_Demo&gt; logger)\n    {\n        _logger = logger;\n    }\n\n    [Function(&quot;Encryption_Demo&quot;)]\n    public async Task&lt;HttpResponseData&gt; Run([HttpTrigger(AuthorizationLevel.Function, &quot;post&quot;)] HttpRequestData req)\n    {\n        try\n        {\n            string input = &quot;Encryption with ECIES&quot;;\n            Console.WriteLine(&quot;Original: &quot; + input);\n           \n            string pemPublicKey = &quot;{{PUBLIC KEY}}&quot;\n            ECPublicKeyParameters pubKey = LoadPublicKeyFromPem(pemPublicKey);         \n\n            string encrypted = ECIESEncryptionUtil.Encrypt(input, pubKey);\n            Console.WriteLine(&quot;Encrypted: &quot; + encrypted);\n\n            var response = req.CreateResponse(System.Net.HttpStatusCode.OK);\n            await response.WriteStringAsync(encrypted);\n            return response;\n        }\n        catch (Exception ex)\n        {\n            var response = req.CreateResponse(System.Net.HttpStatusCode.InternalServerError);\n            await response.WriteStringAsync($&quot;There is some error. The reason is : {ex.Message}&quot;);\n            return response;\n        }\n    }\n\n    public static ECPublicKeyParameters LoadPublicKeyFromPem(string pem)\n    {\n        using var reader = new StringReader(pem);\n        var pemReader = new PemReader(reader);\n        var keyObject = pemReader.ReadObject();\n\n        if (keyObject is ECPublicKeyParameters pubKey)\n            return pubKey;\n\n        if (keyObject is SubjectPublicKeyInfo info)\n            return (ECPublicKeyParameters)PublicKeyFactory.CreateKey(info);\n\n        throw new Exception(&quot;Unsupported public key format&quot;);\n    }\n\npublic static class ECIESEncryptionUtil\n{\n    // Encrypt using ECIESwithSHA512/NONE/NoPadding\n    public static string Encrypt(string plainText, ECPublicKeyParameters recipientPublicKey)\n    {\n        var ecParams = recipientPublicKey.Parameters;\n        var random = new SecureRandom();\n\n        // Generate ephemeral key pair\n        var keyGen = new ECKeyPairGenerator();\n        keyGen.Init(new ECKeyGenerationParameters(ecParams, random));\n        AsymmetricCipherKeyPair ephKp = keyGen.GenerateKeyPair();\n\n        var iesEngine = new IesEngine(\n            new ECDHBasicAgreement(),\n            new Kdf2BytesGenerator(new Sha512Digest()),\n            new HMac(new Sha512Digest())\n        );\n\n        var derivation = new byte[0];\n        var encoding = new byte[0];\n        \n        var iesParams = new IesWithCipherParameters(derivation, encoding, 256, 512);\n        iesEngine.Init(true, ephKp.Private, recipientPublicKey, iesParams);\n\n        byte[] input = Encoding.UTF8.GetBytes(plainText);\n        byte[] ciphertext = iesEngine.ProcessBlock(input, 0, input.Length);\n\n        // Prepend ephemeral public key\n        byte[] ephPublicBytes = ((ECPublicKeyParameters)ephKp.Public).Q.GetEncoded(false);\n        byte[] result = new byte[ephPublicBytes.Length + ciphertext.Length];\n        Array.Copy(ephPublicBytes, 0, result, 0, ephPublicBytes.Length);\n        Array.Copy(ciphertext, 0, result, ephPublicBytes.Length, ciphertext.Length);\n\n        return Convert.ToBase64String(result);\n    }\n}\n</code></pre>\n<p>After generating the encrypted string from C# when we're using the string for decryption from the Java code, we're getting the error as <em>&quot;Invalid MAC&quot;</em>.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}