{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "jdbc",
      "hikaricp",
      "virtual-threads"
    ],
    "owner": {
      "account_id": 35759066,
      "reputation": 54,
      "user_id": 27385957,
      "user_type": "registered",
      "profile_image": "https://i.sstatic.net/xTemQxiI.png?s=256",
      "display_name": "gtatarsky",
      "link": "https://stackoverflow.com/users/27385957/gtatarsky"
    },
    "is_answered": true,
    "view_count": 1712,
    "accepted_answer_id": 79040864,
    "answer_count": 1,
    "score": 2,
    "last_activity_date": 1727726044,
    "creation_date": 1726789233,
    "last_edit_date": 1726839683,
    "question_id": 79004793,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79004793/oh-no-io-concurrency-issues-with-virtual-threads-hikaricp-and-spring-boot-jd",
    "title": "Oh no! IO! Concurrency issues with virtual threads, HikariCP, and Spring Boot JDBC (Postgres)",
    "body": "<p>I have run into an issue when using the following technologies.</p>\n<ul>\n<li>PostgreSQL run through a docker container</li>\n<li>Project Loom</li>\n<li>Spring Boot 3.3.4</li>\n<li>Java 21</li>\n<li>Spring Boot Starter JDBC (which includes HikariCp - who I believe to be the source of the issue)</li>\n<li>Spring Boot Starter JPA</li>\n</ul>\n<p>And obviously, a litany of other things. I can provide a POM on request, but I don't think it'll be helpful. My postgres driver is UTD, as is all my versions.</p>\n<p>The core issue is when running concurrent operations at high speeds, I am running into IO issues with HikariCp, when trying to save items to my database. I'm not totally sure what to do.</p>\n<p><strong>In my microservice's logs:</strong></p>\n<pre class=\"lang-java prettyprint-override\"><code>2024-09-19T18:50:51.617-04:00  WARN 10060 --- [virtual-ingest] [    virtual-342] com.zaxxer.hikari.pool.ProxyConnection   : HikariPool-1 - Connection org.postgresql.jdbc.PgConnection@28b26c3f marked as broken because of SQLSTATE(08006), ErrorCode(0)\n\norg.postgresql.util.PSQLException: An I/O error occurred while sending to the backend.\n</code></pre>\n<p>**In Docker Logs for PG (repeated, constantly):\n**</p>\n<pre><code>2024-09-19 22:50:51.807 UTC [412] LOG:  unexpected EOF on client connection with an open transaction\n\n</code></pre>\n<p>My code (I haven't gone back to clean this up yet):</p>\n<pre class=\"lang-java prettyprint-override\"><code>@EventListener(ApplicationReadyEvent.class)\n    public void startStructures()\n    {\n        try (var outerScope = new StructuredTaskScope.ShutdownOnFailure())\n        {\n            sqsConfig.getQueues().forEach(queue -&gt; outerScope.fork(() -&gt; {\n                processQueueMessages(queue);\n                return null;\n            }));\n            outerScope.join();\n        }\n        catch (InterruptedException e)\n        {\n            Thread.currentThread().interrupt();\n            log.error(&quot;Processing interrupted&quot;, e);\n        }\n    }\n\n    private void processQueueMessages(String queue)\n    {\n        while (true)\n        {\n            try (var innerScope = new StructuredTaskScope.ShutdownOnFailure())\n            {\n                List&lt;Message&gt; messages = retrieveMessages(queue);\n                if (messages.isEmpty())\n                {\n                    log.info(&quot;No messages in queue: {}, sleeping...&quot;, queue);\n                    Thread.sleep(5000);\n                }\n                else\n                {\n                    for (Message message : messages)\n                    {\n                        innerScope.fork(() -&gt; {\n                            processMessage(queue, message);\n                            return null;\n                        });\n                    }\n                    innerScope.join();\n                }\n            }\n            catch (InterruptedException e)\n            {\n                Thread.currentThread().interrupt();\n                log.error(&quot;Queue processing interrupted&quot;, e);\n                break;\n            }\n        }\n    }\n\n    public List&lt;Message&gt; retrieveMessages(String queue)\n    {\n        var url = awsConfig.getBaseUrl() + queue;\n        ReceiveMessageRequest request = ReceiveMessageRequest.builder()\n                                                             .queueUrl(url)\n                                                             .maxNumberOfMessages(10)\n                                                             .waitTimeSeconds(\n                                                                 10)\n                                                             .build();\n\n        ReceiveMessageResponse response = sqsClient.receiveMessage(request);\n        return response.messages();\n    }\n\n    private void processMessage(String queue, Message message) throws JsonProcessingException\n    {\n\n        log.info(&quot;Processing message from queue {}: {}&quot;, queue, message.messageId());\n\n        JsonNode node = nodeBuilderService.buildNode(message);\n        distributionService.handleSqsNotification(node);\n        deleteMessage(queue, message);\n    }\n\n    private void deleteMessage(String queue, Message message)\n    {\n        var url = awsConfig.getBaseUrl() + queue;\n        sqsClient.deleteMessage(builder -&gt; builder.queueUrl(url).receiptHandle(message.receiptHandle()));\n\n        int remainingMessages = getMessageCount(queue);\n        log.info(\n            &quot;Deleted message: {}. Approximate {} messages remaining in the queue.&quot;, message.messageId(),\n            remainingMessages\n        );\n    }\n\n    public int getMessageCount(String queueName)\n    {\n        var url = awsConfig.getBaseUrl() + queueName;\n\n        GetQueueAttributesRequest request = GetQueueAttributesRequest.builder()\n                                                                     .queueUrl(url)\n                                                                     .attributeNames(\n                                                                         QueueAttributeName.APPROXIMATE_NUMBER_OF_MESSAGES)\n                                                                     .build();\n\n        return Integer.parseInt(\n            sqsClient.getQueueAttributes(request)\n                     .attributes()\n                     .get(QueueAttributeName.APPROXIMATE_NUMBER_OF_MESSAGES)\n        );\n    }\n</code></pre>\n<p>In the processing of messages, my code eventually hits this method:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Transactional\n    public void process(String filename, InputStream stream)\n    throws IOException\n    {\n        byte[] bytes = getBytesFromInputStream(stream, filename);\n\n        List&lt;SurfaceObservation&gt; observations = decoder.beginSynopticDecoders(bytes, filename);\n        repository.saveAllAndFlush(observations);\n    }\n</code></pre>\n<p>Which is where the error occurs.</p>\n<p>I have tried forcing this onto a platform thread, but I believe this is related to HikariCP's lack of support for virtual threads, even in current versions. I watched JEP cafe on my scopesâ€”and I'm wondering if anyone can help me answer a few questions.</p>\n<ol>\n<li>Am I doing anything blatantly wrong? I'm migrating from async patterns, and want to never use them again, so there's a good chance I don't know what I should be doing.</li>\n<li>I am wondering if ExtentLocal can help. I think the problem in Hikari might be related to their use of ThreadLocal. but again, new to this stuff.</li>\n<li>Do I have to ditch spring jdbc? What would I use instead? R2DBC as of (I'm pretty sure) writing this still does not have a good ORM system, even with Hibernate reactive.</li>\n</ol>\n<p>I tried Platform threads, I tried a scope for just the DB transactions. I tried a lot of stuff for hours and have that code-brain where now I'm not even sure what I tried. I even tried to have chatGPT help me, and as expected, it could not.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}