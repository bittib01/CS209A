{
  "question": {
    "tags": [
      "java",
      "reflection"
    ],
    "owner": {
      "account_id": 15881203,
      "reputation": 66,
      "user_id": 11458910,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/976aa92b80da76fe4153efbd05048f04?s=256&d=identicon&r=PG",
      "display_name": "TdrFlp",
      "link": "https://stackoverflow.com/users/11458910/tdrflp"
    },
    "is_answered": true,
    "view_count": 144,
    "accepted_answer_id": 79013952,
    "answer_count": 2,
    "score": 0,
    "last_activity_date": 1727762450,
    "creation_date": 1726844230,
    "question_id": 79007297,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79007297/create-extended-class-via-reflection",
    "title": "Create extended class via Reflection",
    "body": "<p>I have a nice and clean interface like so:</p>\n<pre><code>public interface Mapping&lt;I extends Input, O extends Output&gt; {\n    O calculate(I input);\n\n    Class&lt;I&gt; getInputClass();\n\n    Class&lt;O&gt; getOutputClass();\n}\n</code></pre>\n<p>Let's assume for simplicity that <code>Input</code> and <code>Output</code> are empty interfaces.</p>\n<p>I want to define Mappings at runtime and instantiate them via reflection. One example for such a <code>Mapping</code> is the following:</p>\n<pre><code>public class DoublerMapping implements Mapping&lt;DoublerInput, DoublerOutput&gt; {\n    @Override\n    DoublerOutput calculate(DoublerInput input){\n       DoublerOutput output = new DoublerOutput();\n       output.setValue(input.getValue() * 2);\n       return output;\n    }\n\n    @Override\n    Class&lt;DoublerInput&gt; getInputClass(){\n       return DoublerInput.class;\n    }\n\n    @Override\n    Class&lt;O&gt; getOutputClass(){\n       return DoublerInput.class;\n    }\n}\n</code></pre>\n<p>When instantiating <code>Mapping</code>s by reflection, however, I can only use <code>getInputClass()</code> and <code>getOutputClass()</code> to instantiate <code>Inputs</code> and <code>Outputs</code> respectively (utilizing <code>mapping.getInputClass().getDeclaredConstructor().newInstance()</code>), instead of their actual extension. I don't want the <code>Mapping</code> to take a generic <code>Input</code> as I want to make sure it's getting the proper class <code>I</code> it's expecting. I also can't pull the <code>getValue()</code> and <code>setValue()</code> methods to the interface, as they could take any arguments and have different signatures.</p>\n<p>How do I go to create an <code>I extends Input</code> at runtime and feeding it back to the parameterized <code>Mapping</code> class? Not even <code>mapping.execute(mapping.getInputClass().getDeclaredConstructor().newInstance())</code> compiles.</p>\n<p>Or is there a better way to achieve this?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}