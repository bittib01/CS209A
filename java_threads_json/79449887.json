{
  "question": {
    "tags": [
      "java",
      "hazelcast",
      "hazelcast-imap",
      "near-cache"
    ],
    "owner": {
      "account_id": 2492679,
      "reputation": 23196,
      "user_id": 2169845,
      "user_type": "registered",
      "accept_rate": 91,
      "profile_image": "https://i.sstatic.net/XoDg6.gif?s=256",
      "display_name": "zappee",
      "link": "https://stackoverflow.com/users/2169845/zappee"
    },
    "is_answered": false,
    "view_count": 57,
    "answer_count": 0,
    "score": 1,
    "last_activity_date": 1740160390,
    "creation_date": 1739923075,
    "last_edit_date": 1740160390,
    "question_id": 79449887,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79449887/hazelcast-near-cache-configuration-do-the-map-id-and-near-cache-id-have-to-be-t",
    "title": "Hazelcast near-cache configuration: Do the Map-ID and Near-Cache-ID have to be the same?",
    "body": "<p>I am learning how the different Hazelcast cache topologies work. I use the latest <code>5.5.0</code> maven dependency and I use always and only Java configuration, and no XML config is used.</p>\n<p>I have a problem with the Map-ID <code>hazelcastClient.getMap(&quot;name&quot;)</code> and the Near-Cahche-Configuration name <code>new NearCacheConfig(&quot;name&quot;)</code>.</p>\n<p>The doc <a href=\"https://docs.hazelcast.com/hazelcast/5.5/cluster-performance/near-cache\" rel=\"nofollow noreferrer\">here</a> says this:</p>\n<blockquote>\n<p>The Near Cache on the client side must have the same name as the data\nstructure on the member for which this Near Cache is being created.\nYou can use wildcards, so in this example mostlyRead* would also match\nthe map mostlyReadMap.</p>\n</blockquote>\n<p>It is clear that Near Cache Config lives  on the client side and the map-id is used to identify the distributed map within the Hazelcast cluster.</p>\n<p>But for me the wildcards do not want to work and my demo only works properly if the near-cache-configuration name equals with the map-id:</p>\n<pre><code>... new NearCacheConfig(&quot;counter&quot;)\n... hazelcastClient.getMap(&quot;counter&quot;)\n</code></pre>\n<p>I tried the following combinations but non of them works, my near-cache-config is not used:</p>\n<ul>\n<li><code>new NearCacheConfig(&quot;counter)</code> and <code>hazelcastClient.getMap(&quot;counterId)</code></li>\n<li><code>new NearCacheConfig(&quot;counterId)</code> and <code>hazelcastClient.getMap(&quot;counter)</code></li>\n</ul>\n<p><strong>This is my test code:</strong></p>\n<pre><code>public class HazelcastConfiguration {\n\n    // THE FOLLOWING TWO VALUES MUST BE IDENTICAL\n    // e.g. &quot;counter-config&quot; and &quot;counter&quot; DOES NOT WORK\n    public static final String NEAR_CACHE_CONFIG_NAME = &quot;counter&quot;;\n    public static final String COUNTER_MAP_ID = &quot;counter&quot;;\n\n    private static final String HZ_CLUSTER_NAME = &quot;gombi-dev&quot;;\n    private static final String HZ_CLUSTER_ADDRESS_1 = &quot;localhost:13063&quot;;\n    private static final String HZ_CLUSTER_ADDRESS_2 = &quot;localhost:13073&quot;;\n\n    public static HazelcastInstance getHazelcastInstance() {\n        NearCacheConfig nearCacheConfigForCounterMap = new NearCacheConfig(NEAR_CACHE_CONFIG_NAME)\n                .setInMemoryFormat(InMemoryFormat.BINARY)\n                .setTimeToLiveSeconds(30)\n                .setMaxIdleSeconds(10)\n                .setEvictionConfig(new EvictionConfig()\n                        .setEvictionPolicy(EvictionPolicy.LRU)\n                        .setSize(1000));\n\n        ClientConfig clientConfig = new ClientConfig();\n        clientConfig.setClusterName(HZ_CLUSTER_NAME);\n        clientConfig.getNetworkConfig().getAddresses().add(HZ_CLUSTER_ADDRESS_1);\n        clientConfig.getNetworkConfig().getAddresses().add(HZ_CLUSTER_ADDRESS_2);\n        clientConfig.addNearCacheConfig(nearCacheConfigForCounterMap);\n\n        return HazelcastClient.newHazelcastClient(clientConfig);\n    }\n}\n</code></pre>\n<p><strong>Then my cache reader demo:</strong></p>\n<pre><code>public class NearCacheReader {\n\n     public static void main(String[] args) {\n         String username = &quot;zappee&quot;;\n         String key = MapKeyGenerator.getKey(username);\n\n        HazelcastInstance hazelcastClient = HazelcastConfiguration.getHazelcastInstance();\n\n        TimerTask task = new TimerTask() {\n            @Override\n            public void run() {\n                // nearCache will never be null\n                IMap&lt;String, Integer&gt; nearCache = hazelcastClient.getMap(HazelcastConfiguration.COUNTER_MAP_ID);\n\n                Integer value = nearCache.get(key);\n                if (Objects.isNull(value)) {\n                    System.out.printf(\n                            &quot;[%s] near-cache entry miss: {username: \\&quot;%s\\&quot;}%n&quot;,\n                            LocalTimeConverter.nowAsString(),\n                            username);\n                } else {\n                    System.out.printf(\n                            &quot;[%s] near-cache entry hit: {username: \\&quot;%s\\&quot;, value: %s}%n&quot;,\n                            LocalTimeConverter.nowAsString(),\n                            username,\n                            value);\n                }\n            }\n        };\n\n        // Schedule the timer task to run after 1 second\n        Timer timer = new Timer();\n        timer.scheduleAtFixedRate(task, 0, 1000);\n    }\n}\n</code></pre>\n<p><strong>And my cache updater demo:</strong></p>\n<pre><code>public class NearCacheUpdater {\n\n    public static void main(String[] args) {\n        String username = &quot;zappee&quot;;\n        String key = MapKeyGenerator.getKey(username);\n\n        HazelcastInstance hazelcastClient = HazelcastConfiguration.getHazelcastInstance();\n        IMap&lt;String, Integer&gt; nearCache = hazelcastClient.getMap(HazelcastConfiguration.COUNTER_MAP_ID);\n        nearCache.put(key, 1);\n\n        TimerTask task = new TimerTask() {\n            @Override\n            public void run() {\n                int value = nearCache.get(key);\n                value++;\n                nearCache.put(key, value);\n\n                System.out.printf(\n                        &quot;[%s] value in the cache has been updated: {username: \\&quot;%s\\&quot;, new-value: %s}\\n&quot;,\n                        LocalTimeConverter.nowAsString(),\n                        username,\n                        value);\n            }\n        };\n\n        // Schedule the timer task to run after 1 second\n        Timer timer = new Timer();\n        timer.scheduleAtFixedRate(task, 0, 1000);\n    }\n}\n</code></pre>\n<p>This is the output log if the <code>NEAR_CACHE_CONFIG_NAME</code> and <code>COUNTER_MAP_ID</code> are equals. First start the reader, then later the updater. Here I can see clearly that the value comes from the local cache and it is refreshed in every 10 second:</p>\n<pre><code>[23:27:32] near-cache entry miss: {username: &quot;zappee&quot;}\n[23:27:33] near-cache entry miss: {username: &quot;zappee&quot;}\n...\n[23:27:57] near-cache entry miss: {username: &quot;zappee&quot;}\n[23:27:58] near-cache entry hit: {username: &quot;zappee&quot;, value: 12}\n[23:27:59] near-cache entry hit: {username: &quot;zappee&quot;, value: 12}\n...\n[23:28:07] near-cache entry hit: {username: &quot;zappee&quot;, value: 12}\n[23:28:08] near-cache entry hit: {username: &quot;zappee&quot;, value: 22}\n...\n[23:28:17] near-cache entry hit: {username: &quot;zappee&quot;, value: 22}\n[23:28:18] near-cache entry hit: {username: &quot;zappee&quot;, value: 32}\n...\n</code></pre>\n<p><strong>And the updater log, which only updates the cache value every second:</strong></p>\n<pre><code>[23:27:47] value in the cache has been updated: {username: &quot;zappee&quot;, new-value: 2}\n[23:27:48] value in the cache has been updated: {username: &quot;zappee&quot;, new-value: 3}\n[23:27:49] value in the cache has been updated: {username: &quot;zappee&quot;, new-value: 4}\n...\n[23:28:28] value in the cache has been updated: {username: &quot;zappee&quot;, new-value: 43}\n...\n</code></pre>\n<p>But if the <code>NEAR_CACHE_CONFIG_NAME</code> and <code>COUNTER_MAP_ID</code> are only partially equals, the near cache configuration does not work as I see it and according to the log the value is always read from the Hazelcast cluster, not from the local cache:</p>\n<pre><code>[23:37:01] near-cache entry miss: {username: &quot;zappee&quot;}\n[23:37:02] near-cache entry miss: {username: &quot;zappee&quot;}\n...\n[23:37:09] near-cache entry miss: {username: &quot;zappee&quot;}\n[23:37:10] near-cache entry hit: {username: &quot;zappee&quot;, value: 2}\n[23:37:11] near-cache entry hit: {username: &quot;zappee&quot;, value: 3}\n[23:37:12] near-cache entry hit: {username: &quot;zappee&quot;, value: 4}\n[23:37:13] near-cache entry hit: {username: &quot;zappee&quot;, value: 5}\n[23:37:14] near-cache entry hit: {username: &quot;zappee&quot;, value: 6}\n...\n</code></pre>\n<p><a href=\"https://github.com/zappee/gombi/tree/0.4.0/projects/remal-gombi-hazelcast-demo\" rel=\"nofollow noreferrer\">The working full code is available here</a></p>\n<p>What I missed here?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}