{
  "question": {
    "tags": [
      "java",
      "spring",
      "project-reactor",
      "model-context-protocol",
      "spring-ai"
    ],
    "owner": {
      "account_id": 4723263,
      "reputation": 247,
      "user_id": 3820633,
      "user_type": "registered",
      "accept_rate": 17,
      "profile_image": "https://www.gravatar.com/avatar/102db1d429d12dc6e3fdf1f3d3ffbf5a?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "robynico",
      "link": "https://stackoverflow.com/users/3820633/robynico"
    },
    "is_answered": true,
    "view_count": 238,
    "accepted_answer_id": 79812408,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1763056804,
    "creation_date": 1761140826,
    "last_edit_date": 1761228709,
    "question_id": 79796845,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79796845/spring-mcp-client-do-not-access-to-http-headers-from-mcptransportcontext-in-stre",
    "title": "Spring MCP Client do not access to HTTP Headers from McpTransportContext in stream mode",
    "body": "<p>I'm trying to implement a <strong>Spring MCP Client</strong> based on the <code>spring-ai</code> <strong>1.1.0-SNAPSHOT</strong> library.</p>\n<p>The <strong>minimal project source code</strong> is available in this public GitHub repository: <a href=\"https://github.com/robynico/spring-mcp-client-stream\" rel=\"nofollow noreferrer\">https://github.com/robynico/spring-mcp-client-stream</a>.</p>\n<p>The Spring controller exposes 2 endpoints:</p>\n<ul>\n<li><code>/chat</code> → Non-streaming</li>\n<li><code>/stream-chat</code> → Streaming</li>\n</ul>\n<p>When calling <code>/stream-chat</code>, the <code>ServletContext</code> is <strong>not available</strong> from <code>McpTransportContext</code> despite implementing <code>AuthenticationMcpTransportContextProvider</code> as recommended in: <a href=\"https://github.com/spring-ai-community/mcp-security\" rel=\"nofollow noreferrer\">https://github.com/spring-ai-community/mcp-security</a></p>\n<p><strong>Question:</strong><br />\nHow to propagate HTTP headers in a <strong>thread-safe way</strong> to the MCP tool execution context when using streaming with reactor ?</p>\n<hr />\n<h2>Controller</h2>\n<p><code>ChatController.java</code></p>\n<pre class=\"lang-java prettyprint-override\"><code>@RestController\n@Validated\npublic class ChatController {\n\n    public static final String HTTP_HEADER_TENANT = &quot;Tenant&quot;;\n\n    private static final Logger logger = LoggerFactory.getLogger(ChatController.class);\n\n    private final AgentService agentService;\n\n    public ChatController(AgentService agentService) {\n        this.agentService = agentService;\n    }\n\n    @PostMapping(value = &quot;/chat&quot;)\n    public String chat(@RequestBody @Valid ChatRequest request) {\n        return agentService.chat(request.getPrompt());\n    }\n\n    @PostMapping(value = &quot;/stream-chat&quot;)\n    public Flux&lt;String&gt; streamChat(@RequestBody @Valid ChatRequest request, @Headers HttpHeaders headers) {\n        var requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        logger.info(&quot;Tenant {}&quot;, requestAttributes.getRequest().getHeader(HTTP_HEADER_TENANT));\n        return agentService.streamChat(request.getPrompt());\n    }\n\n}\n</code></pre>\n<h3>ContextProvider &amp; RequestCustomizer</h3>\n<p><code>McpConfiguration.java</code></p>\n<pre class=\"lang-java prettyprint-override\"><code>@Configuration\npublic class McpConfiguration implements WebMvcConfigurer {\n\n    @Bean\n    McpSyncClientCustomizer syncClientCustomizer() {\n        return (name, syncSpec) -&gt; syncSpec.transportContextProvider(new AuthenticationMcpTransportContextProvider());\n    }\n\n    @Bean\n    McpSyncHttpClientRequestCustomizer requestCustomizer() {\n        return new CustomMcpSyncRequestCustomizer();\n    }\n\n}\n</code></pre>\n<p><code>AuthenticationMcpTransportContextProvider.java</code></p>\n<pre class=\"lang-java prettyprint-override\"><code>public class AuthenticationMcpTransportContextProvider implements Supplier&lt;McpTransportContext&gt; {\n\n    private static final Logger logger = LoggerFactory.getLogger(AuthenticationMcpTransportContextProvider.class);\n\n    public static final String HTTP_HEADERS_KEY = &quot;httpHeaders&quot;;\n\n    @Override\n    public McpTransportContext get() {\n        var data = new HashMap&lt;String, Object&gt;();\n        RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();\n        if (previousAttributes instanceof ServletRequestAttributes) {\n            HttpServletRequest request = ((ServletRequestAttributes) previousAttributes).getRequest();\n            Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();\n            List.of(HttpHeaders.AUTHORIZATION, HTTP_HEADER_TENANT).forEach(headerName -&gt; {\n                String value = request.getHeader(headerName);\n                if (value != null) {\n                    headers.put(headerName, value);\n                }\n            });\n            data.put(HTTP_HEADERS_KEY, headers);\n        }\n        logger.info(&quot;Headers found in RequestContextHolder: {}&quot;, data);\n        return McpTransportContext.create(data);\n    }\n\n}\n</code></pre>\n<p><code>CustomMcpSyncRequestCustomizer.java</code></p>\n<pre class=\"lang-java prettyprint-override\"><code>class CustomMcpSyncRequestCustomizer implements McpSyncHttpClientRequestCustomizer {\n\n    private static final Logger logger = LoggerFactory.getLogger(CustomMcpSyncRequestCustomizer.class);\n\n    @Override\n    public void customize(HttpRequest.Builder builder, String method, URI endpoint, String body,\n            McpTransportContext context) {\n        var headers = context.get(AuthenticationMcpTransportContextProvider.HTTP_HEADERS_KEY);\n        logger.info(&quot;Headers found in McpTransportContext: {}&quot;, headers);\n\n        if (headers instanceof Map&lt;?, ?&gt; headerMap) {\n            List.of(HttpHeaders.AUTHORIZATION, HTTP_HEADER_TENANT).forEach(headerName -&gt; {\n                var value = headerMap.get(headerName);\n                if (value instanceof String stringValue) {\n                    builder.header(headerName, stringValue);\n                }\n            });\n        }\n    }\n\n}\n</code></pre>\n<h3>ChatClient</h3>\n<p><code>AgentService.java</code></p>\n<pre class=\"lang-java prettyprint-override\"><code>@Component\npublic class AgentService {\n\n    private final ChatClient chatClient;\n\n    public AgentService(ChatClient.Builder chatClientBuilder, ToolCallbackProvider mcpToolProvider) {\n        var options = BedrockChatOptions.builder()\n            .model(&quot;anthropic.claude-3-5-sonnet-20240620-v1:0&quot;)\n            .temperature(0.6)\n            .maxTokens(3000)\n            .build();\n        chatClient = chatClientBuilder.defaultOptions(options).defaultToolCallbacks(mcpToolProvider).build();\n    }\n\n    public Flux&lt;String&gt; streamChat(String prompt) {\n        return chatClient.prompt().user(userMessage -&gt; userMessage.text(prompt)).stream().content();\n    }\n\n    public String chat(String prompt) {\n        return chatClient.prompt().user(userMessage -&gt; userMessage.text(prompt)).call().content();\n    }\n\n}\n</code></pre>\n<hr />\n<h2>Test</h2>\n<p>Curl:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>curl -X POST http://localhost:8080/stream-chat \\\n-H &quot;Content-Type: application/json&quot; \\\n-H &quot;Tenant: A &quot; \\\n-d '{&quot;prompt&quot;: &quot;do an echo toto&quot;}'\n</code></pre>\n<p>Observed Logs:</p>\n<pre><code>[nio-8080-exec-3] c.c.a.m.c.controller.ChatController      : Tenant A\n[yEventLoop-1-14] o.s.a.b.converse.BedrockProxyChatModel   : Completed streaming response.\n[oundedElastic-2] uthenticationMcpTransportContextProvider : Headers found in RequestContextHolder: {}\n[oundedElastic-2] c.a.m.c.c.CustomMcpSyncRequestCustomizer : Headers found in McpTransportContext: null\n[yEventLoop-1-14] o.s.a.b.converse.BedrockProxyChatModel   : Completed streaming response.\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}