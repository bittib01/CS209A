{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "spring-data-jpa"
    ],
    "owner": {
      "account_id": 67765,
      "reputation": 5159,
      "user_id": 198108,
      "user_type": "registered",
      "accept_rate": 79,
      "profile_image": "https://www.gravatar.com/avatar/0d61e8dd1d552643c997a61442ac197b?s=256&d=identicon&r=PG",
      "display_name": "javydreamercsw",
      "link": "https://stackoverflow.com/users/198108/javydreamercsw"
    },
    "is_answered": false,
    "view_count": 148,
    "answer_count": 1,
    "score": 2,
    "last_activity_date": 1728935462,
    "creation_date": 1726611466,
    "last_edit_date": 1728036259,
    "question_id": 78995965,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78995965/spring-jpa-entity-with-embedded-key-is-not-deleted",
    "title": "Spring JPA: Entity with embedded key is not deleted",
    "body": "<p>I'm learning Spring Boot as I go and everything was fine so far using Spring JPA to manage database until I tried deleting an entity that has an embedded key.</p>\n<p>The relevant entity is as follows:</p>\n<pre class=\"lang-java prettyprint-override\"><code>    @Setter\n    @Getter\n    @Data\n    @Entity\n    @NoArgsConstructor(access = AccessLevel.PROTECTED)\n    @AllArgsConstructor\n    @JsonIgnoreProperties(ignoreUnknown = true)\n    @JsonInclude(JsonInclude.Include.NON_NULL)\n    @Cacheable\n    @ToString\n    @Builder\n    @Table(name = &quot;test_case_execution_result&quot;)\n    @NamedQueries({\n    @NamedQuery(\n    name = &quot;TestCaseExecutionResult.findAll&quot;,\n    query = &quot;SELECT t FROM TestCaseExecutionResult t&quot;),\n    @NamedQuery(\n    name = &quot;TestCaseExecutionResult.findById&quot;,\n    query = &quot;SELECT t FROM TestCaseExecutionResult t WHERE t.testCaseExecutionResultPK.id = :id&quot;),\n    @NamedQuery(\n    name = &quot;TestCaseExecutionResult.findByTestCaseResultId&quot;,\n    query =\n    &quot;SELECT t FROM TestCaseExecutionResult t WHERE&quot;\n    \\+ &quot; t.testCaseExecutionResultPK.testCaseResultId = :testCaseResultId&quot;),\n    @NamedQuery(\n    name = &quot;TestCaseExecutionResult.findByTestCaseId&quot;,\n    query =\n    &quot;SELECT t FROM TestCaseExecutionResult t WHERE t.testCaseExecutionResultPK.testCaseId =&quot;\n    \\+ &quot; :testCaseId&quot;),\n    @NamedQuery(\n    name = &quot;TestCaseExecutionResult.findByTestRegionId&quot;,\n    query =\n    &quot;SELECT t FROM TestCaseExecutionResult t WHERE t.testCaseExecutionResultPK.testRegionId =&quot;\n    \\+ &quot; :testRegionId&quot;),\n    @NamedQuery(\n    name = &quot;TestCaseExecutionResult.findByDate&quot;,\n    query = &quot;SELECT t FROM TestCaseExecutionResult t WHERE t.date = :date&quot;),\n    @NamedQuery(\n    name = &quot;TestCaseExecutionResult.findByRelatedJob&quot;,\n    query = &quot;SELECT t FROM TestCaseExecutionResult t WHERE t.relatedJob = :relatedJob&quot;)\n    })\n    \n    public class TestCaseExecutionResult implements Serializable {\n    \n    @Serial private static final long serialVersionUID = 1L;\n    @EmbeddedId protected TestCaseExecutionResultPK testCaseExecutionResultPK;\n    \n    @Basic(optional = false)\n    @NotNull @Column(name = &quot;date&quot;)\n    @Temporal(TemporalType.TIMESTAMP)\n    private Date date;\n    \n    @Basic(optional = false)\n    @NotNull @Size(min = 1, max = 255)\n    @Column(name = &quot;relatedJob&quot;)\n    private String relatedJob;\n    \n    @JoinColumn(\n    name = &quot;test_case_id&quot;,\n    referencedColumnName = &quot;id&quot;,\n    insertable = false,\n    updatable = false)\n    @ManyToOne(optional = false)\n    private TestCase testCase;\n    \n    @JoinColumn(\n    name = &quot;test_case_result_id&quot;,\n    referencedColumnName = &quot;id&quot;,\n    insertable = false,\n    updatable = false)\n    @ManyToOne(optional = false)\n    private TestCaseResult testCaseResult;\n    \n    @JoinColumn(\n    name = &quot;test_region_id&quot;,\n    referencedColumnName = &quot;id&quot;,\n    insertable = false,\n    updatable = false)\n    @ManyToOne(optional = false)\n    private TestRegion testRegion;\n    \n    public TestCaseExecutionResult(TestCaseExecutionResultPK testCaseExecutionResultPK) {\n    this.testCaseExecutionResultPK = testCaseExecutionResultPK;\n    }\n    \n    public TestCaseExecutionResult(\n    TestCaseExecutionResultPK testCaseExecutionResultPK, Date date, String relatedJob) {\n    this.testCaseExecutionResultPK = testCaseExecutionResultPK;\n    this.date = date;\n    this.relatedJob = relatedJob;\n    }\n    \n    public TestCaseExecutionResult(\n    int testCaseExecutionResultPK, int testCaseResultId, int testCaseId, int testRegionId) {\n    this.testCaseExecutionResultPK =\n    new TestCaseExecutionResultPK(\n    testCaseExecutionResultPK, testCaseResultId, testCaseId, testRegionId);\n    }\n    \n    @Override\n    public int hashCode() {\n    int hash = 0;\n    hash += (testCaseExecutionResultPK != null ? testCaseExecutionResultPK.hashCode() : 0);\n    return hash;\n    }\n    \n    @Override\n    public boolean equals(Object object) {\n    // TODO: Warning - this method won't work in the case the id fields are not set\n    if (!(object instanceof TestCaseExecutionResult other)) {\n    return false;\n    }\n    return (this.testCaseExecutionResultPK != null || other.testCaseExecutionResultPK == null)\n    &amp;&amp; (this.testCaseExecutionResultPK == null\n    || this.testCaseExecutionResultPK.equals(other.testCaseExecutionResultPK));\n    }\n    }\n</code></pre>\n<p>This is the relevant controller:</p>\n<pre class=\"lang-java prettyprint-override\"><code>    @RestController\n    @SuppressWarnings(&quot;PMD.TestClassWithoutTestCases&quot;)\n    public class TestCaseExecutionResultController {\n    \n    private final TestCaseExecutionResultRepository repository;\n    private final TestCaseExecutionResultAssembler assembler;\n    \n    public TestCaseExecutionResultController(\n    TestCaseExecutionResultRepository repository, TestCaseExecutionResultAssembler assembler) {\n    this.repository = repository;\n    this.assembler = assembler;\n    }\n    \n    @PostMapping(Endpoints.EXECUTION_RESULT_REGION)\n    @ResponseStatus(HttpStatus.CREATED)\n    public ResponseEntity\\&lt;EntityModel\\&lt;TestCaseExecutionResult\\&gt;\\&gt; createTestCaseExecutionResult(\n    @RequestBody TestCaseExecutionResult testCaseExecutionResult,\n    @PathVariable Integer tcId,\n    @PathVariable Integer regionId,\n    @PathVariable Integer resultId) {\n    if (testCaseExecutionResult.getTestCaseExecutionResultPK() == null) {\n    testCaseExecutionResult.setTestCaseExecutionResultPK(\n    TestCaseExecutionResultPK.builder()\n    .testCaseResultId(resultId)\n    .testCaseId(tcId)\n    .testRegionId(regionId)\n    .build());\n    }\n    testCaseExecutionResult.setDate(new Date());\n    return ResponseEntity.ok(this.assembler.toModel(this.repository.save(testCaseExecutionResult)));\n    }\n    \n    @GetMapping(Endpoints.EXECUTION_RESULTS)\n    public ResponseEntity\\&lt;CollectionModel\\&lt;EntityModel\\&lt;TestCaseExecutionResult\\&gt;\\&gt;\\&gt; findAll() {\n    return ResponseEntity.ok(this.assembler.toCollectionModel(this.repository.findAll()));\n    }\n    \n    @GetMapping(Endpoints.EXECUTION_RESULTS_REGION)\n    public ResponseEntity\\&lt;CollectionModel\\&lt;EntityModel\\&lt;TestCaseExecutionResult\\&gt;\\&gt;\\&gt;\n    executionResultsForTestCaseInRegion(\n    @PathVariable Integer tcId, @PathVariable Integer regionId) throws NotFoundException {\n    return ResponseEntity.ok(\n    this.assembler.toCollectionModel(\n    this.repository.findByTestCaseIdAndTestRegionId(tcId, regionId)));\n    }\n    \n    @DeleteMapping(Endpoints.EXECUTION_RESULT_REGION_EXECUTION)\n    public ResponseEntity\\&lt;?\\&gt; delete(\n    @PathVariable Integer tcId,\n    @PathVariable Integer regionId,\n    @PathVariable Integer resultId,\n    @PathVariable Integer executionId)\n    throws NotFoundException {\n    Iterable\\&lt;TestCaseExecutionResult\\&gt; results =\n    repository.findAllById(\n    List.of(new TestCaseExecutionResultPK(executionId, resultId, tcId, regionId)));\n    if (results.iterator().hasNext()) {\n    TestCaseExecutionResult target = results.iterator().next();\n    this.repository.deleteById(target.getTestCaseExecutionResultPK());\n    return ResponseEntity.noContent().build();\n    } else {\n    throw new NotFoundException(\n    &quot;Test case execution result with id &quot;\n    \\+ new TestCaseExecutionResultPK(executionId, resultId, tcId, regionId)\n    \\+ &quot; not found&quot;);\n    }\n    }\n    }\n</code></pre>\n<p>Have the following test where I basically create the necesary entities and then create a test case execution result which works fine. Then I proceed to delete it but fail when I expect to no longer being able to find it via the API. This is the approach that I use in all the other tests and seem to work fine in those cases. The only difference I can find so far is the key for this entity.</p>\n<pre class=\"lang-java prettyprint-override\"><code>    @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n    @Slf4j\n    public class TestCaseExecutionTest {\n    \n    @Autowired private TestCaseExecutionResultController controller;\n    \n    @Autowired TestCaseExecutionResultRepository repository;\n    \n    @Autowired private TestRegionRepository regionRepository;\n    \n    @Autowired private TestCaseResultRepository resultRepository;\n    \n    @Autowired private TestCaseRepository testCaseRepository;\n    \n    @LocalServerPort private int port;\n    \n    @Autowired private TestRestTemplate restTemplate;\n    \n    @Test\n    void contextLoads() {\n    assertThat(controller).isNotNull();\n    }\n    \n    @Test\n    @SneakyThrows\n    public void testCreateTestCaseExecutionResult() {\n    TestCase tc =\n    TestCase.builder()\n    .className(&quot;ClassName&quot;)\n    .testName(&quot;testName&quot;)\n    .testMethod(&quot;testMethod&quot;)\n    .description(&quot;description&quot;)\n    .build();\n    TestCase testCase = testCaseRepository.save(tc);\n    \n        Iterator&lt;TestRegion&gt; iterator = regionRepository.findAll().iterator();\n        TestRegion region;\n        if (iterator.hasNext()) {\n          region = iterator.next();\n        } else {\n          region = TestRegion.builder().regionName(UUID.randomUUID().toString()).build();\n          regionRepository.save(region);\n        }\n        \n        TestCaseResult testCaseResult = resultRepository.findById(1);\n        \n        // Add an execution result\n        TestCaseExecutionResult request =\n            TestCaseExecutionResult.builder()\n                .testRegion(TestRegion.builder().id(region.getId()).build())\n                .testCase(TestCase.builder().id(testCase.getId()).build())\n                .testCaseResult(TestCaseResult.builder().id(testCaseResult.getId()).build())\n                .relatedJob(&quot;Dummy URL&quot;)\n                .build();\n        \n        this.restTemplate.getForEntity(\n            &quot;http://localhost:&quot; + port + Endpoints.EXECUTION_RESULTS_REGION,\n            TestCaseExecutionResult.class,\n            request.getTestCase().getId(),\n            request.getTestRegion().getId());\n        \n        assertTrue(Objects.requireNonNull(controller.findAll().getBody()).getContent().isEmpty());\n        \n        TestCaseExecutionResult testCaseExecutionResult =\n            this.restTemplate.postForObject(\n                &quot;http://localhost:&quot; + port + Endpoints.EXECUTION_RESULT_REGION,\n                request,\n                TestCaseExecutionResult.class,\n                request.getTestCase().getId(),\n                request.getTestRegion().getId(),\n                request.getTestCaseResult().getId());\n        \n        assertThat(testCaseExecutionResult).isNotNull();\n        assertThat(testCaseExecutionResult)\n            .usingRecursiveComparison()\n            .ignoringFields(\n                &quot;testCaseExecutionResultPK&quot;, &quot;date&quot;, &quot;testCase&quot;, &quot;testCaseResult&quot;, &quot;testRegion&quot;)\n            .isEqualTo(request);\n        \n        assertFalse(Objects.requireNonNull(controller.findAll().getBody()).getContent().isEmpty());\n        \n        assertFalse(\n            Objects.requireNonNull(\n                    controller\n                        .executionResultsForTestCaseInRegion(\n                            testCaseExecutionResult.getTestCase().getId(),\n                            testCaseExecutionResult.getTestRegion().getId())\n                        .getBody())\n                .getContent()\n                .isEmpty());\n        \n        ResponseEntity&lt;TestCaseExecutionResultWrapper&gt; response =\n            this.restTemplate.getForEntity(\n                &quot;http://localhost:&quot; + port + Endpoints.EXECUTION_RESULTS_REGION,\n                TestCaseExecutionResultWrapper.class,\n                request.getTestCase().getId(),\n                request.getTestRegion().getId());\n        \n        TestCaseExecutionResultWrapper wrapper = response.getBody();\n        assertNotNull(wrapper);\n        List&lt;TestCaseExecutionResult&gt; results = wrapper.getEmbedded().getTestCaseExecutionResults();\n        assertNotNull(results);\n        assertEquals(results.size(), 1);\n        \n        testCaseExecutionResult = results.get(0);\n        \n        // Delete it\n        this.restTemplate.delete(\n            &quot;http://localhost:&quot; + port + Endpoints.EXECUTION_RESULT_REGION_EXECUTION,\n            testCaseExecutionResult.getTestCaseExecutionResultPK().getTestCaseId(),\n            testCaseExecutionResult.getTestCaseExecutionResultPK().getTestRegionId(),\n            testCaseExecutionResult.getTestCaseExecutionResultPK().getTestCaseResultId(),\n            testCaseExecutionResult.getTestCaseExecutionResultPK().getId());\n        \n        response =\n            this.restTemplate.getForEntity(\n                &quot;http://localhost:&quot; + port + Endpoints.EXECUTION_RESULTS_REGION,\n                TestCaseExecutionResultWrapper.class,\n                request.getTestCase().getId(),\n                request.getTestRegion().getId());\n        \n        wrapper = response.getBody();\n        assertNotNull(wrapper);\n        results = wrapper.getEmbedded().getTestCaseExecutionResults();\n        assertNotNull(results);\n        if (!results.isEmpty()) {\n          ObjectMapper objectMapper = new ObjectMapper();\n          repository\n              .findAll()\n              .iterator()\n              .forEachRemaining(\n                  item -&gt; {\n                    try {\n                      String json =\n                          objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(item);\n                      log.info(json);\n                    } catch (JsonProcessingException e) {\n                      log.error(&quot;Error converting item to JSON&quot;, e);\n                    }\n                  });\n        }\n        assertEquals(results.size(), 0);\n    \n    }\n    }\n\n</code></pre>\n<p>I was expecting the deleted entity not to be found afterward. I have a zip file of the project I could share but I couldn't figure out how to share it.</p>\n<p><strong>Update</strong>\nI enabled the SQL in the settings and noticed that the delete query is never done:</p>\n<pre><code>Hibernate: select tcss1_0.id,tcss1_0.test_case_id,tcss1_0.test_region_id,tcss1_0.score,tcss1_0.stability,tc1_0.id,tc1_0.class_name,tc1_0.description,tc1_0.test_method,tc1_0.test_name,tcerl1_0.test_case_id,tcerl1_0.id,tcerl1_0.test_case_result_id,tcerl1_0.test_region_id,tcerl1_0.date,tcerl1_0.related_job,tcr1_0.id,tcr1_0.result,tr1_0.id,tr1_0.region_name,tr2_0.id,tr2_0.region_name from test_case_stability_status tcss1_0 join test_case tc1_0 on tc1_0.id=tcss1_0.test_case_id left join test_case_execution_result tcerl1_0 on tc1_0.id=tcerl1_0.test_case_id left join test_case_result tcr1_0 on tcr1_0.id=tcerl1_0.test_case_result_id left join test_region tr1_0 on tr1_0.id=tcerl1_0.test_region_id join test_region tr2_0 on tr2_0.id=tcss1_0.test_region_id where (tcss1_0.id,tcss1_0.test_case_id,tcss1_0.test_region_id) in ((?,?,?))\nHibernate: select tcssl1_0.test_case_id,tcssl1_0.id,tcssl1_0.test_region_id,tcssl1_0.score,tcssl1_0.stability,tr1_0.id,tr1_0.region_name from test_case_stability_status tcssl1_0 left join test_region tr1_0 on tr1_0.id=tcssl1_0.test_region_id where tcssl1_0.test_case_id=?\nHibernate: select tchil1_0.test_case_id,tchil1_0.issue_id,i1_0.id,i1_0.issue_reference,i1_0.issue_type_id,iti1_0.id,iti1_0.type from test_case_has_issue tchil1_0 left join issue i1_0 on i1_0.id=tchil1_0.issue_id left join issue_type iti1_0 on iti1_0.id=i1_0.issue_type_id where tchil1_0.test_case_id=?\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}