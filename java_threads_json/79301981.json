{
  "question": {
    "tags": [
      "python",
      "java",
      "android-studio",
      "bluetooth-lowenergy",
      "thermal-printer"
    ],
    "owner": {
      "account_id": 7041902,
      "reputation": 11,
      "user_id": 5394116,
      "user_type": "registered",
      "profile_image": "https://lh5.googleusercontent.com/-yZSGSuFBcls/AAAAAAAAAAI/AAAAAAAAAKA/R_GaHe5bJGc/s256-rj/photo.jpg",
      "display_name": "Amal Anjula",
      "link": "https://stackoverflow.com/users/5394116/amal-anjula"
    },
    "is_answered": false,
    "view_count": 328,
    "answer_count": 0,
    "score": 1,
    "last_activity_date": 1734918233,
    "creation_date": 1734918233,
    "question_id": 79301981,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79301981/mx11-cat-thermal-printer-android-sdk",
    "title": "MX11 cat thermal printer android SDK",
    "body": "<p>I have Python code that handles printing, and it works well. Now, I want to implement this functionality in an Android Studio Java project. To do this, I removed all the Bluetooth-related components from the Python code and integrated them into the Android project.now pythoncode only send printing body data packet to the main activity via pyObject</p>\n<p>I have analyzed the data packet used by the Python code for printing. The first six packets are for configuration, followed by a 56-byte chunk for the print body (a 1-bit BMP image). After that, additional command byte arrays are included.</p>\n<p>However, when I send these data packets from the Android script, the printer only feeds paper and does not print the image. I'm sending the data via Bluetooth Low Energy (BLE) by writing to the <code>PrinterCharacteristic</code>.\\</p>\n<pre><code>   private void runBackgroundTask( ) {\n        System.out.println(&quot;Task started in background: &quot; + Thread.currentThread());\n        try {\n            if (!Python.isStarted()) {\n                Python.start(new AndroidPlatform(getApplicationContext()));\n            }\n            Python python = Python.getInstance();\n            PyObject pythonModule = python.getModule(&quot;printJob&quot;);\n            PyObject rawResult = pythonModule.callAttr(&quot;makeByteArr&quot;);\n            String result = rawResult.toString().substring(1, rawResult.toString().length()  -1);\n            String[] dataBuff=result.split(&quot;,&quot;);\n            byte[][] dataPackets = {\n                    {81, 120, (byte) 163, 0, 1, 0, 0, 0, (byte) 255},  //dev status\n                    {81, 120, (byte) 164, 0, 1, 0, 51, (byte) 153, (byte) 255}, //dev status\n                    {81, 120, (byte) 166, 0, 11, 0, (byte) 170, 85, 23, 56, 68, 95, 95, 95, 68, 56, 44, (byte) 161, (byte) 255}, //ControlLattice\n                    {81, 120, (byte) 175, 0, 2, 0, (byte) 224, 46, (byte) 137, (byte) 255}, //ControlLattice\n                    {81, 120, (byte) 190, 0, 1, 0, 1, 7, (byte) 255}, //ControlLattice\n                    {81, 120, (byte) 189, 0, 1, 0, 35, (byte) 233, (byte) 255}, //ControlLattice\n                    {81, 120, (byte) 166, 0, 11, 0, (byte) 170, 85, 23, 0, 0, 0, 0, 0, 0, 0, 23, 17, (byte) 255}, //ControlLattice\n                    {81, 120, (byte) 189, 0, 1, 0, 25, 79, (byte) 255}, //ControlLattice\n                    {81, 120, (byte) 161, 0, 2, 0, 55, 0, (byte) 146, (byte) 255} //ControlLattice\n            };\n            byte packeyCount=0;\n            byte[] byteArray = new byte[56];\n           // Log.d(&quot;full&quot;,&quot;Len &quot;+byteArray.length+&quot; &quot; +packeyCount+&quot; &quot; );\n            for (byte[] packet : dataPackets) {\n                // Optionally add a delay if needed to avoid flooding the BLE stack\n                try {\n                   if (packeyCount++==6){\n                        int bitCount=0;\n                        int i=0;\n                        for (  i = 0; i &lt; dataBuff.length; i++) {\n                            int value = Integer.parseInt(dataBuff[i].trim()); // Convert string to integer\n                            byteArray[bitCount++] = (byte) value; // Convert integer to byte\n                            if (bitCount==56) {\n                                bitCount = 0;\n                                bluetoothHelper.sendData(byteArray);\n                               // Log.d(&quot;imgsend&quot;,&quot;Len &quot;+byteArray.length+&quot; &quot; +(i%256)+&quot; &quot;+ Arrays.toString(byteArray));\n                                Thread.sleep(5);\n                            }\n\n                        }\n                    }\n                    bluetoothHelper.sendData(packet);\n\n                    //Log.d(&quot;dsds&quot;,&quot;Len &quot;+packet.length+&quot; &quot; +packeyCount+&quot; &quot;+ Arrays.toString(packet));\n                    Thread.sleep(1); // 50 ms delay between packets\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    Log.d(&quot;Errorble&quot;,e.toString());\n                }\n            }\n \n            Thread.sleep(20); // Simulate background work\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            Log.d(&quot;Eror&quot;,e.toString());\n        }\n        System.out.println(&quot;Task completed.&quot;);\n    }\n</code></pre>\n<p>actual data packet</p>\n<pre><code>first command set\n0x51', '0x78', '0xa3', '0x00', '0x01', '0x00', '0x00', '0x00', '0xff', '    dev status\n0x51', '0x78', '0xa4', '0x00', '0x01', '0x00', '0x33', '0x99', '0xff', '    setqulty    \n0x51', '0x78', '0xa6', '0x00', '0x0b', '0x00', '0xaa', '0x55', '0x17', '0x38', '0x44', '0x5f', '0x5f', '0x5f', '0x44', '0x38', '0x2c', '0xa1', '0xff', ' ControlLattice\n0x51', '0x78', '0xaf', '0x00', '0x02', '0x00', '0xe0', '0x2e', '0x89', '0xff', ' SetEnergy\n0x51', '0x78', '0xbe', '0x00', '0x01', '0x00', '0x01', '0x07', '0xff', ' DrawingMode\n0x51', '0x78', '0xbd', '0x00', '0x01', '0x00', '0x23', '0xe9', '0xff', ' OtherFeedPaper\n// bmp message body data\n0x51', '0x78', '0xa2', '0x00', '0x30', '0x00', '0x00', '   '0x00', '0x1a', '0x00', '0xa0', '0x01', '0x00', '0x1a', '0x00', '0x00', '0x47', '0xff', '\n0x51', '0x78', '0xa2', '0x00', '0x30', '0x00', '0x00', ' 0x0a', '0x00', '0xa0', '0x00', '0x00', '0x0a', '0x00', '0x00', '0x42', '0xff', '\n0x51', '0x78', '0xa2', '0x00', '0x30', '0x00', '0x00', '0x00', '0x1e', '0x00', '0xe0', '0x01', '0x00', '0x1e', '0x00', '0x00', '0xc5', '0xff', '\n0x51', '0x78', '0xa2', '0x00', '0x30', '0x00', '0x00',  '0xa0', '0x00', '0x00', '0x0a', '0x00', '0x00', '0x42', '0xff', ' \nother command set\n0x51', '0x78', '0xa6',  '0x00', '0x00', '0x00', '0x00', '0x17', '0x11', '0xff', '  ControlLattice\n0x51', '0x78', '0xbd', '0x00', '0x01', '0x00', '0x19', '0x4f', '0xff', ' OtherFeedPaper\n0x51', '0x78', '0xa1', '0x00', '0x02', '0x00', '0x37', '0x00', '0x92', '0xff']  FeedPaper\n</code></pre>\n<p>python code block</p>\n<pre><code>#!/usr/bin/env python3\nimport os\nimport asyncio\nimport argparse\nimport time\nimport contextlib\n\n\nimport PIL.Image\nimport PIL.ImageFont\nimport PIL.ImageDraw\nimport PIL.ImageChops\nimport filetype\n\n# CRC8 table extracted from APK, pretty standard though\ncrc8_table = (\n    0x00, 0x07, 0x0e, 0x09, 0x1c, 0x1b, 0x12, 0x15, 0x38, 0x3f, 0x36, 0x31,\n    0x24, 0x23, 0x2a, 0x2d, 0x70, 0x77, 0x7e, 0x79, 0x6c, 0x6b, 0x62, 0x65,\n    0x48, 0x4f, 0x46, 0x41, 0x54, 0x53, 0x5a, 0x5d, 0xe0, 0xe7, 0xee, 0xe9,\n    0xfc, 0xfb, 0xf2, 0xf5, 0xd8, 0xdf, 0xd6, 0xd1, 0xc4, 0xc3, 0xca, 0xcd,\n    0x90, 0x97, 0x9e, 0x99, 0x8c, 0x8b, 0x82, 0x85, 0xa8, 0xaf, 0xa6, 0xa1,\n    0xb4, 0xb3, 0xba, 0xbd, 0xc7, 0xc0, 0xc9, 0xce, 0xdb, 0xdc, 0xd5, 0xd2,\n    0xff, 0xf8, 0xf1, 0xf6, 0xe3, 0xe4, 0xed, 0xea, 0xb7, 0xb0, 0xb9, 0xbe,\n    0xab, 0xac, 0xa5, 0xa2, 0x8f, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9d, 0x9a,\n    0x27, 0x20, 0x29, 0x2e, 0x3b, 0x3c, 0x35, 0x32, 0x1f, 0x18, 0x11, 0x16,\n    0x03, 0x04, 0x0d, 0x0a, 0x57, 0x50, 0x59, 0x5e, 0x4b, 0x4c, 0x45, 0x42,\n    0x6f, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7d, 0x7a, 0x89, 0x8e, 0x87, 0x80,\n    0x95, 0x92, 0x9b, 0x9c, 0xb1, 0xb6, 0xbf, 0xb8, 0xad, 0xaa, 0xa3, 0xa4,\n    0xf9, 0xfe, 0xf7, 0xf0, 0xe5, 0xe2, 0xeb, 0xec, 0xc1, 0xc6, 0xcf, 0xc8,\n    0xdd, 0xda, 0xd3, 0xd4, 0x69, 0x6e, 0x67, 0x60, 0x75, 0x72, 0x7b, 0x7c,\n    0x51, 0x56, 0x5f, 0x58, 0x4d, 0x4a, 0x43, 0x44, 0x19, 0x1e, 0x17, 0x10,\n    0x05, 0x02, 0x0b, 0x0c, 0x21, 0x26, 0x2f, 0x28, 0x3d, 0x3a, 0x33, 0x34,\n    0x4e, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5c, 0x5b, 0x76, 0x71, 0x78, 0x7f,\n    0x6a, 0x6d, 0x64, 0x63, 0x3e, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2c, 0x2b,\n    0x06, 0x01, 0x08, 0x0f, 0x1a, 0x1d, 0x14, 0x13, 0xae, 0xa9, 0xa0, 0xa7,\n    0xb2, 0xb5, 0xbc, 0xbb, 0x96, 0x91, 0x98, 0x9f, 0x8a, 0x8d, 0x84, 0x83,\n    0xde, 0xd9, 0xd0, 0xd7, 0xc2, 0xc5, 0xcc, 0xcb, 0xe6, 0xe1, 0xe8, 0xef,\n    0xfa, 0xfd, 0xf4, 0xf3\n)\n\n\ndef crc8(data):\n    crc = 0\n    for byte in data:\n        crc = crc8_table[(crc ^ byte) &amp; 0xFF]\n    return crc &amp; 0xFF\n\n\n# General message format:\n# Magic number: 2 bytes 0x51, 0x78\n# Command: 1 byte\n# 0x00\n# Data length: 1 byte\n# 0x00\n# Data: Data Length bytes\n# CRC8 of Data: 1 byte\n# 0xFF\ndef format_message(command, data):\n    data = [0x51, 0x78] + [command] + [0x00] + [len(data)] + [0x00] + data + [crc8(data)] + [0xFF]\n    return data\n\n\ndef printer_short(i):\n    return [i &amp; 0xFF, (i &gt;&gt; 8) &amp; 0xFF]\n\n\n# Commands\nRetractPaper = 0xA0  # Data: Number of steps to go back  160\nFeedPaper = 0xA1  # Data: Number of steps to go forward  161\nDrawBitmap = 0xA2  # Data: Line to draw. 0 bit -&gt; don't draw pixel, 1 bit -&gt; draw pixel 162\nGetDevState = 0xA3  # Data: 0 163\nControlLattice = 0xA6  # Data: Eleven bytes, all constants. One set used before printing, one after. 166\nGetDevInfo = 0xA8  # Data: 0  168\nOtherFeedPaper = 0xBD  # Data: one byte, set to a device-specific &quot;Speed&quot; value before printing\n#                              and to 0x19 before feeding blank paper  189\nDrawingMode = 0xBE  # Data: 1 for Text, 0 for Images  190\nSetEnergy = 0xAF  # Data: 1 - 0xFFFF  175\nSetQuality = 0xA4  # Data: 0x31 - 0x35. APK always sets 0x33 for GB01 164\n\nPrintLattice = [0xAA, 0x55, 0x17, 0x38, 0x44, 0x5F, 0x5F, 0x5F, 0x44, 0x38, 0x2C]\nFinishLattice = [0xAA, 0x55, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17]\nXOff = (0x51, 0x78, 0xAE, 0x01, 0x01, 0x00, 0x10, 0x70, 0xFF)\nXOn = (0x51, 0x78, 0xAE, 0x01, 0x01, 0x00, 0x00, 0x00, 0xFF)\n\nenergy = {\n    0: printer_short(8000),\n    1: printer_short(12000),\n    2: printer_short(17500)\n}\ncontrast = 1\n\nPrinterWidth = 384\n\nImgPrintSpeed = [0x23]\nBlankSpeed = [0x19]\n\nfeed_lines = 55\nheader_lines = 0\nscale_feed = False\n\ndefault_font_name = &quot;/data/data/com.ainven.farmman/files/chaquopy/fonts/iskpota.ttf&quot;\n\npacket_length = 60\nthrottle = 0.01\n\naddress = None\n\ndevice = None\n\n# show notification data\ndebug = False\n\n\n\n\n\n\nasync def connect_and_send(data_iter):\n\n    count=0\n\n    for data in data_iter:\n        count=0\n        sendBuf=[]\n        dataPacketLen = int(len(data)/255)\n        if (len(data)/255!=0):\n            dataPacketLen=dataPacketLen+1\n\n        return data\n\n\n\n\n\ndef request_status():\n    return format_message(GetDevState, [0x00])\n\n\ndef blank_paper(lines):\n    # Feed extra paper for image to be visible\n    blank_commands = format_message(OtherFeedPaper, BlankSpeed)\n    count = lines\n    while count:\n        feed = min(count, 0xFF)\n        blank_commands = blank_commands + format_message(FeedPaper, printer_short(feed))\n        count = count - feed\n    return blank_commands\n\n\ndef get_wrapped_text(text: str, font: PIL.ImageFont.ImageFont,\n                     line_length: int):\n    if font.getlength(text) &lt;= line_length:\n        return text\n\n    lines = ['']\n    for word in text.split():\n        line = f'{lines[-1]} {word}'.strip()\n        if font.getlength(line) &lt;= line_length:\n            lines[-1] = line\n        else:\n            lines.append(word)\n    return '\\n'.join(lines)\n\n\ndef trim(im):\n    bg = PIL.Image.new(im.mode, im.size, (255,255,255))\n    diff = PIL.ImageChops.difference(im, bg)\n    diff = PIL.ImageChops.add(diff, diff, 2.0)\n    bbox = diff.getbbox()\n    if bbox:\n        return im.crop((bbox[0],bbox[1],bbox[2],bbox[3]+10)) # don't cut off the end of the image\n\n\ndef convert_text_to_img(text: list[str], font_name=default_font_name, font_size=20):\n    img = PIL.Image.new('RGB', (PrinterWidth, 5000), color = (255, 255, 255))\n    font = PIL.ImageFont.truetype(font_name, font_size)\n\n    d = PIL.ImageDraw.Draw(img)\n    lines = []\n    for line in text:\n        lines.append(get_wrapped_text(line, font, PrinterWidth))\n    lines = &quot;\\n&quot;.join(lines)\n    lines = lines.replace(&quot;\\n\\n&quot;, &quot;\\n&quot;)\n    d.multiline_text((0,0), text, fill=(0,0,0), align=&quot;left&quot;, font=font, spacing=0)\n    return trim(img)\n\n\ndef render_image(img):\n    global header_lines\n    global feed_lines\n    cmdqueue = []\n    if img.width &gt; PrinterWidth:\n        # image is wider than printer resolution; scale it down proportionately\n        scale = PrinterWidth / img.width\n        if scale_feed:\n            header_lines = int(header_lines * scale)\n            feed_lines = int(feed_lines * scale)\n        img = img.resize((PrinterWidth, int(img.height * scale)))\n    if img.width &lt; (PrinterWidth // 2):\n        # scale up to largest whole multiple\n        scale = PrinterWidth // img.width\n        if scale_feed:\n            header_lines = int(header_lines * scale)\n            feed_lines = int(feed_lines * scale)\n        img = img.resize((img.width * scale, img.height * scale), resample=PIL.Image.NEAREST)\n    # convert image to black-and-white 1bpp color format\n    img = img.convert(&quot;RGB&quot;)\n    img = img.convert(&quot;1&quot;)\n    if img.width &lt; PrinterWidth:\n        # image is narrower than printer resolution\n        # pad it out with white pixels\n        pad_amount = (PrinterWidth - img.width) // 2\n        padded_image = PIL.Image.new(&quot;1&quot;, (PrinterWidth, img.height), 1)\n        padded_image.paste(img, box=(pad_amount, 0))\n        img = padded_image\n\n    if header_lines:\n        cmdqueue += blank_paper(header_lines)\n\n    for y in range(0, img.height):\n        bmp = []\n        bit = 0\n        # pack image data into 8 pixels per byte\n        for x in range(0, img.width):\n            if bit % 8 == 0:\n                bmp += [0x00]\n            bmp[int(bit / 8)] &gt;&gt;= 1\n            if not img.getpixel((x, y)):\n                bmp[int(bit / 8)] |= 0x80\n            else:\n                bmp[int(bit / 8)] |= 0\n\n            bit += 1\n\n        cmdqueue += format_message(DrawBitmap, bmp)\n\n    # finish the lattice, whatever that means\n    cmdqueue += format_message(ControlLattice, FinishLattice)\n\n    return cmdqueue\n\n\n\ndef produce_print_data(eject: bool, no_eject: bool, assume_text: bool, filename: str, ):\n    #print_data = request_status()\n    print_data=[]\n    if not eject:\n        image = convert_text_to_img(filename)\n\n        print_data = print_data + render_image(image)\n    if not no_eject:\n        print_data = print_data + blank_paper(feed_lines)\n    return print_data\ndef makeByteArr():\n    print_data = produce_print_data(\n        eject=False,\n        no_eject=False,\n        assume_text=True,\n        filename=&quot;******************\\namal&quot;,\n    )\n    return  print_data\n\n    #await client.write_gatt_char(PrinterCharacteristic, formatMessage(FeedPaper, [0, 1]))\n\nmakeByteArr()\n\n\n</code></pre>\n<p>i followed this steps</p>\n<p><a href=\"https://github.com/rbaron/catprinter\" rel=\"nofollow noreferrer\">text</a></p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}