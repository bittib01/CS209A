{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "authentication",
      "spring-security"
    ],
    "owner": {
      "account_id": 25906607,
      "reputation": 13,
      "user_id": 19631607,
      "user_type": "registered",
      "profile_image": "https://lh3.googleusercontent.com/a-/AFdZucrJQp2Yb9qyXPsbHrfyMtNYPsuzz5DcxnzL3rQM=k-s256",
      "display_name": "Osteen Omega",
      "link": "https://stackoverflow.com/users/19631607/osteen-omega"
    },
    "is_answered": true,
    "view_count": 352,
    "accepted_answer_id": 79458556,
    "answer_count": 1,
    "score": -1,
    "last_activity_date": 1740578717,
    "creation_date": 1740136990,
    "last_edit_date": 1740142272,
    "question_id": 79457222,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79457222/spring-boot-3-oauth2-github-login-email-attribute-returns-null-even-after-setti",
    "title": "Spring Boot 3 OAuth2 GitHub Login: Email Attribute Returns Null Even After Setting Scope and Public email",
    "body": "<p>I’m implementing OAuth2 login in my Spring Boot 3 application using GitHub as an authentication provider. However, I’m unable to retrieve the user's email from GitHub—it always returns null.\ni'm building a job board application and i want users to first register with email and password, or with github, and they'll be directed to the onboarding page where they'll input details such as usertype-recruiter or jobseeker etc.</p>\n<p>What I've Tried\nConfigured application.yml with the correct scope:</p>\n<pre class=\"lang-java prettyprint-override\"><code>yaml\nCopy\nEdit\nsecurity:\n  oauth2:\n    client:\n      registration:\n        github:\n          client-id: xxx\n          client-secret: xxx\n          redirect-uri: &quot;{baseUrl}/login/oauth2/code/{registrationId}&quot;\n          scope: user:email\n</code></pre>\n<p>Checked GitHub Profile Settings:</p>\n<p>My email is set to &quot;Public&quot; in GitHub.\nI've Logged OAuth2 Attributes:\nThe email field is missing (null), but other details like name and id are available.\nConfirmed GitHub Provides Email via API:</p>\n<p>My Questions\nWhy is GitHub’s OAuth2 response not including the email, even when my email is public?\nIs there a way to configure Spring Security to fetch the email directly, or do I need a separate API request?</p>\n<p>Here is how I've tried to fetch user details from the access token</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Service\n@RequiredArgsConstructor\npublic class CustomOauth2UserService extends DefaultOAuth2UserService {\n    private static final Logger log = LoggerFactory.getLogger(CustomOauth2UserService.class);\n    private final UserConnectedAccountRepository userConnectedAccountRepository;\n    private final UserRepository userRepository;\n\n    @Override\n    public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException {\n        OAuth2User oAuth2User = super.loadUser(userRequest);\n        String provider = userRequest.getClientRegistration().getRegistrationId();\n        String providerId = oAuth2User.getName();\n        String email = oAuth2User.getAttribute(&quot;email&quot;);\n        oAuth2User.getAttributes().forEach((key, value) -&gt; log.info(&quot;key {}, value {}&quot;, key, value));\n\n        Optional&lt;UserConnectedAccount&gt; userConnectedAccount = userConnectedAccountRepository.findByProviderIdAndProvider(providerId, provider);\n        if (userConnectedAccount.isEmpty()) {\n            userRepository.findUserByEmail(email)\n                    .ifPresentOrElse(user -&gt; connectAccount(providerId, provider, user),\n                            () -&gt; createUser(providerId, provider, oAuth2User)\n                    );\n        }\n        return new DefaultOAuth2User(\n                Collections.singleton(new SimpleGrantedAuthority(null)),\n                oAuth2User.getAttributes(),\n                &quot;email&quot;\n        );\n    }\n\n    public void createUser(String providerId, String provider, OAuth2User oAuth2User) {\n        AppUser appUser = new AppUser(oAuth2User);\n        appUser = userRepository.save(appUser);\n        connectAccount(providerId, provider, appUser);\n    }\n\n    private void connectAccount(String providerId, String provider, AppUser appUser) {\n        UserConnectedAccount newUserConnectedAccount = new UserConnectedAccount(providerId, provider, appUser);\n        userConnectedAccountRepository.save(newUserConnectedAccount);\n    }\n}\n</code></pre>\n<p>and here is my security configuration. I'm using session based authentication.</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Configuration\n@RequiredArgsConstructor\n@EnableWebSecurity\npublic class SecurityConfig {\n    private final UserService userService;\n    private final PasswordEncoder passwordEncoder;\n    private final GlobalAuthenticationEntryPoint globalAuthenticationEntryPoint;\n    private final Oauth2LoginSuccessHandler oauth2LoginSuccessHandler;\n    private final CustomOauth2UserService customOauth2UserService;\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n        http.authorizeHttpRequests(request -&gt; request\n                .requestMatchers(&quot;/api/v1/auth/**&quot;, &quot;/login/**&quot;, &quot;/**&quot;, &quot;/oauth2/authorization/**&quot;).permitAll()\n                .anyRequest().authenticated());\n        http.csrf(AbstractHttpConfigurer::disable)\n                .cors(AbstractHttpConfigurer::disable)\n                .oauth2Login(oauth2 -&gt; oauth2\n                        .userInfoEndpoint(userInfo -&gt; userInfo.userService(customOauth2UserService))\n                        .successHandler(oauth2LoginSuccessHandler)\n                );\n\n        http.exceptionHandling(customizer -&gt;\n                customizer.authenticationEntryPoint(globalAuthenticationEntryPoint)\n        );\n\n        return http.build();\n    }\n\n    @Bean\n    public AuthenticationManager authenticationManager() {\n        var authenticationProvider = new DaoAuthenticationProvider(passwordEncoder);\n        authenticationProvider.setUserDetailsService(userService);\n        return new ProviderManager(authenticationProvider);\n    }\n\n    @Bean\n    public SecurityContextRepository SecurityContextRepository() {\n        return new HttpSessionSecurityContextRepository();\n    }\n\n    @Bean\n    public SecurityContextLogoutHandler securityContextLogoutHandler() {\n        return new SecurityContextLogoutHandler();\n    }\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}