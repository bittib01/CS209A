{
  "question": {
    "tags": [
      "java",
      "couchbase",
      "couchbase-java-api"
    ],
    "owner": {
      "account_id": 5289146,
      "reputation": 9950,
      "user_id": 4222206,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/416696430ab23f397a5dbeda73e72896?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "queeg",
      "link": "https://stackoverflow.com/users/4222206/queeg"
    },
    "is_answered": true,
    "view_count": 180,
    "accepted_answer_id": 79755068,
    "answer_count": 2,
    "score": 0,
    "last_activity_date": 1758118959,
    "creation_date": 1756842523,
    "last_edit_date": 1758118938,
    "question_id": 79753892,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79753892/couchbase-client-fails-with-outofmemoryerror-on-too-many-waiting-threads",
    "title": "Couchbase client fails with OutOfMemoryError on too many waiting threads",
    "body": "<p>I have a Java batch application that performs several processing steps on a Couchbase bucket hosted in a single node cluster. The database is neither big nor required to be lightning fast, just about 500 MB of data.</p>\n<p>The different application components (<a href=\"https://www.baeldung.com/java-ee-7-batch-processing\" rel=\"nofollow noreferrer\">Java Batch</a> ItemReader, ItemProcessor or ItemWriter) connect to Couchbase each via the java-sdk. They do it in parallel or repeatedly, thus a single batch run results in many calls to <code>Cluster.connect()</code>.</p>\n<p>While this was running fine, since a week I perceive timeouts and OutOfMemoryErrors.</p>\n<pre><code>[16.081s][warning][os,thread] Failed to start thread &quot;Unknown thread&quot; - pthread_create failed (EAGAIN) for attributes: stacksize: 256k, guardsize: 4k, detached.\n[16.082s][warning][os,thread] Failed to start the native thread for java.lang.Thread &quot;boundedElastic-evictor-225&quot;\n13:11:59.543 [jberet-1] ERROR org.jberet - JBERET000007: Failed to run job createTickets, createTickets, org.jberet.job.model.Step@78739007\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\n    at java.base/java.lang.Thread.start0(Native Method) ~[?:?]\n    at java.base/java.lang.Thread.start(Unknown Source) [?:?]\n    at java.base/java.lang.System$2.start(Unknown Source) ~[?:?]\n    ...\n</code></pre>\n<p>Adding the JVM option <code>-XX:+HeapDumpOnOutOfMemoryError</code> does not trigger heap dumps. Increasing the heap did not help either but I discovered more than 2000 waiting threads before the error occurs. Almost all of the threads are related to the Couchbase connections. This limits my application in processing further data.</p>\n<p>I checked in the code that all the Couchbase connections get closed when no longer needed - yet the amount of threads remains and seems not to go away.</p>\n<p>There is <a href=\"https://dzone.com/articles/troubleshoot-outofmemoryerror-unable-to-create-new\" rel=\"nofollow noreferrer\">an article</a> that describes the symptom of OutOfMemoryError on the client side caused by resource constraints on the server side (Apache Cassandra NoSQL DB, in my case it is Couchbase). I checked the admin interface, but there is no indication of any problem.</p>\n<p>What can be the root cause for this behaviour? What should I look at to find out more?</p>\n<p>Threads analysis: Short before death the JVM was running 2073 threads. Removing trailing numbers from thread names, I find these counts:</p>\n<p><a href=\"https://i.sstatic.net/1Ky8yQQ3.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/1Ky8yQQ3.png\" alt=\"enter image description here\" /></a></p>\n<p>While investigating further I found JVMs with even more than 3000 threads before dying. From the thread dump I can see many threads are waiting for Couchbase Locks. Here is an example:</p>\n<pre><code>&quot;cb-txn-cleanup-230&quot; daemon prio=5 Id=2311 WAITING on java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject@1472208d\n&quot;cb-comp-994&quot; daemon prio=5 Id=2004 TIMED_WAITING on java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject@446e7065\n</code></pre>\n<p>Looks like I am facing a client-side deadlock.</p>\n<p><strong>Update:</strong>\nI suspect I ran into some special situation - not sure how to proove that.\nFor date handling we followed <a href=\"https://docs.couchbase.com/java-sdk/current/howtos/json.html#dates\" rel=\"nofollow noreferrer\">https://docs.couchbase.com/java-sdk/current/howtos/json.html#dates</a> which suggests to register your own ObjectMapper which has registered the JavaTimeModule. This is shown in <a href=\"https://docs.couchbase.com/java-sdk/current/howtos/json.html#ObjectMapper\" rel=\"nofollow noreferrer\">https://docs.couchbase.com/java-sdk/current/howtos/json.html#ObjectMapper</a>, which creates it's own ClusterEnvironment.</p>\n<p><a href=\"https://i.sstatic.net/825Ng9MT.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/825Ng9MT.png\" alt=\"enter image description here\" /></a></p>\n<p>But then here - out of context for the problem we tried to solve - you see a warning that resources might not get cleaned up if you create your own environment: <a href=\"https://docs.couchbase.com/java-sdk/current/howtos/managing-connections.html#multiple-clusters\" rel=\"nofollow noreferrer\">https://docs.couchbase.com/java-sdk/current/howtos/managing-connections.html#multiple-clusters</a></p>\n<p><a href=\"https://i.sstatic.net/Kj8DfMGy.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/Kj8DfMGy.png\" alt=\"enter image description here\" /></a></p>\n<p><strong>Update 2</strong></p>\n<p>So many people asked for code to analyze. Now, knowing what to look for I recreated the problem. Here is the code:</p>\n<pre><code>import com.couchbase.client.java.Cluster;\nimport com.couchbase.client.java.ClusterOptions;\nimport com.couchbase.client.java.codec.JacksonJsonSerializer;\nimport com.couchbase.client.java.env.ClusterEnvironment;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;\nimport java.lang.management.ManagementFactory;\nimport java.time.Duration;\nimport java.time.temporal.ChronoUnit;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\npublic class CouchbaseProblem {\n  private static final Logger log = LogManager.getLogger();\n  \n  public static Cluster connectSimple(String connectionString, String username, String password) {\n    return Cluster.connect(connectionString, username, password);\n  }\n\n  public static Cluster connectWithEnv(String connectionString, String username, String password) {\n    ObjectMapper mapper = new ObjectMapper();\n    mapper.registerModule(new JavaTimeModule());\n\n    ClusterEnvironment environment = ClusterEnvironment.builder()\n            .jsonSerializer(JacksonJsonSerializer.create(mapper))\n            .build();\n    ClusterOptions co = ClusterOptions.clusterOptions(username, password);\n    co.environment(environment);\n    return Cluster.connect(connectionString, co);\n  }\n  \n  public static int getThreadCount() {\n    return ManagementFactory.getThreadMXBean().getThreadCount();\n  }\n\n  public static void main(String[] args) throws Exception {\n    int max = 100;\n    \n    for (int i = 0; i &lt; max; i++) {\n      log.info(&quot;Simple Iteration {}/{}, Threads {}&quot;, i, max, getThreadCount());\n      \n      Cluster c = connectSimple(args[0], args[1], args[2]);\n      Thread.sleep(Duration.of(1, ChronoUnit.SECONDS));\n      c.disconnect();\n    }\n    \n    for (int i = 0; i &lt; max; i++) {\n      log.info(&quot;Env Iteration {}/{}, Threads {}&quot;, i, max, getThreadCount());\n      \n      Cluster c = connectWithEnv(args[0], args[1], args[2]);\n      Thread.sleep(Duration.of(1, ChronoUnit.SECONDS));\n      c.disconnect();\n    }\n  }\n}\n</code></pre>\n<p>You can see two loops, each of them creating and closing Couchbase connections. While running they log the iteration and the number of threads the JVM needs to care about.</p>\n<p>You can see the first loop's threadcount is growing but then levels off at 40, but the second loop's threadcount continually grows to over 2200.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}