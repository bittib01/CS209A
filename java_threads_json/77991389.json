{
  "question": {
    "tags": [
      "java",
      "arraylist",
      "hashmap"
    ],
    "owner": {
      "account_id": 30504030,
      "reputation": 33,
      "user_id": 23376115,
      "user_type": "registered",
      "profile_image": "https://i.sstatic.net/fNrQ2.jpg?s=256",
      "display_name": "Cloud",
      "link": "https://stackoverflow.com/users/23376115/cloud"
    },
    "is_answered": false,
    "view_count": 182,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1734951340,
    "creation_date": 1707866690,
    "last_edit_date": 1707867012,
    "question_id": 77991389,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/77991389/resizing-the-array-for-a-hash-map",
    "title": "Resizing the array for a hash map",
    "body": "<p>I'm having problems with resizing the array of a hash map for a Data Structures and Algorithms HW assignment. Here are the instructions:</p>\n<blockquote>\n<p>If adding to the table would cause the load factor (LF) to exceed (i.e. greater than, not greater than or equal to) the max load factor constant provided in the java file, the table should be resized to have a capacity of <em>2n + 1.</em></p>\n</blockquote>\n<p>I'm trying to resize it to 2n+1, where n is the original array size. But it doesn't seem to work for some reason? Whenever I test it, the array never resizes like I want it to.</p>\n<p>I believe the problem may lie within one of these pieces of code:</p>\n<ol>\n<li><p>The placement of this method being called within the put method:</p>\n<pre><code>if ((countEntries(table)) / table.length &gt; MAX_LOAD_FACTOR) {\n    resizeBackingTable(table.length);\n}\n</code></pre>\n</li>\n<li><p>Or the code inside the resizeBackingTable method itself.</p>\n<pre><code>private void resizeBackingTable(int length) {\n   // WRITE YOUR CODE HERE (DO NOT MODIFY METHOD HEADER)!\n   ExternalChainingMapEntry&lt;K, V&gt;[] newBackingArray = (ExternalChainingMapEntry&lt;K, V&gt;[]) new ExternalChainingMapEntry[2 * length + 1];\n\n   for (ExternalChainingMapEntry&lt;K, V&gt; entry : table) {\n      while (entry != null) {\n         int hash = calculateHash(entry.getKey(), newBackingArray.length);\n\n         ExternalChainingMapEntry&lt;K, V&gt; next = entry.getNext();\n\n         entry.setNext(newBackingArray[hash]);\n         newBackingArray[hash] = entry;\n\n         entry = next;\n      }\n   }\n   table = newBackingArray;\n}\n</code></pre>\n</li>\n</ol>\n<p>Here's the entire code, sorry if it looks kind of messy.</p>\n<pre><code>import java.util.NoSuchElementException;\n\n/**\n * Your implementation of a ExternalChainingHashMap.\n */\npublic class ExternalChainingHashMap&lt;K, V&gt; {\n\n    /*\n     * The initial capacity of the ExternalChainingHashMap when created with the\n     * default constructor.\n     *\n     * DO NOT MODIFY THIS VARIABLE!\n     */\n    public static final int INITIAL_CAPACITY = 13;\n\n    /*\n     * The max load factor of the ExternalChainingHashMap.\n     *\n     * DO NOT MODIFY THIS VARIABLE!\n     */\n    public static final double MAX_LOAD_FACTOR = 0.67;\n\n    /*\n     * Do not add new instance variables or modify existing ones.\n     */\n    private ExternalChainingMapEntry&lt;K, V&gt;[] table;\n    private int size;\n\n    /**\n     * Constructs a new ExternalChainingHashMap with an initial capacity of INITIAL_CAPACITY.\n     */\n    public ExternalChainingHashMap() {\n        //DO NOT MODIFY THIS METHOD!\n        table = (ExternalChainingMapEntry&lt;K, V&gt;[]) new ExternalChainingMapEntry[INITIAL_CAPACITY];\n    }\n\n    /**\n     * Adds the given key-value pair to the map. If an entry in the map\n     * already has this key, replace the entry's value with the new one\n     * passed in.\n     *\n     * In the case of a collision, use external chaining as your resolution\n     * strategy. Add new entries to the front of an existing chain, but don't\n     * forget to check the entire chain for duplicate keys first.\n     *\n     * If you find a duplicate key, then replace the entry's value with the new\n     * one passed in. When replacing the old value, replace it at that position\n     * in the chain, not by creating a new entry and adding it to the front.\n     *\n     * Before actually adding any data to the HashMap, you should check to\n     * see if the table would violate the max load factor if the data was\n     * added. Resize if the load factor (LF) is greater than max LF (it is\n     * okay if the load factor is equal to max LF). For example, let's say\n     * the table is of length 5 and the current size is 3 (LF = 0.6). For\n     * this example, assume that no elements are removed in between steps.\n     * If another entry is attempted to be added, before doing anything else,\n     * you should check whether (3 + 1) / 5 = 0.8 is larger than the max LF.\n     * It is, so you would trigger a resize before you even attempt to add\n     * the data or figure out if it's a duplicate. Be careful to consider the\n     * differences between integer and double division when calculating load\n     * factor.\n     *\n     * When regrowing, resize the length of the backing table to\n     * (2 * old length) + 1. You should use the resizeBackingTable method to do so.\n     *\n     * @param key   The key to add.\n     * @param value The value to add.\n     * @return null if the key was not already in the map. If it was in the\n     *         map, return the old value associated with it.\n     * @throws java.lang.IllegalArgumentException If key or value is null.\n     */\n   public V put(K key, V value) {\n      // WRITE YOUR CODE HERE (DO NOT MODIFY METHOD HEADER)!\n        \n      int hash = calculateHash(key, table.length);\n\n      // Create a new node with the new key-value pair\n      ExternalChainingMapEntry&lt;K, V&gt; newNode = new ExternalChainingMapEntry&lt;&gt;(key, value);\n\n      // Check if the linked list at the given index is null\n      if (table[hash] == null) {\n         // If it's null, instantiate a new ExternalChainingMapEntry to represent the head\n         table[hash] = newNode;\n         size++;\n         \n         if ((countEntries(table)) / table.length &gt; MAX_LOAD_FACTOR) {\n            resizeBackingTable(table.length);\n         }\n         return null;\n      }\n      \n         // Search through the linked list to find if the key already exists\n      ExternalChainingMapEntry&lt;K, V&gt; current = table[hash];\n      while (current != null) {\n         if (current.getKey().equals(key)) {\n         // If the key already exists, replace the old value with the new value\n         current.setValue(value);\n         return null; // Key found and replaced, exit the entire method\n         }\n         current = current.getNext();\n      }\n         \n      // Sets the &quot;next&quot; reference of the newNode to be the current head of the linked list at the specified index (table[hash]).\n      // It's saying, &quot;the next element after this new node is the current head of the list.&quot;\n      // This way, you are linking the new node to the existing elements in the list.\n      newNode.setNext(table[hash]);\n\n      // Set the new node as the new head of the linked list at the specified index\n      table[hash] = newNode;\n      size++;\n      if ((countEntries(table)) / table.length &gt; MAX_LOAD_FACTOR) {\n         resizeBackingTable(table.length);\n      }\n      return null;\n   }\n\n    /**\n     * Removes the entry with a matching key from the map.\n     *\n     * @param key The key to remove.\n     * @return The value associated with the key.\n     * @throws java.lang.IllegalArgumentException If key is null.\n     * @throws java.util.NoSuchElementException   If the key is not in the map.\n     */\n   public V remove(K key) {\n      // WRITE YOUR CODE HERE (DO NOT MODIFY METHOD HEADER)!\n      if (key == null) {\n         throw new IllegalArgumentException(&quot;Error: key is null&quot;);\n      }\n      \n      int hash = calculateHash(key, table.length);\n        \n      if(table[hash] == null) {\n         throw new NoSuchElementException(&quot;Error: entry is empty&quot;);\n      }\n      \n      ExternalChainingMapEntry&lt;K, V&gt; current = table[hash];\n      ExternalChainingMapEntry&lt;K, V&gt; prev = null;\n      \n      while (current != null &amp;&amp; !current.getKey().equals(key)) {\n         prev = current;\n         current = current.getNext();\n      }\n\n      if (current == null) {\n         throw new NoSuchElementException(&quot;Error: key not found&quot;);\n      }\n\n      V removedValue = current.getValue();\n\n      if (prev == null) {\n         // If the entry to be removed is the head of the linked list\n         table[hash] = current.getNext();\n      } else {\n         // If the entry to be removed is not the head of the linked list\n         prev.setNext(current.getNext());\n      }\n\n      size--; // Decrement size when removing an entry\n\n      return removedValue;\n   }\n\n    /**\n     * Helper method stub for resizing the backing table to length.\n     *\n     * This method should be called in put() if the backing table needs to\n     * be resized.\n     *\n     * You should iterate over the old table in order of increasing hash and\n     * add entries to the new table in the order in which they are traversed.\n     *\n     * Since resizing the backing table is working with the non-duplicate\n     * data already in the table, you won't need to explicitly check for\n     * duplicates.\n     *\n     * Hint: You cannot just simply copy the entries over to the new table.\n     *\n     * @param Length The new length of the backing table.\n     */\n    private void resizeBackingTable(int length) {\n        // WRITE YOUR CODE HERE (DO NOT MODIFY METHOD HEADER)!\n        ExternalChainingMapEntry&lt;K, V&gt;[] newBackingArray = (ExternalChainingMapEntry&lt;K, V&gt;[]) new ExternalChainingMapEntry[2 * length + 1];\n        \n        for (ExternalChainingMapEntry&lt;K, V&gt; entry : table) {\n            while (entry != null) {\n               int hash = calculateHash(entry.getKey(), newBackingArray.length);\n               \n               ExternalChainingMapEntry&lt;K, V&gt; next = entry.getNext();\n\n               entry.setNext(newBackingArray[hash]);\n               newBackingArray[hash] = entry;\n\n               entry = next;\n            }\n        }\n        table = newBackingArray;\n    }\n    \n    //The hash function\n    private int calculateHash(K key, int array) {\n         if (key == null) {\n            throw new IllegalArgumentException(&quot;Error: key is null&quot;);\n         }\n         \n         int hash = Math.abs(key.hashCode() % array);\n         return hash;\n    }\n    \n    //Counts number of non-null entries in an array\n    private int countEntries(ExternalChainingMapEntry&lt;K, V&gt;[] table) {\n         int count = 0;\n         for (int i = 0; i &lt; table.length; i++) {\n            if (table[i] != null) {\n               count++;\n            }\n         } \n         return count;\n    }\n\n    /**\n     * Returns the table of the map.\n     *\n     * For grading purposes only. You shouldn't need to use this method since\n     * you have direct access to the variable.\n     *\n     * @return The table of the map.\n     */\n    public ExternalChainingMapEntry&lt;K, V&gt;[] getTable() {\n        // DO NOT MODIFY THIS METHOD!\n        return table;\n    }\n\n    /**\n     * Returns the size of the map.\n     *\n     * For grading purposes only. You shouldn't need to use this method since\n     * you have direct access to the variable.\n     *\n     * @return The size of the map.\n     */\n\n    public int size() {\n        // DO NOT MODIFY THIS METHOD!\n        return size;\n    }\n}\n</code></pre>\n<p>I tried placing the call to the resizeBackingTable in different places but it didn't seem to have an effect. I already had placed it at the very beginning of the put method too but that didn't have an effect either.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}