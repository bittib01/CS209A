{
  "question": {
    "tags": [
      "java",
      "recursion",
      "binary-tree"
    ],
    "owner": {
      "account_id": 45012655,
      "reputation": 86,
      "user_id": 32053083,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/299ec5f93e1efb0942f01a942b020612?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "sunmicrosystemsfan101",
      "link": "https://stackoverflow.com/users/32053083/sunmicrosystemsfan101"
    },
    "is_answered": true,
    "view_count": 182,
    "accepted_answer_id": 79847826,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1765815019,
    "creation_date": 1765754354,
    "question_id": 79847295,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79847295/stuck-on-recursive-state-design-for-a-zigzag-alternating-sum-path-in-a-binary-tr",
    "title": "Stuck on Recursive State Design for a Zigzag Alternating-Sum Path in a Binary Tree",
    "body": "<p>I’m trying to reason about a recursive algorithm on trees and I feel like I’m missing something subtle.</p>\n<p>I have an immutable binary tree (not a BST) where each node has an <code>int value</code>. I want to compute the maximum alternating-sum zigzag path anywhere in the tree. A path is any downward path (start at any node, go only to children). The path must strictly alternate left/right at each step. The sum alternates signs starting with <code>+</code> at the starting node: <code>+v0 − v1 + v2 − v3 …</code>. Single-node paths are allowed.</p>\n<p>Here’s the code I <em>thought</em> should work, but it fails on some cases with negative values and when the best path doesn’t start at the root.</p>\n<pre><code>int maxZigZagSum(Node root) {\n    return helper(root, true, 0);\n}\n\nint helper(Node node, boolean goLeft, int sign) {\n    if (node == null) return 0;\n\n    int cur = (sign == 0 ? node.val : -node.val);\n\n    int next;\n    if (goLeft) {\n        next = helper(node.left, false, 1 - sign);\n    } else {\n        next = helper(node.right, true, 1 - sign);\n    }\n\n    return Math.max(cur, cur + next);\n}\n</code></pre>\n<p>I tried calling <code>helper</code> twice at the root (once starting left, once right), but that still doesn’t fix all cases. Intuitively, I feel like I need to track <em>both</em> “last direction” and “parity of the sum”, but whenever I add more parameters the recursion explodes and I can’t keep it O(n). I also don’t see how to handle paths that start in the middle of the tree without restarting recursion from every node, which would be O(n²).</p>\n<p>What minimal information needs to be returned from each recursive call so that the parent can combine results correctly? How do you structure the recursion so that paths can start at any node, but you still only traverse the tree once? Why doesn’t the “return the best path starting here” approach work without additional state?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}