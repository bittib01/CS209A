{
  "question": {
    "tags": [
      "java",
      "swt"
    ],
    "owner": {
      "account_id": 30510250,
      "reputation": 13,
      "user_id": 23381600,
      "user_type": "registered",
      "profile_image": "https://lh3.googleusercontent.com/a/ACg8ocKRKiDHrdJIVuVsNpgebdiJR6-LBYwPGuV3d8DlXCeU=k-s256",
      "display_name": "user23381600",
      "link": "https://stackoverflow.com/users/23381600/user23381600"
    },
    "is_answered": false,
    "view_count": 44,
    "answer_count": 0,
    "score": 1,
    "last_activity_date": 1740241590,
    "creation_date": 1740241590,
    "question_id": 79459916,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79459916/how-to-use-swt-to-create-a-console-and-avoid-thread-blocking-and-program-crash",
    "title": "How to use SWT to create a console and avoid thread blocking and program crash?",
    "body": "<p>I used SWT to make a Java desktop application, and used StyledText as the console.\nFor ease of operation, I encapsulated it into a category.</p>\n<pre><code>public class Console {\n    \n    private static StyledText console;\n    \n    public static void init(StyledText styledText) {\n        console = styledText;\n    }\n     \n    // red text\n    public static void err(String message) {\n        if (console != null) {\n            setConsoleMessage(message, SWT.COLOR_RED);\n        }\n    }\n\n    // black text\n    public static void out(String message) {\n        if (console != null) {\n            setConsoleMessage(message, SWT.COLOR_BLACK);\n        }\n    }\n    \n    private static void setConsoleMessage(String message, int color) {\n        \n        if (Display.getCurrent() == null) {\n            Display.getDefault().asyncExec(() -&gt; updateConsole(message, color));\n        } else {\n            \n            updateConsole(message, color);\n        }\n    }\n    \n    private static void updateConsole(String message, int color) {\n        Display display = Display.getCurrent();\n        if (display != null &amp;&amp; console != null) {\n            console.setForeground(display.getSystemColor(color));\n            console.append(message);\n            console.setCaretOffset(console.getText().length());\n            console.setTopIndex(console.getLineCount() - 1);\n        }\n    }\n\n}\n</code></pre>\n<p>There are currently several operational problems.\nBecause my program uses multiple threads to download data, when I want to output the download information, it will cause the thread to be blocked and may cause the program to crash.</p>\n<pre><code> Path outputPath = Paths.get(outputPathString);\n            \n            if (!Files.exists(outputPath)) {\n                try {Director\n                    // If the directory does not exist, create it\n                    Files.createDirectories(outputPath); \n                    Console.out(&quot;Output folder created successfully: &quot; +     outputPath.toString() + &quot;\\n&quot;);\n                } catch (IOException ex) {\n                    Console.err(&quot;Error creating folder: &quot; + ex.getMessage() + &quot;\\n&quot;);\n                    return;\n                }\n            }\n            \n            Console.out(&quot;start download...&quot; + System.lineSeparator());\n\n            /* \n             * Before adding the following method, the message of starting the download will \n             * not be displayed immediately, but will appear after the download is complete.\n             */\n\n            Display.getDefault().update();\n            stopButton.setEnabled(false);\n            startButton.setEnabled(true);\n            \n            List&lt;ImgData&gt; imgDatas = new ArrayList&lt;&gt;();\n            \n            if(selectedIndex == 0) {\n                imgDatas = dataProcessedService.htmlParser(selectedFile, outputPath);\n            } else if (selectedIndex == 2) {                \n                imgDatas = dataProcessedService.txtParser(selectedFile, outputPath);\n            } else if(selectedIndex == 3) {\n                boolean isThumbnailChecked = checkBox1.getSelection();\n                boolean isFileNameChecked = checkBox2.getSelection();      \n                Map&lt;String, Boolean&gt; method = new HashMap&lt;&gt;();\n                method.put(&quot;Thumbnail&quot;, isThumbnailChecked);\n                method.put(&quot;FileName&quot;, isFileNameChecked);\n                boolean isFinish = false;\n                isFinish = playListService.handlePlaylistJson(selectedFile, outputPath, method,\n                        executorService, isStop);\n                stopButton.setEnabled(!isFinish);\n                startButton.setEnabled(isFinish);\n                return;\n            }\n            \n            handleProcessedFormat(imgDatas, new TaskCompletionCallback() {\n                @Override\n                public void onTaskCompleted() {\n                    \n                    Display.getDefault().asyncExec(() -&gt; {\n                        startButton.setEnabled(true);\n                        stopButton.setEnabled(false);\n                    });\n                }\n            });\n</code></pre>\n<pre><code>protected static void handleProcessedFormat(List&lt;ImgData&gt; imgDatas, TaskCompletionCallback callback) {\n        \n        AtomicLong successCount = new AtomicLong(0);\n        AtomicLong failureCount = new AtomicLong(0);\n        \n        CountDownLatch latch = new CountDownLatch(imgDatas.size());\n        \n        for (ImgData imgData : imgDatas) {\n            \n            if (isStop.get()) {\n                latch.countDown();\n                continue;\n            }\n            \n            executorService.submit(() -&gt; {\n                boolean success = downloadService.downloadAndSaveImage(imgData);\n\n                if (success) {\n                    successCount.incrementAndGet();\n                } else {\n                    failureCount.incrementAndGet();\n                }\n\n                latch.countDown();\n            });\n            \n        }\n        \n        \n        executorService.submit(() -&gt; {\n            try {\n                latch.await();\n            } catch (InterruptedException e) {\n                Console.err(&quot;Thread Wait Error&quot; + e);\n            }\n\n            long success = successCount.get();\n            long failure = failureCount.get();\n\n            Display.getDefault().asyncExec(() -&gt; {\n                Console.out(String.format(&quot;Successful: %d, Failed: %d%n&quot;, success, failure));\n                if (callback != null) {\n                    callback.onTaskCompleted();\n                }\n            });\n        });\n        \n    }\n</code></pre>\n<pre><code>public boolean downloadAndSaveImage(ImgData imgData) {\n        \n        Path filePath = imgData.getFilePath();\n        URL srcUrl = imgData.getSrc();\n        \n\n        Console.out(String.format(&quot;%s is %s%n&quot;, \n                filePath.getFileName(), attemptDownload(filePath, srcUrl) ? &quot;Successful&quot; : &quot;Failed&quot;));\n        \n        return true;\n    }\n</code></pre>\n<p>Methods tried so far</p>\n<ol>\n<li><p>Create a cache method in the Console to output content at a fixed time.\nThis method will also cause the program to stop responding until the download is complete and then output all the information at once.</p>\n</li>\n<li><p>Change asyncExec to syncExec\nIt doesn't help much with thread blocking and can cause messages to be lost.</p>\n</li>\n</ol>\n<p>Should I try to modify the multi-threaded download part or find another way to control the console output?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}