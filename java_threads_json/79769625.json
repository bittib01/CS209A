{
  "question": {
    "tags": [
      "java",
      "spring",
      "hibernate",
      "optimistic-locking"
    ],
    "owner": {
      "account_id": 17750,
      "reputation": 27260,
      "user_id": 40064,
      "user_type": "registered",
      "accept_rate": 69,
      "profile_image": "https://www.gravatar.com/avatar/6f118f710d3077f91c0c0d722f7be0a3?s=256&d=identicon&r=PG",
      "display_name": "Wim Deblauwe",
      "link": "https://stackoverflow.com/users/40064/wim-deblauwe"
    },
    "is_answered": true,
    "view_count": 243,
    "accepted_answer_id": 79769710,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1758520264,
    "creation_date": 1758291627,
    "last_edit_date": 1758520264,
    "question_id": 79769625,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79769625/how-to-correctly-handle-optimistic-locking-with-spring-data-jpa-and-rest-api",
    "title": "How to correctly handle optimistic locking with Spring Data JPA and REST API",
    "body": "<p>I am using Spring Boot 3.5 and have added an <code>@Version</code> field to my entity. This all works fine, but I wonder how I need to handle concurrent updates coming from the REST API.</p>\n<p>Suppose 2 users have my web app open. They both see version 1 of my entity.</p>\n<p>The first user saves and the version is updated in the database. After a minute or so, the 2nd user saves his changes. I want to return a 409 Conflict at that point.</p>\n<p>The saving itself is done in a use case like this:</p>\n<pre><code>@Component\n@Transactional\nclass UpdateMyEntity {\n\n  private final MyEntityRepository repo;\n\n  public UpdateMyEntity(MyEntityRepository repo) {\n    this.repo = repo;\n  }\n\n  public MyEntity execute(MyEntityUpdateParameters parameters) {\n    MyEntity item = repo.findById(parameters.id()).orElseThrow();\n\n    item.setName(parameters.name());\n\n    return repo.save(item);\n}\n</code></pre>\n<p>At first, I tried to set the version on the <code>MyEntity</code>, but JPA/Hibernate does not take that into account.</p>\n<p>Should I manually check the version that the frontend sends me back through the rest api in my use case? Or is there a way to have the database or JPA handle this?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}