{
  "question": {
    "tags": [
      "java",
      "json",
      "jackson",
      "deserialization"
    ],
    "owner": {
      "account_id": 11512926,
      "reputation": 125,
      "user_id": 10560184,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/3399de3e1ec229ab54f7a9926b6a35b8?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Andorrax",
      "link": "https://stackoverflow.com/users/10560184/andorrax"
    },
    "is_answered": true,
    "view_count": 241,
    "accepted_answer_id": 79718467,
    "answer_count": 2,
    "score": 2,
    "last_activity_date": 1753785624,
    "creation_date": 1752928427,
    "last_edit_date": 1753785507,
    "question_id": 79707238,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79707238/jackson-custom-deserialization-deserialize-into-known-object-instance-without",
    "title": "Jackson Custom Deserialization - deserialize into known object instance WITHOUT JsonTypeInfo annotations or Mixins",
    "body": "<p>I have a class <code>BaseClass</code> that during runtime will store a reference to another object <code>Thing</code>. <code>BaseClass</code> is meant to be extensible so I've made it abstract like so:</p>\n<pre class=\"lang-java prettyprint-override\"><code>abstract class BaseClass{\n    // see explanation for annotations below\n    @JsonIgnore private final Thing storedThing;\n    @JsonProperty private final String thingId;\n    protected BaseClass(){}  // empty constructor\n    protected BaseClass(Thing thing){\n      // store thing\n    }\n    // other stuff\n  }\n</code></pre>\n<p><code>Thing</code> is polymorphic and has a LOT of data. So for serialization/deserialization, I'm looking to only store the id of <code>Thing</code> instead of the whole object (this is a hard requirement). So if we have a class <code>SomeClass</code> implementing <code>BaseClass</code>, its json might look like so:</p>\n<pre class=\"lang-json prettyprint-override\"><code>// SomeClass extends BaseClass\n&quot;SomeClass&quot;:{\n  &quot;thingId&quot; : &quot;ahbjhadbv&quot; // target id of stored Thing. All other info is ignored\n}\n</code></pre>\n<p>The intent being that during deserialization I can look up the actual <code>Thing</code> instance using the id (<code>Thing</code> is stored elsewhere and can be queried) and put that back in.</p>\n<p>Implementors of <code>BaseClass</code> are also free to add any state data to their implementations should they want. E.g. <code>SomeOtherClass</code> which implements <code>BaseClass</code> could look like so:</p>\n<pre class=\"lang-json prettyprint-override\"><code>// SomeOtherClassextends BaseClass\n&quot;SomeOtherClass&quot;:{\n  &quot;thingId&quot; : &quot;asdawetgvd&quot; // target id of stored Thing. All other info is ignored\n  &quot;someOtherData&quot;: {...}\n  &quot;evenMoreData&quot; : {...}\n}\n</code></pre>\n<p>Implementing serialization to suit my needs was simple enough with Jackson.</p>\n<p>Now the annoying/interesting bit - for reasons I can't go into, I am hamstrung with these constraints:</p>\n<ul>\n<li>I cannot use mixins/<code>@JsonTypeInfo</code>/ <code>@JsonSubTypes</code> annotations.</li>\n<li>I cannot provide a multi-argument constructor for both <code>Thing</code> and <code>ThingId</code> on <code>BaseClass</code>.</li>\n<li>Even if I do push back on the constructors, I have no guarantees that implementors of <code>BaseClass</code> will implement the multi-argument constructor</li>\n<li>I cannot assume that the impelemtors of <code>BaseClass</code> will all implement an empty constructor.</li>\n<li>names of state data fields as defined in derived classes might not align with the names in their serialized counterparts because implementors can <code>@JsonProperty()</code> and define a different name</li>\n</ul>\n<p>I do, however, have assurances that all derived classes will implement at least one of the two provided constructors in <code>BaseClass</code>. I will also have knowledge of the class type that extends <code>BaseClass</code>. Finally, I am also assured that objects will be serialized and deserialized within the same runtime (so if I store any params during serialization, they can be available for use during deserialization)</p>\n<p>Knowing this, I decided to create my own custom deserializer - a part of which is shown below:</p>\n<pre class=\"lang-java prettyprint-override\"><code>\n    // Clazz is known beforehand\n    &lt;T extends BaseClass&gt; T deserialize(Class&lt;T&gt; clazz, JsonNode serializedData){\n        // implementors are guaranteed to use one of the two available constructors from the base class.\n\n        boolean hasEmptyConstructor = Arrays.stream(clazz.getDeclaredConstructors()).anyMatch(x-&gt;x.getParameterCount() == 0)\n        T instance;\n        if(hasEmptyConstructor){\n            instance = clazz.getConstructor().newInstance();\n        } else {\n            Thing dummyThing = getDummyThing(); // empty thing object needed only for deserialzation\n            instance = clazz.getConstructor(Thing.class).newInstance(dummyThing);\n        }\n\n        // populate instance with other state data from serializedData\n    }\n</code></pre>\n<p>And now the question - given that the class <code>T</code> can have state data fields other than <code>thingId</code>, how can I reliably populate the instantiated object's fields with said data using jackson ?</p>\n<p>Since the state data might have field names different from what's stored in the <code>serializedData</code> input (due to implementors using <code>@JsonProperty()</code> and defining a different name)\nI cannot directly use reflection to get field names. I will need to use jackson somehow, but I haven't been able to figure out how. Most available methods seem to require a type instead of an instantiated object, and I can't find any way to inject said object into the deserializer.</p>\n<p>Edit: The best solution for my case was to use <code>mapper.readerForUpdating(object).readValue(json);</code> as described in this post: <a href=\"https://stackoverflow.com/questions/12518618/deserialize-json-into-existing-object-java\">Deserialize JSON into existing object (Java)</a>.\nFull credits to Olivier in comments below</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}