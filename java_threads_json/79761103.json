{
  "question": {
    "tags": [
      "java",
      "sql-server",
      "spring-boot",
      "locking",
      "jdbi3"
    ],
    "owner": {
      "account_id": 43875485,
      "reputation": 13,
      "user_id": 31460919,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/2038d5a677b3471586dd8c75b3f6e4e2?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Gabriel Souza",
      "link": "https://stackoverflow.com/users/31460919/gabriel-souza"
    },
    "is_answered": true,
    "view_count": 192,
    "accepted_answer_id": 79765057,
    "answer_count": 2,
    "score": 1,
    "last_activity_date": 1758047543,
    "creation_date": 1757523085,
    "last_edit_date": 1758047194,
    "question_id": 79761103,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79761103/different-locking-behavior-betweeen-running-query-from-code-with-transactional",
    "title": "Different locking behavior betweeen running query from code with @Transactional and running on SQL Server",
    "body": "<p>I have created the following test scenario:</p>\n<pre><code>CREATE TABLE master.mytest.control_table (\n    id int IDENTITY(1,1) NOT NULL,\n    uuid varchar(36) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,\n    status int NOT NULL,\n    CONSTRAINT PK__control___3213E83F4F29C19D PRIMARY KEY (id)\n);\n CREATE NONCLUSTERED INDEX IControlTable_Uuid ON master.mytest.control_table (  uuid ASC  )  \n     WITH (  PAD_INDEX = OFF ,FILLFACTOR = 100  ,SORT_IN_TEMPDB = OFF , IGNORE_DUP_KEY = OFF , STATISTICS_NORECOMPUTE = OFF , ONLINE = OFF , ALLOW_ROW_LOCKS = ON , ALLOW_PAGE_LOCKS = ON  )\n     ON [PRIMARY ] ;\n</code></pre>\n<p>The table contains 3 columns: id (PK, auto generated), uuid (varchar(36)) and status (int). I created a non-clustered index on UUID.</p>\n<p>Then I inserted 4 million rows with this loop:</p>\n<pre><code>DECLARE @i INT = 1;\nWHILE @i &lt;= 4000000\nBEGIN\n    INSERT INTO mytest.control_table (uuid, status)\n    VALUES (NEWID(), (ABS(CHECKSUM(NEWID())) % 5) + 1);\n    SET @i = @i + 1;\nEND\n</code></pre>\n<p>My table contains 4M entries with random UUIDs. Then I did the following tests, I ran a SELECT query with table hints UPDLOCK, HOLDLOCK, and queried the locks generated in the dm_tran_locks table. The searched UUID does not exist in the table.</p>\n<p>For viewing the locks, I used the following query:</p>\n<pre><code>SELECT resource_type, request_session_id, resource_associated_entity_id, request_mode, request_type, request_status, COUNT(*) as 'count' FROM sys.dm_tran_locks\nGROUP BY resource_type, request_session_id, resource_associated_entity_id, request_mode, request_type, request_status\nORDER BY request_session_id;\n</code></pre>\n<p>The first test case ran the query with a delay until the commit:</p>\n<pre><code>BEGIN TRANSACTION\n\nSELECT * FROM mytest.control_table WITH(UPDLOCK, HOLDLOCK)\nWHERE uuid = 'XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX';\n\nWAITFOR DELAY '00:00:10';\n\nCOMMIT TRANSACTION;\n</code></pre>\n<p>Query plan: <a href=\"https://www.brentozar.com/pastetheplan/?id=32Occ4KVLI\" rel=\"nofollow noreferrer\">https://www.brentozar.com/pastetheplan/?id=32Occ4KVLI</a></p>\n<p>Locks table:</p>\n<p><a href=\"https://i.sstatic.net/8McobhbT.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/8McobhbT.png\" alt=\"lock table running directly on sqlserver\" /></a></p>\n<p>As we can see, we got an IX lock on OBJECT, a IU lock on PAGE, and a RangeS-U on KEY. Other queries can still run normally, except if they're also searching for the same UUID, with the same query hints.</p>\n<p>Then, I created an integration test in Spring Boot, to test my class. The class is as follows:</p>\n<pre><code>@Service\n@RequiredArgsConstructor\n@Slf4j\npublic class StatusService {\n\n    private final StatusRepository repository;\n\n    @Transactional(isolation = Isolation.READ_COMMITTED)\n    public void getUUID(StatusDomain statusDomain) {\n        log.info(&quot;Thread {} entered get method&quot;, currentThread().getName());\n\n        StatusDomain current = repository.findByUuidWithHoldLock(statusDomain.getUuid());\n        \n        log.info(&quot;Thread {} selected registry {}&quot;, currentThread().getName(), current);\n        ThreadUtils.sleep(10000); //pauses execution for 10s\n        log.info(&quot;Thread {} exited get method&quot;, currentThread().getName());\n    }\n}\n</code></pre>\n<p>The StatusDomain class just represents the table, having an id, uuid and status. Just the uuid matters for this test.\nThe StatusRepository class is an interface. I'm using JDBI for the implementation.</p>\n<pre><code>@Repository\n@UseClasspathSqlLocator\npublic interface StatusRepository {\n\n    @SqlQuery\n    @RegisterBeanMapper(StatusDomain.class)\n    StatusDomain findByUuidWithHoldLock(@Bind(&quot;uuid&quot;) String uuid);\n\n}\n</code></pre>\n<p>The JDBI configuration is:</p>\n<pre><code>@Configuration\npublic class JdbiConfiguration {\n\n    @Bean\n    public JdbiPlugin sqlObjectPlugin() {\n        return new SqlObjectPlugin();\n    }\n\n    @Bean\n    public Jdbi jdbi(DataSource dataSource, List&lt;JdbiPlugin&gt; jdbiPlugins) {\n        TransactionAwareDataSourceProxy dataSourceProxy = new TransactionAwareDataSourceProxy(dataSource);\n        Jdbi jdbi = Jdbi.create(dataSourceProxy);\n\n        jdbiPlugins.forEach(jdbi::installPlugin);\n\n        return jdbi;\n    }\n\n    @Bean\n    public StatusRepository statusRepository(Jdbi jdbi) {\n        return jdbi.onDemand(StatusRepository.class);\n    }\n}\n</code></pre>\n<p>The findByUuidWithHoldLock query is defined as:</p>\n<pre><code>SELECT * FROM mytest.control_table WITH(UPDLOCK, HOLDLOCK)\nWHERE uuid = :uuid\n</code></pre>\n<p>The goal is just to query the locks table after the SELECT and before exiting the method, before committing the transaction.</p>\n<p>This could be done in a lot of ways, but I decided to create a integration test:</p>\n<pre><code>@ActiveProfiles(profiles = {&quot;local&quot;})\n@SpringBootTest(properties = &quot;spring.main.allow-bean-definition-overriding=true&quot;)\nclass StatusServiceTest {\n\n    @Autowired\n    public ApplicationContext applicationContext;\n\n    @Autowired\n    public StatusService service;\n\n    @MockitoSpyBean\n    public StatusRepository repository;\n    \n    private final StatusDomain status4 = new StatusDomain(55L, &quot;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&quot;, 4);\n\n    @BeforeEach\n    void setUp() {\n        repository.deleteByUuid(status4.getUuid());\n    }\n\n    @Test\n    void testGet() {\n        assertDoesNotThrow(() -&gt; {\n            Thread t1 = new Thread(() -&gt; service.getUUID(status4), &quot;THREAD1&quot;);\n            t1.start();\n            t1.join();\n        });\n\n        Mockito.verify(repository, times(1)).findByUuidWithHoldLock(anyString());\n    }\n}\n</code></pre>\n<p>The @BeforeEach deletes the queried UUID to ensure it doesn't exist in the table before each test. The repository is annotated with MockitoSpyBean so I can make the assertion on the amount of times it was invoked.</p>\n<p>Querying the locks table while running the test, I found this:</p>\n<p>Query plan: <a href=\"https://www.brentozar.com/pastetheplan/?id=pcPxA0CpeO\" rel=\"nofollow noreferrer\">https://www.brentozar.com/pastetheplan/?id=pcPxA0CpeO</a></p>\n<p>Locks table:</p>\n<p><a href=\"https://i.sstatic.net/Ff0koTVo.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/Ff0koTVo.png\" alt=\"enter image description here\" /></a></p>\n<p>The generated locks are different then when executing directly the same query in SQL Server. Now I got a IX on OBJECT, lots of U locks on PAGE, and no RangeS-U lock on KEY like before.</p>\n<p>What's even weirder, is that this result was different when I first started querying the locks while executing the code. My first tests revealed an X lock on the table. So, I created another table, called status_control2, with the same DDL script, and created the index, just renaming it to IControlTable_Uuid2, and did the test again. The executed query is the same, except that it now queries status_control2. A difference though, is the number of entries inserted through the WHILE loop. In status_control2 I put only 100K entries, while status_control has 4 million.</p>\n<p>Query plan: <a href=\"https://www.brentozar.com/pastetheplan/?id=Vm101k5WDz\" rel=\"nofollow noreferrer\">https://www.brentozar.com/pastetheplan/?id=Vm101k5WDz</a></p>\n<p>Locks table:</p>\n<p><a href=\"https://i.sstatic.net/zO2aVIx5.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/zO2aVIx5.png\" alt=\"enter image description here\" /></a></p>\n<p>As we can see, the whole table got an exclusive (X) lock.</p>\n<p>This has been bugging me for a while now. I can't understand why the different behavior. I mean, the different behavior between the locks in status_control and status_control2, and specially the different behavior between running the query directly in SQL Server and running through Java application with JDBI.</p>\n<hr />\n<p>I substitute the <code>SELECT *</code> for <code>SELECT id, uuid, status</code>. The results didn't change at all.</p>\n<hr />\n<p>I created an Extended Events session to capture the &quot;query_post_execution_showplan&quot; event. Taking a look at the plans, they kinda make sense to me.</p>\n<p>The first one, which generated the expected locks, only contains the index seek + clustered index lookup. The second one, which generated a lot of PAGE U locks, contains entries of &quot;parallelism&quot; and &quot;clustered index scan&quot;. The last one, which blocks the whole table with an X lock, contains only the clustered index scan.</p>\n<p>The question remaining is why the difference... the query was supposed to be the same in all 3 scenarios. There's a warning on the 2 and 3 query plans which says:</p>\n<pre><code>Type conversion in expression\n(CONVERT_IMPLICIT(nvarchar(36),[master].[mytest].[control_table2].[uuid],0)=[@P0])\nmay affect &quot;Seek Plan&quot; in query plan choice.\n</code></pre>\n<p>But I'm not really sure about how to interpret it. At least, I guess this has something to do with JDBI replacing the &quot;:uuid&quot; variable with the provided String.</p>\n<p>SQL Server version:<br />\nMicrosoft SQL Server 2022 (RTM-CU20-GDR) (KB5063814) 16.0.4210.1 (X64)<br />\nDeveloper Edition (64-bit) on Linux (Ubuntu 22.04.5 LTS)</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}