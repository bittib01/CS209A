{
  "question": {
    "tags": [
      "java",
      "opengl",
      "3d",
      "lwjgl"
    ],
    "owner": {
      "account_id": 23032422,
      "reputation": 1,
      "user_id": 19673805,
      "user_type": "registered",
      "profile_image": "https://lh3.googleusercontent.com/a/AATXAJz3wF3Xrt7z5dKXO8jofcdCq5kIGwgCZAS3U42P=k-s256",
      "display_name": "Mohammed Baig",
      "link": "https://stackoverflow.com/users/19673805/mohammed-baig"
    },
    "is_answered": true,
    "view_count": 104,
    "answer_count": 2,
    "score": 0,
    "last_activity_date": 1725154322,
    "creation_date": 1703921676,
    "last_edit_date": 1703921751,
    "question_id": 77735195,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/77735195/opengl-texture-rendering-over-another-with-3d-batch-renderer",
    "title": "OpenGL Texture rendering over another with 3D Batch Renderer",
    "body": "<p>So, my current OpenGL Renderer seems to draw Texture B with Texture A for some reason. I checked the slots in RenderDoc and they seem to be properly bound with glBindTexture() and glActiveTexture(). I'm not quite sure what's happening. I've observed that when not moving the camera at all, the issue seems to disappear.</p>\n<p><a href=\"https://i.sstatic.net/6nuGR.png\" rel=\"nofollow noreferrer\">Screenshot</a></p>\n<p>This is the main class:</p>\n<pre><code>package demo;\n\nimport org.joml.Matrix4f;\nimport org.lwjgl.opengl.GL46;\nimport rebel.graphics.*;\n\npublic class Test3D {\n    public static void main(String[] args) {\n        Window window = new Window(1000, 600, &quot;&quot;);\n        Renderer3D renderer3D = new Renderer3D(window.getWidth(), window.getHeight(), true);\n\n\n        Texture2D a = new Texture2D(&quot;project/logo.png&quot;);\n        Texture2D b = new Texture2D(&quot;project/texture.png&quot;);\n\n\n        float rotX = 0f, rotY = 0f, rotZ = 0f;\n\n        while(!window.shouldClose()){\n            renderer3D.clear(Color.WHITE);\n\n\n            renderer3D.setOrigin(0, 0);\n            renderer3D.drawTexture(0.5f / -2f, 0.5f / -2f, 0.5f, 0.5f, a, Color.RED);\n            renderer3D.drawTexture((0.5f / -2f) + 0.5f, 0.5f / -2f, 1f, 1f, b, Color.BLUE);\n            renderer3D.resetTransform();\n\n\n\n            renderer3D.getCamera().getViewMatrix().rotate((float) Math.toRadians(rotX), 1, 0, 0);\n            renderer3D.getCamera().getViewMatrix().rotate((float) Math.toRadians(rotY), 0, 1, 0);\n            renderer3D.getCamera().getViewMatrix().translate(0, 0, 1f);\n\n\n            rotX = 360 * -(window.getMouseY() / window.getHeight());\n            rotY = 360 * (window.getMouseX() / window.getWidth());\n\n\n\n\n            renderer3D.updateCamera2D();\n            renderer3D.render();\n            renderer3D.getCamera().getViewMatrix().set(new Matrix4f().identity());\n\n            System.out.println(GL46.glGetError());\n\n\n            window.update();\n        }\n\n        window.close();\n\n\n    }\n}\n\n</code></pre>\n<p>And Renderer3D:</p>\n<pre><code>package rebel.graphics;\n\nimport org.joml.*;\nimport org.lwjgl.BufferUtils;\nimport rebel.FileReader;\n\nimport java.lang.Math;\nimport java.nio.IntBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.lwjgl.opengl.GL46.*;\n\npublic class Renderer3D {\n    private int width;\n    private int height;\n    private Matrix4f proj;\n    private Camera camera;\n    private Matrix4f translation;\n    private VertexBuffer vertexBuffer;\n    private float[] vertexData;\n    private int maxTextureSlots;\n    private ShaderProgram defaultShaderProgram, currentShaderProgram;\n    private ArrayList&lt;String&gt; renderCallNames = new ArrayList&lt;&gt;(50);\n    private boolean debug = false;\n    private FastTextureLookup textureLookup;\n\n    private static final float FOV = (float) Math.toRadians(60.0f);\n\n    private static final float Z_NEAR = 0.01f;\n\n    private static final float Z_FAR = 1000.f;\n\n    public Renderer3D(int width, int height, boolean msaa) {\n        this.width = width;\n        this.height = height;\n\n        glEnable(GL_DEPTH_TEST);\n        glDepthFunc(GL_NOTEQUAL);\n\n\n        float aspectRatio = (float) getWidth() / getHeight();\n        proj = new Matrix4f().perspective(FOV, aspectRatio,\n                Z_NEAR, Z_FAR);\n        camera = new Camera();\n        translation = new Matrix4f().identity();\n\n\n        IntBuffer d = BufferUtils.createIntBuffer(1);\n        glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, d);\n        maxTextureSlots  = d.get();\n        textureLookup = new FastTextureLookup(maxTextureSlots);\n\n\n\n        defaultShaderProgram = new ShaderProgram(\n                FileReader.readFile(Renderer2D.class.getClassLoader().getResourceAsStream(&quot;3DBatchVertexShader.glsl&quot;)),\n                FileReader.readFile(Renderer2D.class.getClassLoader().getResourceAsStream(&quot;3DBatchFragmentShader.glsl&quot;))\n        );\n\n        defaultShaderProgram.prepare();\n        currentShaderProgram = defaultShaderProgram;\n        currentShaderProgram.bind();\n\n\n        updateCamera2D();\n\n        VertexArray vertexArray = new VertexArray();\n        vertexArray.bind();\n\n\n        vertexArray.setVertexAttributes(\n                new VertexAttribute(0, 3, false, &quot;v_pos&quot;),\n                new VertexAttribute(1, 2, false, &quot;v_uv&quot;),\n                new VertexAttribute(2, 1, false, &quot;v_texindex&quot;),\n                new VertexAttribute(3, 4, false, &quot;v_color&quot;),\n                new VertexAttribute(4, 1, false, &quot;v_thickness&quot;)\n        );\n\n        vertexBuffer = new VertexBuffer(1000, vertexArray.getStride());\n        vertexArray.build();\n\n        vertexData = new float[vertexBuffer.getNumOfVertices() * vertexBuffer.getVertexDataSize()];\n    }\n\n    /***\n     * Sets the current shader. This shader must be compiled before calling this method!\n     * @param shaderProgram\n     */\n    public void setShader(ShaderProgram shaderProgram){\n\n        if(currentShaderProgram != shaderProgram) {\n            currentShaderProgram = shaderProgram;\n            currentShaderProgram.bind();\n            updateCamera2D();\n        }\n    }\n\n    public void updateCamera2D(){\n        currentShaderProgram.setMatrix4f(&quot;v_model&quot;, getTranslation());\n        currentShaderProgram.setMatrix4f(&quot;v_view&quot;, getView());\n        currentShaderProgram.setMatrix4f(&quot;v_projection&quot;, getProj());\n        currentShaderProgram.setIntArray(&quot;u_textures&quot;, createTextureSlots());\n    }\n\n\n    private int[] createTextureSlots() {\n        int[] slots = new int[maxTextureSlots];\n        for (int i = 0; i &lt; maxTextureSlots; i++) {\n            slots[i] = i;\n        }\n        return slots;\n    }\n    public VertexBuffer getVertexBuffer() {\n        return vertexBuffer;\n    }\n    public int getWidth() {\n        return width;\n    }\n    public int getHeight() {\n        return height;\n    }\n    public Matrix4f getProj() {\n        return proj;\n    }\n    public Camera getCamera() {\n        return camera;\n    }\n    public Matrix4f getView() {\n        return camera.getViewMatrix();\n    }\n    public Matrix4f getTranslation() {\n        return translation;\n    }\n    private int quadIndex;\n    private int nextTextureSlot;\n    private Matrix4f transform = new Matrix4f().identity();\n    private float originX, originY;\n    public Matrix4f getTransform() {\n        return transform;\n    }\n    public void setTransform(Matrix4f transform) {\n        this.transform = transform;\n    }\n    public void resetTransform(){\n        setTransform(new Matrix4f().identity());\n    }\n    public void drawTexture(float x, float y, float w, float h, Texture2D texture){\n        drawTexture(x, y, w, h, texture, Color.WHITE);\n    }\n    public void setOrigin(float x, float y){\n        this.originX = x;\n        this.originY = y;\n    }\n\n\n\n\n    public void drawTexture(float x, float y, float w, float h, Texture2D texture, Color color){\n        drawTexture(x, y, w, h, texture, color, new Rect2D(0, 0, 1, 1), false, false);\n    }\n    public void drawTexture(float x, float y, float w, float h, Texture2D texture, Color color, Rect2D rect2D, boolean xFlip, boolean yFlip) {\n\n        int slot = nextTextureSlot;\n        boolean isUniqueTexture = false;\n\n\n\n        //Existing texture\n        if (textureLookup.hasTexture(texture)) {\n            slot = textureLookup.getTexture(texture);\n        }\n\n        //Unique Texture\n        else {\n            glActiveTexture(GL_TEXTURE0 + slot);\n            texture.bind();\n            texture.setSlot(slot);\n            textureLookup.registerTexture(texture, slot);\n            isUniqueTexture = true;\n        }\n\n\n        drawQuadGL(x, y, w, h, slot, color, originX, originY, rect2D, -1, xFlip, yFlip);\n\n        if(isUniqueTexture) nextTextureSlot++;\n\n        if(nextTextureSlot == maxTextureSlots)\n            render(&quot;Next Batch Render [No more rebel.engine.graphics.Texture slots out of &quot; + maxTextureSlots + &quot;]&quot;);\n\n    }\n\n\n    public void drawQuadGL(float x, float y, float w, float h, int slot, Color color, float originX, float originY, Rect2D region, float thickness, boolean xFlip, boolean yFlip){\n        //Translate back by origin (for rotation math)\n        //This usually takes everything near (0, 0)\n\n        Rect2D copy = new Rect2D(region.x, region.y, region.w, region.h);\n\n        if(xFlip){\n            float temp = copy.x;\n            copy.x = copy.w;\n            copy.w = temp;\n        }\n\n        if(yFlip){\n            float temp = copy.y;\n            copy.y = copy.h;\n            copy.h = temp;\n        }\n\n        float z = -0.25f;\n\n        Vector4f topLeft = new Vector4f(x - originX, y - originY, z, 1);\n        Vector4f topRight = new Vector4f(x + w - originX, y - originY, z, 1);\n        Vector4f bottomLeft = new Vector4f(x - originX, y + h - originY, z, 1);\n        Vector4f bottomRight = new Vector4f(x + w - originX, y + h - originY, z, 1);\n\n        topLeft.mul(transform);\n        topRight.mul(transform);\n        bottomLeft.mul(transform);\n        bottomRight.mul(transform);\n\n\n\n        //Translate forward by origin back to the current position\n        topLeft.x += originX;\n        topRight.x += originX;\n        bottomLeft.x += originX;\n        bottomRight.x += originX;\n\n        topLeft.y += originY;\n        topRight.y += originY;\n        bottomLeft.y += originY;\n        bottomRight.y += originY;\n\n\n\n        {\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 0] = topLeft.x;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 1] = topLeft.y;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 2] = topLeft.z;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 3] = copy.x;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 4] = copy.y;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 5] = slot;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 6] = color.r;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 7] = color.g;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 8] = color.b;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 9] = color.a;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 10] = thickness;\n\n\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 11] = bottomLeft.x;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 12] = bottomLeft.y;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 13] = bottomLeft.z;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 14] = copy.x;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 15] = copy.h;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 16] = slot;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 17] = color.r;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 18] = color.g;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 19] = color.b;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 20] = color.a;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 21] = thickness;\n\n\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 22] = bottomRight.x;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 23] = bottomRight.y;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 24] = bottomRight.z;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 25] = copy.w;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 26] = copy.h;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 27] = slot;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 28] = color.r;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 29] = color.g;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 30] = color.b;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 31] = color.a;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 32] = thickness;\n\n\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 33] = topRight.x;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 34] = topRight.y;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 35] = topRight.z;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 36] = copy.w;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 37] = copy.y;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 38] = slot;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 39] = color.r;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 40] = color.g;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 41] = color.b;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 42] = color.a;\n            vertexData[(quadIndex * vertexBuffer.getVertexDataSize()) + 43] = thickness;\n\n\n        }\n        quadIndex++;\n\n\n        if(quadIndex == vertexBuffer.maxQuads()) render(&quot;Next Batch Render&quot;);\n    }\n    public void render(){\n        render(&quot;Final Draw Call [rebel.engine.graphics.Renderer2D.render()]&quot;);\n\n        if(debug){\n            System.out.println(&quot;Renderer2D (&quot; + this + &quot;) - Debug&quot;);\n\n            for(String call : getRenderCalls()){\n                System.out.print(&quot;\\t&quot; + call + &quot;\\n&quot;);\n            }\n            System.out.println(&quot;\\n&quot;);\n        }\n\n\n        renderCallNames.clear();\n    }\n\n    public void render(String renderName) {\n        renderCallNames.add(renderName);\n\n        glBindBuffer(GL_ARRAY_BUFFER, getVertexBuffer().myVbo);\n\n\n\n        glBufferSubData(GL_ARRAY_BUFFER, 0, vertexData);\n\n\n        int numOfIndices = quadIndex * 6;\n        int[] indices = new int[numOfIndices];\n        int offset = 0;\n\n        for (int j = 0; j &lt; numOfIndices; j += 6) {\n\n            indices[j] =         offset;\n            indices[j + 1] = 1 + offset;\n            indices[j + 2] = 2 + offset;\n            indices[j + 3] = 2 + offset;\n            indices[j + 4] = 3 + offset;\n            indices[j + 5] =     offset;\n\n            offset += 4;\n        }\n\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, getVertexBuffer().myEbo);\n        glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, 0, indices);\n        glDrawElements(GL_TRIANGLES, indices.length, GL_UNSIGNED_INT, 0);\n\n\n        vertexData = new float[vertexBuffer.getNumOfVertices() * vertexBuffer.getVertexDataSize()];\n        quadIndex = 0;\n        nextTextureSlot = 0;\n        textureLookup.clear();\n\n    }\n    public List&lt;String&gt; getRenderCalls(){\n        return new ArrayList&lt;&gt;(renderCallNames);\n    }\n\n\n    public void clear(Color color) {\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n        glClearColor(color.r, color.g, color.b, color.a);\n    }\n\n\n}\n\n</code></pre>\n<p>This is my Vertex Shader:</p>\n<pre><code>#version 330 core\nlayout (location = 0) in vec3 v_pos;\nlayout (location = 1) in vec2 v_uv;\nlayout (location = 2) in float v_texindex;\nlayout (location = 3) in vec4 v_color;\nlayout (location = 4) in float v_thickness;\n\n\n\n\nout vec2 f_uv;\nout float f_texindex;\nout vec4 f_color;\nout vec2 f_origin;\nout vec2 f_size;\nout float f_thickness;\n\nuniform mat4 v_model;\nuniform mat4 v_view;\nuniform mat4 v_projection;\n\n\n\n\n\n\nvoid main() {\n\n    f_texindex = v_texindex;\n    f_uv = v_uv;\n    f_color = v_color;\n    f_thickness = v_thickness;\n\n\n    gl_Position = v_projection * v_view * v_model * vec4(v_pos, 1.0);\n}\n</code></pre>\n<p>And my Fragment Shader</p>\n<pre><code>#version 330 core\nout vec4 FragColor;\n\nin vec2 f_uv;\n\nuniform sampler2D u_textures[32];\nin float f_texindex;\nin vec4 f_color;\nin float f_thickness;\nlayout(origin_upper_left) in vec4 gl_FragCoord;\n\n\nvoid main()\n{\n\n\n    int index = int(f_texindex);\n\n\n\n    if(index == -1){\n        FragColor = f_color;\n    }\n    else if(index == -2){\n        vec2 uv = f_uv * 2.0 - 1.0;\n\n        float distance = length(uv);\n\n        if(distance &lt;= 1.0 &amp;&amp; distance &gt;= (1.0 - f_thickness))\n        FragColor = f_color;\n        else\n        discard;\n\n    }\n    else {\n\n\n        if(index == 0) FragColor += texture(u_textures[0], f_uv) * f_color;\n        if(index == 1) FragColor += texture(u_textures[1], f_uv) * f_color;\n        if(index == 2) FragColor += texture(u_textures[2], f_uv) * f_color;\n        if(index == 3) FragColor += texture(u_textures[3], f_uv) * f_color;\n        if(index == 4) FragColor += texture(u_textures[4], f_uv) * f_color;\n        if(index == 5) FragColor += texture(u_textures[5], f_uv) * f_color;\n        if(index == 6) FragColor += texture(u_textures[6], f_uv) * f_color;\n        if(index == 7) FragColor += texture(u_textures[7], f_uv) * f_color;\n        if(index == 8) FragColor += texture(u_textures[8], f_uv) * f_color;\n        if(index == 9) FragColor += texture(u_textures[9], f_uv) * f_color;\n        if(index == 10) FragColor += texture(u_textures[10], f_uv) * f_color;\n        if(index == 11) FragColor += texture(u_textures[11], f_uv) * f_color;\n        if(index == 12) FragColor += texture(u_textures[12], f_uv) * f_color;\n        if(index == 13) FragColor += texture(u_textures[13], f_uv) * f_color;\n        if(index == 14) FragColor += texture(u_textures[14], f_uv) * f_color;\n        if(index == 15) FragColor += texture(u_textures[15], f_uv) * f_color;\n        if(index == 16) FragColor += texture(u_textures[16], f_uv) * f_color;\n        if(index == 17) FragColor += texture(u_textures[17], f_uv) * f_color;\n        if(index == 18) FragColor += texture(u_textures[18], f_uv) * f_color;\n        if(index == 19) FragColor += texture(u_textures[19], f_uv) * f_color;\n        if(index == 20) FragColor += texture(u_textures[20], f_uv) * f_color;\n        if(index == 21) FragColor += texture(u_textures[21], f_uv) * f_color;\n        if(index == 22) FragColor += texture(u_textures[22], f_uv) * f_color;\n        if(index == 23) FragColor += texture(u_textures[23], f_uv) * f_color;\n        if(index == 24) FragColor += texture(u_textures[24], f_uv) * f_color;\n        if(index == 25) FragColor += texture(u_textures[25], f_uv) * f_color;\n        if(index == 26) FragColor += texture(u_textures[26], f_uv) * f_color;\n        if(index == 27) FragColor += texture(u_textures[27], f_uv) * f_color;\n        if(index == 28) FragColor += texture(u_textures[28], f_uv) * f_color;\n        if(index == 29) FragColor += texture(u_textures[29], f_uv) * f_color;\n        if(index == 30) FragColor += texture(u_textures[30], f_uv) * f_color;\n        if(index == 31) FragColor += texture(u_textures[31], f_uv) * f_color;\n    }\n\n}\n\n</code></pre>\n<p>I was expecting it to render the textures without any glitchy artifacts, mostly because I carried over the Texture batching logic from my 2D Renderer. I'm sure I'm missing something simple. I'm using an NVIDIA GeForce MX450 PCIe/SSE2.</p>\n<p>glGetError() reported no errors, and the LWJGL OpenGL Callback was silent the whole time. I've verified using RenderDoc that the textures are bound to the correct slots.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}