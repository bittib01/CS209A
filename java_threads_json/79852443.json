{
  "question": {
    "tags": [
      "java",
      "swing",
      "user-interface",
      "components",
      "tablelayout"
    ],
    "owner": {
      "account_id": 2182934,
      "reputation": 2660,
      "user_id": 1932011,
      "user_type": "registered",
      "accept_rate": 71,
      "profile_image": "https://www.gravatar.com/avatar/612163480a1ccb4785fd647a003eefbb?s=256&d=identicon&r=PG",
      "display_name": "JayC667",
      "link": "https://stackoverflow.com/users/1932011/jayc667"
    },
    "is_answered": true,
    "view_count": 44,
    "answer_count": 11,
    "score": 0,
    "last_activity_date": 1766435553,
    "creation_date": 1766346954,
    "last_edit_date": 1766347598,
    "question_id": 79852443,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79852443/table-layout-adjusting-insides-of-components",
    "title": "Table layout adjusting insides of components",
    "body": "<p>I want to display and configure multiple objects of the same class at the same time, while keeping up the good looks of a table. So: one line per entity, with multiple GUI elements per line for the configuration of each entity.</p>\n<p>Usually, one could use a <code>JTable</code> for this. Or a <code>GridBagLayout</code>, if all the controls were in one parent container.</p>\n<p>But if the logic for each object is more complex and requires additional logic (checks and variables), it seems better to use a custom panel for each object (like a class extending <code>JPanel</code> with components for each member variable).</p>\n<p>But, when using <code>LayoutManager</code>s inside that custom panel, like <code>BorderLayout</code>, <code>BoxLayout</code> etc, the component sizes inside the panel might differ from the ones in the next line.</p>\n<p>Here is an SSCC example of how I want to use it, and what it should actually look like:</p>\n<pre><code>package stackoverflow;\n\nimport java.awt.BorderLayout;\nimport java.awt.GridBagConstraints;\nimport java.awt.GridBagLayout;\n\nimport javax.swing.BoxLayout;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.JTextField;\n\npublic class ComponentTableLayoutTest {\n\n\n\n    static public final int TEXT_FIELD_COLS = 30;\n\n\n\n    static class MyPanel extends JPanel {\n        private static final long   serialVersionUID    = 7290890689192066726L;\n        public final JLabel         label;\n        public final JTextField     text                = new JTextField(TEXT_FIELD_COLS);\n        // more elements, complex logic\n\n        public MyPanel(final String pLabel) {\n            label = new JLabel(pLabel);\n\n            setLayout(new BorderLayout());\n            add(label, BorderLayout.WEST);\n            add(text, BorderLayout.CENTER);\n        }\n    }\n\n\n\n    public static void main(final String... args) {\n        showInterestingFrame();\n        showPerfectFrame();\n    }\n\n\n\n    private static void showInterestingFrame() { // how I want to use it\n        final JFrame f = new JFrame();\n        f.setTitle(&quot;component wise table layout test - how it should work&quot;);\n        f.setLayout(new BoxLayout(f.getContentPane(), BoxLayout.Y_AXIS));\n\n        final MyPanel panel1 = new MyPanel(&quot;short: &quot;);\n        final MyPanel panel2 = new MyPanel(&quot;mediummmm: &quot;);\n        final MyPanel panel3 = new MyPanel(&quot;veryverylonglonglong: &quot;);\n\n        f.add(panel1);\n        f.add(panel2);\n        f.add(panel3);\n\n        f.setVisible(true);\n        f.pack();\n        f.setLocation(200, 200);\n    }\n\n\n\n    private static void showPerfectFrame() { // what it should look like\n        final JFrame f = new JFrame();\n        f.setTitle(&quot;classic GBL - how it should look&quot;);\n        f.setLayout(new GridBagLayout());\n\n        final GridBagConstraints gbc = new GridBagConstraints();\n        gbc.anchor = GridBagConstraints.WEST;\n\n        f.add(new JLabel(&quot;short: &quot;), gbc);\n        f.add(new JTextField(TEXT_FIELD_COLS), gbc);\n\n        gbc.gridy = 1;\n        f.add(new JLabel(&quot;mediummmm: &quot;), gbc);\n        f.add(new JTextField(TEXT_FIELD_COLS), gbc);\n\n        gbc.gridy = 2;\n        f.add(new JLabel(&quot;veryverylonglonglong: &quot;), gbc);\n        f.add(new JTextField(TEXT_FIELD_COLS), gbc);\n\n        f.setVisible(true);\n        f.pack();\n        f.setLocation(200, 300);\n    }\n\n\n\n}\n</code></pre>\n<p>So, what is the best practice to use the methodology of <code>showInterestingFrame()</code> while keeping the looks like <code>showPerfectFrame()</code>?\nIn other words: Keep up <code>GridBagLayout</code>'s (or any other <code>LayoutManager</code>'s) ability to adjust spacial requirements, while keeping a table layout look, across sub-components.</p>\n<p>And if I had to interfere with layouting directly, if I checked/adjusted all the <code>getPreferredSize()</code>s for each vertical component, what would be best way to hook into <code>Swing</code>'s layouting? <code>doLayout</code>? <code>invalidate()</code>?</p>\n<p>Additional aspects:</p>\n<ul>\n<li>I want to avoid the usage of dialog popups to configure each entity; The user should be able to edit them simultaneously</li>\n<li>I believe that <code>JTable</code> has too many shortcomings regarding the specific display/handling of columns (as its <code>TableCellRenderer</code>s seem to be selected via property class, instead of column index), plus cell access is hard to be done on an entity-level.</li>\n</ul>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}