{
  "question": {
    "tags": [
      "java",
      "angular",
      "spring-cloud-gateway",
      "spring-authorization-server",
      "spring-boot-starter-oauth2-client"
    ],
    "owner": {
      "account_id": 18835111,
      "reputation": 73,
      "user_id": 13810015,
      "user_type": "registered",
      "profile_image": "https://i.sstatic.net/FhZCE.jpg?s=256",
      "display_name": "Andre Gallegos",
      "link": "https://stackoverflow.com/users/13810015/andre-gallegos"
    },
    "is_answered": true,
    "view_count": 2043,
    "accepted_answer_id": 78728160,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1722538741,
    "creation_date": 1720481114,
    "question_id": 78723179,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78723179/session-management-in-a-spring-oauth2-client-that-works-as-a-gateway",
    "title": "Session management in a spring-oauth2-client that works as a gateway",
    "body": "<p>I am implementing a microservices application and for the authentication issue I have used something similar to what @ch4mp proposed in his <a href=\"https://www.baeldung.com/spring-cloud-gateway-bff-oauth2\" rel=\"nofollow noreferrer\">https://www.baeldung.com/spring-cloud-gateway-bff-oauth2</a> tutorial. The difference is that my oauth2Client works also as a gateway, I also have an angular application.</p>\n<p>The problem I have is that I don't know how to handle the session issue, since the login works as it should, the authorization is requested to my authorization server, it is validated and through a cookieSession I can enter to my dashboard. My accessToken and RefreshToken are set with a duration of 5 minutes and 1 hour respectively. And for testing purposes I have set the session to last 30 minutes. All the logout flow works as it should, for this I use the OIDC Logout standard in which the id_token is used. The problem arises that when the session expires, I have to refresh the page so that I reridiga to /home but at the time of logging in again no longer asks me the credentials but enters directly as if I had already entered the credentials.</p>\n<p>So according to this what would be the best solution? I thought that the session should not I was thinking that the session should not expire but by doing this then I should limit the number of sessions a user should have?</p>\n<p>My SecurityConfigClient:</p>\n<pre><code>@Configuration\n@EnableWebFluxSecurity\npublic class ClientSecurityConfig {\n\n    @Autowired\n    private ReactiveClientRegistrationRepository clientRegistrationRepository;\n\n    @Value(&quot;${intechbo.server.gateway}&quot;)\n    private String gatewayUrl;\n\n    @Bean\n    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http,\n                                                         ServerOAuth2AuthorizationRequestResolver resolver) {\n        http\n                .cors(ServerHttpSecurity.CorsSpec::disable)\n                .csrf(ServerHttpSecurity.CsrfSpec::disable)\n                .authorizeExchange(\n                        exchanges -&gt; exchanges\n                                .pathMatchers(SecurityConstants.AUTH_WHITELIST).permitAll()\n                                .pathMatchers(&quot;/*.js&quot;, &quot;/*.css&quot;, &quot;/*.ico&quot;, &quot;/*.jpg&quot;, &quot;/*.png&quot;, &quot;/*.html&quot;, &quot;/*.svg&quot;).permitAll()\n                                .pathMatchers(SecurityConstants.AUTH_ANGULAR_COMPILER_WHITELIST).permitAll()\n                                .pathMatchers(&quot;/backoffice/home/**&quot;).permitAll()\n                                .pathMatchers(&quot;/backoffice/home&quot;).permitAll()\n                                .pathMatchers(&quot;/backoffice/authentication/logout&quot;).permitAll()\n                                .pathMatchers(&quot;/backoffice/profile/**&quot;).authenticated()\n                                .pathMatchers(&quot;/logged-out&quot;).permitAll()\n                                .pathMatchers(&quot;/authenticate&quot;).authenticated()\n                                .anyExchange().authenticated()\n                )\n                .oauth2Login(auth -&gt;\n                        auth.authorizationRequestResolver(resolver)\n                                .authenticationSuccessHandler(new CustomServerAuthenticationSuccessHandler(&quot;/backoffice/authentication/login&quot;))\n                )\n                .oauth2Client(Customizer.withDefaults())\n                .logout(\n                        logout -&gt; logout\n                                .logoutUrl(&quot;/logout&quot;)\n                                .logoutSuccessHandler(oidcLogoutSuccessHandler())\n                )\n                .exceptionHandling(\n                        exceptionHandlingSpec -&gt; exceptionHandlingSpec\n                                .authenticationEntryPoint((swe, e) -&gt; {\n                                    ServerHttpResponse response = swe.getResponse();\n                                    response.setStatusCode(HttpStatus.SEE_OTHER);\n                                    response.getHeaders().setLocation(URI.create(&quot;/backoffice/home&quot;));\n                                    return response.setComplete();\n                                })\n                );\n        return http.build();\n    }\n\n    private ServerLogoutSuccessHandler oidcLogoutSuccessHandler() {\n        OidcClientInitiatedServerLogoutSuccessHandler oidcLogoutSuccessHandler =\n                new OidcClientInitiatedServerLogoutSuccessHandler(this.clientRegistrationRepository);\n\n        // Sets the location that the End-User's User Agent will be redirected to\n        // after the logout has been performed at the Provider\n        oidcLogoutSuccessHandler.setPostLogoutRedirectUri(gatewayUrl + &quot;/logged-out&quot;);\n\n        return oidcLogoutSuccessHandler;\n    }\n\n    @Bean\n    public ServerOAuth2AuthorizationRequestResolver pkceResolver(ReactiveClientRegistrationRepository repo) {\n        DefaultServerOAuth2AuthorizationRequestResolver resolver = new DefaultServerOAuth2AuthorizationRequestResolver(repo);\n        resolver.setAuthorizationRequestCustomizer(OAuth2AuthorizationRequestCustomizers.withPkce());\n        return resolver;\n    }\n\n    @Bean\n    public WebClient webClient(ReactiveOAuth2AuthorizedClientManager authorizedClientManager) {\n        ServerOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =\n                new ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);\n        oauth2Client.setDefaultOAuth2AuthorizedClient(true);\n        return WebClient.builder()\n                .filter(oauth2Client)\n                .build();\n    }\n\n    @Bean\n    public ReactiveOAuth2AuthorizedClientManager authorizedClientManager(ReactiveClientRegistrationRepository clientRegistrationRepository,\n                                                                         ServerOAuth2AuthorizedClientRepository authorizedClientRepository) {\n        ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =\n                ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n                        .authorizationCode()\n                        .refreshToken()\n                        .build();\n        DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager =\n                new DefaultReactiveOAuth2AuthorizedClientManager(clientRegistrationRepository, authorizedClientRepository);\n        authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n        return authorizedClientManager;\n    }\n\n}\n\n</code></pre>\n<p>My Configuration to set maxInactiveIntervalInSeconds:</p>\n<pre><code>@Configuration\n@EnableRedisWebSession(redisNamespace = &quot;inclub:session&quot;, maxInactiveIntervalInSeconds = 600)\npublic class SessionConfig {\n\n}\n</code></pre>\n<p>My application.yml:</p>\n<pre><code>logging:\n  level:\n    org.springframework.cloud.gateway.handler.RoutePredicateHandlerMapping: DEBUG\n    org:\n      springframework:\n        security: DEBUG\n        session: DEBUG\n        web: DEBUG\n\n\nspring:\n#  cache:\n#    redis:\n#      time-to-live: 60000\n  application:\n    name: bo-gateway-server\n  session:\n    redis:\n      repository-type: default\n#    timeout: 10m\n  security:\n    oauth2:\n      client:\n        registration:\n          backoffice-gateway:\n            provider: spring\n            client-id: example-client\n            client-secret: \n            authorization-grant-type: authorization_code\n            redirect-uri: ${intechbo.server.gateway}/login/oauth2/code/backoffice-gateway\n            scope: read,write,openid,profile\n        provider:\n          spring:\n            issuer-uri: ${intechbo.server.oauth}\n\n  cloud:\n    gateway:\n      default-filters:\n        - DedupeResponseHeader=Access-Control-Allow-Credentials Access-Control-Allow-Origin\n        - TokenRelay=\n        - SaveSession\n      routes:\n        - id: pets-service-route\n          uri: uri\n          predicates:\n            - Path=/api/v1/breeds/**\n          filters:\n            - name: Retry\n              args:\n                retries: 5\n                methods: GET\n                backoff:\n                  firstBackoff: 50ms\n                  maxBackOff: 400ms\n            - name: CircuitBreaker\n              args:\n                name: petsService\n                fallbackUri: forward:/pets-service-fallback\n            - name: RequestRateLimiter\n              args:\n                key-resolver: &quot;#{@userKeyResolver}&quot;\n                redis-rate-limiter.replenishRate: 2\n                redis-rate-limiter.burstCapacity: 2\n\n        -  id: account-service-route\n#           uri: http://localhost:8776\n           uri: uri\n           predicates:\n             - Path=/api/v1/account/**\n           filters:\n             - name: Retry\n               args:\n                 retries: 5\n                 methods: GET\n                 backoff:\n                   firstBackoff: 50ms\n                   maxBackOff: 400ms\n             - name: CircuitBreaker\n               args:\n                 name: accountService\n                 fallbackUri: forward:/account-service-fallback\n             - name: RequestRateLimiter\n               args:\n                 key-resolver: &quot;#{@userKeyResolver}&quot;\n                 redis-rate-limiter.replenishRate: 2\n                 redis-rate-limiter.burstCapacity: 2\n\n        - id: membership-service-route\n          uri: uri\n          predicates:\n            - Path=/api/v1/membership/**, /api/v1/pay/** , /api/v1/store/**\n          filters:\n            - name: RequestRateLimiter\n              args:\n                key-resolver: &quot;#{@userKeyResolver}&quot;\n                redis-rate-limiter.replenishRate: 2\n                redis-rate-limiter.burstCapacity: 2\n\n        - id: treepointrange-service-route\n          uri: uri\n          predicates:\n            - Path=/api/v1/three/**, /api/v1/placement/**\n          filters:\n            - name: RequestRateLimiter\n              args:\n                key-resolver: &quot;#{@userKeyResolver}&quot;\n                redis-rate-limiter.replenishRate: 2\n                redis-rate-limiter.burstCapacity: 2\n\n        - id: wallet-service-route\n          uri: uri\n          predicates:\n            - Path=/api/v1/wallet/**, /api/v1/wallettransaction/**, /api/v1/withdrawalrequest/**, /api/v1/tokenwallet/**, /api/v1/electronicpurse/**, /api/v1/accountbank/**\n          filters:\n            - name: RequestRateLimiter\n              args:\n                key-resolver: &quot;#{@userKeyResolver}&quot;\n                redis-rate-limiter.replenishRate: 2\n                redis-rate-limiter.burstCapacity: 2\n\n#        - id: angular\n#          uri: ${intechbo.server.webapp}\n#          predicates:\n#            - Path=/backoffice/**\n#          filters:\n##            - RewritePath=/backoffice(?&lt;segment&gt;/?.*), /$\\\\{segment}\n#            - RewritePath=/backoffice(?&lt;segment&gt;/?.*), &quot;/\\\\$\\\\{segment}&quot;\n        - id: angular\n          uri: ${intechbo.server.webapp}\n          predicates:\n            - Path=/\n          filters:\n            - RewritePath=/, /backoffice\n        - id: static\n          uri: ${intechbo.server.webapp}\n          predicates:\n            - Path=/**\n\n  data:\n    redis:\n      port: ${REDIS_SERVER_PORT:6379}\n      host: ${REDIS_SERVER_HOST:localhost}\n      password: ${REDIS_SERVER_PASSWORD:}\n      timeout: 5000\n      lettuce:\n        pool:\n          max-idle: 9\n          min-idle: 1\n          max-active: 9\n          max-wait: 5000\n\neureka:\n  client:\n    service-url:\n      defaultZone: ${intechbo.server.discover}\n    fetch-registry: true\n    register-with-eureka: true\n\nserver:\n  port: 8090\n#  reactive:\n#    session:\n#      timeout: 1m\n  reactive:\n    session:\n      timeout: 10m\n      cookie:\n        name: INTECHBOSESSION\n        max-age: 10m\n\nresilience4j:\n  circuitbreaker:\n    configs:\n      default:\n        slidingWindowSize: 10\n        slidingWindowType: COUNT_BASED\n        permittedNumberOfCallsInHalfOpenState: 6\n        failureRateThreshold: 50\n        waitDurationInOpenState: 10s\n        registerHealthIndicator: true\n        automaticTransitionFromOpenToHalfOpenEnabled: true\n\n    instances:\n      petsService:\n        baseConfig: default\n\n  retry:\n    instances:\n      authorizationServer:\n        maxAttempts: 3\n        waitDuration: 2500ms\n        enableExponentialBackoff: true\n        exponentialBackoffMultiplier: 2\n\n  timelimiter:\n    configs:\n      values:\n        timeout-duration: 80s\n    instances:\n      offersTimeLimiter: # Unique name for TimeLimiter\n        base-config: values\n\nmanagement:\n  health:\n    circuitbreakers:\n      enabled: true\n  endpoints:\n    web:\n      exposure:\n        include: &quot;*&quot;\n  endpoint:\n    health:\n      show-details: always\n\n</code></pre>\n<p>If I were to choose to never invalidate at some point I may have problems in my redis database where I am storing this?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}