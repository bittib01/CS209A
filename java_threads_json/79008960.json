{
  "question": {
    "tags": [
      "java"
    ],
    "owner": {
      "account_id": 246015,
      "reputation": 11515,
      "user_id": 519882,
      "user_type": "registered",
      "accept_rate": 62,
      "profile_image": "https://www.gravatar.com/avatar/cf3e8e6aeb0333c68b235284d2437127?s=256&d=identicon&r=PG",
      "display_name": "venkysmarty",
      "link": "https://stackoverflow.com/users/519882/venkysmarty"
    },
    "is_answered": true,
    "view_count": 70,
    "closed_date": 1726912772,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1726902920,
    "creation_date": 1726902172,
    "question_id": 79008960,
    "link": "https://stackoverflow.com/questions/79008960/providing-method-of-interface-instead-of-implementing-interface-in-java",
    "closed_reason": "Duplicate",
    "title": "providing method of interface instead of implementing interface in java",
    "body": "<p>I am reading about interfaces in Java. It is mentioned that we have to implement compareTo method for calling &quot;sort&quot; on ArrayList Container, for example Employee class should implement Comparable Interface.</p>\n<p>Later it is explained why can't the Employee class simply provide &quot;compareTo&quot; method without implementing Comparable interface?  The reason for interfaces is that Java programming is strongly typed. When making a method call, the compiler needs to be able to check that the method actually exist.</p>\n<p>So I am expecting compile time error when I don't implement &quot;Comparable interface and using Arrays.sort method, but I am not observing compile error, instead getting runtime error.  Kindly explain why compile time error is not shown in above scenario</p>\n<p>Below is code snippet</p>\n<pre><code>package com.vrk.inheritance;\n\nimport java.time.*;\nimport java.util.Arrays;\n\npublic class Employee\n{\n   private String name;\n   private double salary;\n   private LocalDate hireDay;\n\n   public Employee(String name, double salary, int year, int month, int day)\n   {\n      this.name = name;\n      this.salary = salary;\n      hireDay = LocalDate.of(year, month, day);\n   }\n\n   public String getName()\n   {\n      return name;\n   }\n\n   public double getSalary()\n   {\n      return salary;\n   }\n\n   public LocalDate getHireDay()\n   {\n      return hireDay;\n   }\n\n   public void raiseSalary(double byPercent)\n   {\n      double raise = salary * byPercent / 100;\n      salary += raise;\n   }\n   \n   /*public int compareTo(Object otherObject) {\n       System.out.println(&quot;Employee compareTo called&quot;);\n       return 0;\n   }*/\n   \n   /**\n    * equalTo function in employee. Created on 8th Sep 2024\n    * @param another object to compare to this object\n    */\n   public boolean equals(Object otherObject) {\n       // quick test to check if objects are identical\n       if ( this == otherObject) return true;\n       \n       // must return false if the explicit parameter is null\n       if(otherObject == null) return false;\n       \n       // if the classes don't match, they can't be equal\n       if (getClass() != otherObject.getClass()) return false;\n       \n       // now we know otherObject is a non-null Employee\n       var other = (Employee) otherObject;\n       \n       // test whether the fields have identical value\n       // Not sure in my setup below line is not working, but online compiler it is working. \n       // java.util.Objects.equals(this.hireDay, other.hireDay);\n        return true;\n   }\n   \n   public static void main(String[] args) {\n       var staff = new Employee[3];\n\n       // fill the staff array with Manager and Employee objects\n       staff[0] = new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1);\n       staff[1] = new Employee(&quot;Tommy Tester&quot;, 40000, 1990, 3, 15);\n       staff[1] = new Employee(&quot;Ravi Tester&quot;, 60000, 1999, 4, 16);\n       Arrays.sort(staff);\n   }\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}