{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "spring-data-jpa",
      "record"
    ],
    "owner": {
      "account_id": 1835763,
      "reputation": 2040,
      "user_id": 1666206,
      "user_type": "registered",
      "accept_rate": 67,
      "profile_image": "https://i.sstatic.net/QKAVW.jpg?s=256",
      "display_name": "tjholmes66",
      "link": "https://stackoverflow.com/users/1666206/tjholmes66"
    },
    "is_answered": true,
    "view_count": 258,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1740517148,
    "creation_date": 1740080651,
    "last_edit_date": 1740517148,
    "question_id": 79455666,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79455666/record-class-with-findall-with-spring-data-jpa",
    "title": "Record Class with findAll with Spring Data JPA",
    "body": "<p>I am using SpringBoot 3.4.2 (latest as of right now) I can create RESTful controllers that access the Service, and then we make a Repository call to get data from the database which all works 100%.   I completely understand in why we should NOT, in most cases, return the Entity to whatever is calling the RESTful API.  In some cases we simply do not want data to be returned, and in other cases we want to aggregate some data or do computations on data, and so a DTO would be used for this.  I wholly embrace the Entity &lt;&gt; DTO mapping.</p>\n<p>Now, I see that a Record exists, and this with SMALL data can be used as a DTO.  From what I have read that Records are immutable.  I have read a lot of literature on DTO (with Lombok) is different than Records.   Now if I really want to keep my Repositories as they are, I can simply write for myself the code to map from Entities to Records, but do we want to do this?  From other examples on the Internet, I can see we can use Spring Data JPA to load data directly into Records, and if the fields are exactly the same then the mapping is quite easy.  If in some reasons the data is different, then there is a way to fix that also, but I'm not there yet.  So, I have a question, and it's a small issue, but maybe I am missing something.   So, let me put the code out there.</p>\n<pre><code>@Entity\n@Table(name = &quot;company&quot;)\npublic class CompanyEntity implements Serializable\n{\n   @Id\n   @GeneratedValue(strategy = GenerationType.IDENTITY)\n   @Column(name = &quot;company_id&quot;)\n   private long companyId;\n   @Column(name = &quot;active&quot;)\n   private boolean active;\n   @Column(name = &quot;code&quot;)\n   private String companyCode;\n   @Column(name = &quot;name&quot;)\n   private String companyName;\n   @Column(name = &quot;description&quot;)\n   private String description;\n   @Column(name = &quot;address1&quot;)\n   private String address1;\n   @Column(name = &quot;address2&quot;)\n   private String address2;\n   @Column(name = &quot;city&quot;)\n   private String city;\n   @Column(name = &quot;state&quot;)\n   private String state;\n   @Column(name = &quot;zip&quot;)\n   private String zip;\n}\n</code></pre>\n<p>And now we have the Record class with the same exact fields:</p>\n<pre><code>public record CompanyRecord(long companyId, boolean active, \nString companyCode, \nString companyName, String description, String address1, \nString address2, String city, String state, String zip)\nimplements Serializable {}\n</code></pre>\n<p>And now I have the Repository code:</p>\n<pre><code>@Repository(&quot;CompanyRepository&quot;)\npublic interface CompanyRepository extends JpaRepository&lt;CompanyEntity, Long&gt;\n{\n    // This works great!  No issus here!\n    public CompanyRecord findByCompanyId(long companyId);\n\n    // This works great!  No issus here!\n    public List&lt;CompanyEntity&gt; findAll();\n\n    // This does NOT work!\n    // IDE Reported Error:\n    // The return type is incompatible with ListCrudRepository&lt;CompanyEntity,Long&gt;.findAll()\n    public List&lt;CompanyRecord&gt; findAll();\n\n   // This works great!  No issus here!\n   List&lt;CompanyRecord&gt; findByCompanyCode(String companyCode);\n}\n</code></pre>\n<p>So, I don't know if this is more of a JPARepository issue, or how to fix this.   What is even more confusing is the JUnit Testing.</p>\n<pre><code>@Test\npublic void testFindById_Entity()\n{\n    // works as expected, no problems\n    // surprising because the Repo wanted a CompanyRecord, and not an entity\n    long companyId = 1;\n    CompanyEntity companyEntity = companyRepository.findById(companyId).orElse(null);\n    assertNotNull(companyEntity);\n}\n\n@Disabled\n@Test\npublic void testFindById_Record()\n{\n    long companyId = 1;\n    // doesn't work, and gives an IDE error\n    // Type mismatch: cannot convert from CompanyEntity to CompanyRecord\n    // I would expect this to work since the interface specifically asks for a Record \n    CompanyRecord companyRecord = companyRepository.findById(companyId).orElse(null);\n    assertNotNull(companyRecord);\n}\n\n@Test\npublic void testFindByCode_Entity()\n{\n    String companyCode = &quot;IBM&quot;;\n    // does not work, AS EXPECTED since the interface wants a record\n    List&lt;CompanyEntity&gt; companyEntityList = companyRepository.findByCompanyCode(companyCode);\n    assertNotNull(companyEntityList);\n}\n\n@Test\npublic void testFindByCode()\n{\n    String companyCode = &quot;IBM&quot;;\n    // this works as expected, the interface asks for a record\n    List&lt;CompanyRecord&gt; companyRecordList = companyRepository.findByCompanyCode(companyCode);\n    assertNotNull(companyRecordList);\n}\n\n@Test\npublic void testFindAll_Entity()\n{\n    // works as expected\n    List&lt;CompanyEntity&gt; companyEntityList = companyRepository.findAll();\n    assertNotNull(companyEntityList);\n}\n</code></pre>\n<p>I absolutely see some very confusing points trying to do this this way.  Sometimes thing work as I would expect them to, and sometimes they don't.   Makes me feel like 'Record' isn't quite ready for prime time.   Or, I could go back to the manual way of using an Entity for all my repository work, and manually ceate records in the Service, but I can see how using a Record in the Spring Data JPA would save boilerplate code.</p>\n<p>Anyone have similar experiemces, or could shed more light on Java Record in Spring Data JPA.   Tha Baeldung page is great information, but in their examples they are defintely using criteriaQuery, and I'm not going down that road.  I usually use HQL for my specific requests and that might be what I have to do.</p>\n<p>UPDATE #1</p>\n<p>So, I followed the comments on here, and I completely understand the requirements of Hibernate Entities and Records, I get it.   I also followed the other comments about using JPQL, and although it seems to compile completely failed my JUnit Test because the converter didn't exist, so I got that error.</p>\n<p>So, it seems, in the Repository Interface:</p>\n<pre><code>// gives Convert error\n@Query(value = &quot;SELECT c from CompanyEntity c&quot;)\nList&lt;CompanyRecord&gt; companyRecordList findAllCustomerRecords();\n\n// I think this might work but didn't test it\n@Query(value = &quot;SELECT new CompanyRecord( c.id, c.name, etc) from CompanyEntity c&quot;)\nList&lt;CompanyRecord&gt; companyRecordList findAllCustomerRecords();\n</code></pre>\n<p>So, I know Records have been out since Java14, and more officially on Java16, but in all the places I've worked, we've never used the Record object.   This whole Record thing came to me when I was working on a personal project to use GraphQL, and I was surprised to see they used Record.  I was trying to use Record in a way that seemed to be the industry standard way of doing things, but I don't think that's quite been established yet.</p>\n<p>At this point, I understand why Record exists, but I don't think I need to replace DTOs with Records.  We have various tools that convert Entity to DTO and vice-versa, but it doesn't seem to have caught up to Records yet.  I was hoping to leverage Spring Data JPA for that mapping, but it seems like that take some effort, and IMHO, that's not the right place to be doing that.</p>\n<p>So, Thanks for all the answers, I look forward to more thoughts on this, but I'm going to keep my Repository strictly with Entity and go back to using DTO's (with Lombok) and using MapStruct or other tools to do my mapping.  Seems like a cleaner solution with less boiler-plate code.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}