{
  "question": {
    "tags": [
      "java",
      "overloading",
      "overload-resolution"
    ],
    "owner": {
      "account_id": 14880733,
      "reputation": 33,
      "user_id": 10745479,
      "user_type": "registered",
      "profile_image": "https://lh3.googleusercontent.com/-f4D1XlV9S9s/AAAAAAAAAAI/AAAAAAAAAAA/AGDgw-jaJs5hTjU3TDF_YwI-1tuOZlj9_w/mo/s256-rj/photo.jpg",
      "display_name": "gambit36",
      "link": "https://stackoverflow.com/users/10745479/gambit36"
    },
    "is_answered": true,
    "view_count": 103,
    "accepted_answer_id": 79853063,
    "answer_count": 1,
    "score": 2,
    "last_activity_date": 1766433080,
    "creation_date": 1766417144,
    "last_edit_date": 1766425680,
    "question_id": 79853009,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79853009/how-does-java-resolve-method-overloading-ambiguity-when-competing-methods-have-p",
    "title": "How does Java resolve method overloading ambiguity when competing methods have parameters with similar depth hierarchy",
    "body": "<p>Here's a very basic program I wrote to test how Java overloading is resolved when an exact match is not found, and what priority is assigned to other matching methods.</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.io.*;\npublic class Main\n{\n   \n   \n    //NOTE: Comparable&lt;Integer&gt; ties with Serializable and with Number, however Number wins over Serializable\n   \n    // static void test(Number x) {\n    //     System.out.println(&quot;here in Number x&quot;);\n    // }\n   \n   \n    // static void test(Serializable x) {\n    //     System.out.println(&quot;here in Serializable x&quot;);\n    // }\n   \n    // static void test(Comparable&lt;Integer&gt; x) {\n    //     System.out.println(&quot;here in Comparable&lt;Integer&gt; x&quot;);\n    // }\n\n   \npublic static void main(String[] args) {\n    test(10);\n    }\n}\n</code></pre>\n<p><strong>When test(Number x) is commented out:</strong>\n<code>test(Comparable\\&lt;Integer\\&gt; x)</code> gives an ambiguous reference error when it's present alongside <code>test(Serializable x)</code>.</p>\n<p><strong>When test(Serializable x) is commented out</strong>\nThe same happens for <code>test(Comparable\\&lt;Integer\\&gt; x)</code> and <code>test(Number x)</code>.</p>\n<p>So I assumed that all three of these must be interpreted as having the same hierarchy depth by the JVM. This makes sense, since <code>Integer</code> subclasses <code>Number</code> and implements <code>Serializable</code> and <code>Comparable&lt;Integer&gt;</code>.</p>\n<p>However, <strong>when I comment out the <code>Comparable&lt;Integer&gt;</code> method</strong>, then <code>Number</code> wins over <code>Serializable</code>, and test(Number x) is called</p>\n<p>To put it simply, I assume a sort of transitivity where if method A clashes with method B, and method A also clashes with method C, then method B must also clash with method C, but that's not the case.</p>\n<p>Can someone please explain what's going on here?</p>\n<p>For context, I used an online compiler to test the code. I mention this because I'm not sure if this behavior is JVM implementation-specific.</p>\n<p>Edit: I did come across <a href=\"https://stackoverflow.com/questions/22590914/overloading-method-priority-in-java\">method overloading priority in Java</a>, but that does not answer my question. That material explains why certain methods are prioritized over others, but I am asking: why is it that when method A ties with method B and C, method B and method C don't give the same ambiguity error? Maybe I'm missing something very basic here.</p>\n<p>Edit 2: I removed the additional question about varargs (as suggested by the reviewer). Maybe I'll post another question for that.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}