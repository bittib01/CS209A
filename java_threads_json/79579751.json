{
  "question": {
    "tags": [
      "java",
      "spring",
      "spring-transactions"
    ],
    "owner": {
      "account_id": 10788038,
      "reputation": 291,
      "user_id": 7936458,
      "user_type": "registered",
      "accept_rate": 73,
      "profile_image": "https://www.gravatar.com/avatar/74fc375c71a8986319197198ba7b0ed5?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Rodik",
      "link": "https://stackoverflow.com/users/7936458/rodik"
    },
    "is_answered": false,
    "view_count": 123,
    "answer_count": 2,
    "score": 2,
    "last_activity_date": 1745677021,
    "creation_date": 1744909663,
    "last_edit_date": 1744965788,
    "question_id": 79579751,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79579751/spring-transactional-commit-not-visible-after-method-return",
    "title": "Spring @Transactional – Commit not visible after method return?",
    "body": "<p>I’m working on a modular Java application using <strong>Spring</strong> <code>5.1.20.RELEASE</code>, where a <strong>core module</strong> is used by several client-specific instances. Each instance has its own configuration and business rules.</p>\n<p>In one particular flow, I’m encountering a strange issue with the <code>@Transactional</code> behavior.</p>\n<p><strong>✅ The setup :</strong></p>\n<p>I have a class that saves an <strong>Order</strong> entity and then immediately triggers further processing:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Service\npublic class OrderRetryFacade {\n\n    private final OrderService orderService;\n    private final OrderProcessingStrategy orderProcessingStrategy;\n\n    public OrderRetryFacade(OrderService orderService, OrderProcessingStrategy orderProcessingStrategy) {\n        this.orderService = orderService;\n        this.orderProcessingStrategy = orderProcessingStrategy;\n    }\n\n    public void handleRetry(Order order) {\n        orderService.saveRetryOrder(order);\n        orderProcessingStrategy.process(order);\n    }\n}\n</code></pre>\n<p>The <strong>OrderService</strong> saves the order like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Service\npublic class OrderServiceImpl implements OrderService {\n\n    private final OrderRepository orderRepository;\n\n    public OrderServiceImpl(OrderRepository orderRepository) {\n        this.orderRepository = orderRepository;\n    }\n\n    @Override\n    @Transactional\n    public void saveRetryOrder(Order order) {\n        orderRepository.save(order);\n    }\n}\n</code></pre>\n<p>Later, another component (triggered asynchronously via Apache Camel) tries to retrieve the order by ID from the database.</p>\n<p><strong>❗ The issue:</strong></p>\n<p>Although the <code>saveRetryOrder()</code> method runs successfully and the entity is assigned an ID, the <code>OrderProcessingStrategy.process(order)</code> call results in a failure — because <strong>another component can't find the order in the database</strong>.</p>\n<p>We get a <code>NullPointerException</code> because the order can't be retrieved by ID at that point.</p>\n<p><strong>❓ The question:</strong></p>\n<p>My understanding was that as soon as a method annotated with <code>@Transactional</code> completes, the changes are persisted and committed to the database.</p>\n<p>But based on this behavior, it seems the transaction is still open when process(order) is called, meaning the insert is not visible to other components (like Camel) yet.</p>\n<p>Is this expected in Spring?</p>\n<blockquote>\n<p>Does the actual database commit only happen after the outermost method\nin the call stack completes (i.e., the end of the full transaction\nscope), not immediately after the <code>@Transactional</code> method returns?</p>\n</blockquote>\n<p>Any insights or recommended best practices?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}