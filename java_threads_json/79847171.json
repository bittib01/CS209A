{
  "question": {
    "tags": [
      "java",
      "arrays"
    ],
    "owner": {
      "account_id": 45011036,
      "reputation": 15,
      "user_id": 32052378,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/06e2e3d9871ec4247fa476ccaf0bd80d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Jett McHugh",
      "link": "https://stackoverflow.com/users/32052378/jett-mchugh"
    },
    "is_answered": true,
    "view_count": 135,
    "answer_count": 2,
    "score": -1,
    "last_activity_date": 1765832222,
    "creation_date": 1765734710,
    "last_edit_date": 1765832222,
    "question_id": 79847171,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79847171/array-updating-strangely",
    "title": "Array Updating Strangely",
    "body": "<p>I'm trying to do some simulation of CPU memory allocation in Java. I've got a NEW Queue, A READY Queue, and then a block of memory, represented by an array of size 256. I'm meant to load in a series of processes into NEW, see if there is space for them in memory, and if there is, load them into the READY queue, &quot;allocate&quot; memory for them in the array, and then run processes as their turn comes up in the READY queue, deallocating as necessary. Very basic.</p>\n<p>Problem is, my code is acting strange, and I'm not sure why. It seems to be HELL BENT on skipping the allocation of every other process, so it &quot;loads&quot; 102, but skips 102, loads half of 103, skips 104, and so on. and I cannot parse WHY.</p>\n<p>The code is not fully functional, and isn't able to parse through running all jobs being put on the ready queue yet, because I saw this happening with the array and have been stuck on it. Any idea what's happening?</p>\n<p>Here's code, input, and the output so far. Pls Help <a href=\"https://i.sstatic.net/julQ0qFd.png\" rel=\"nofollow noreferrer\">Weird output skipping every other process</a></p>\n<pre class=\"lang-none prettyprint-override\"><code>101   NEW     5         4      0        50\n102   NEW     3         3      1        30\n103   NEW     4         5      2        100\n104   NEW     2         2      3        60\n105   NEW     1         6      4        40\n106   NEW     3         3      5        70\n107   NEW     2         4      6        20\n108   NEW     4         5      7        90\n109   NEW     5         3      8        50\n110   NEW     1         2      9        60\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>// Create a FIFO CPU Scheduling simulation, Incorporating memory allocation and Deallocation\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\nclass Process {\n    //Class for the processes in the queue\n    int pid, priority, burst, arrival, size, baseRegister, readyTime;\n    String processStatus;\n\n    //Need to add functionality that differentiates time in vs time started\n    // Tracks wait time, end time,  turnaround, and response time\n    //Constructor, the only type we'll need\n    public Process(int pid, String processStatus, int priority, int burst, int arrival, int size) {\n        this.pid = pid;\n        this.processStatus = processStatus;\n        this.priority = priority;\n        this.burst= burst;\n        this.arrival = arrival;\n        this.size = size;\n        this.baseRegister = -1;\n    }\n\n    //Overwrite print to string method for the sake of printing the queue\n    public String toString() {\n        return this.pid +  &quot; &quot; + this.processStatus + &quot; &quot; + this.burst + &quot; &quot; + this.arrival + &quot; &quot; + this.baseRegister;\n    }\n\n    //Getters\n    public int getPid() { return this.pid; }\n    public int getBurst(){ return this.burst; }\n    public int getArrival(){ return this.arrival; }\n    public int getSize() { return this.size; }\n    public int getBaseRegister() { return this.baseRegister; }\n\n    //Setters\n    public void setBaseRegister(int baseRegister) { this.baseRegister = baseRegister; }\n    public void setProcessStatus(String s) { this.processStatus = s; }\n    public void setReadyTime(int n) { this.readyTime = n; }\n\n}\n\n//Add functionality to print out memory array\n//Add functionality of memory array\npublic class Main {\n    //Method to print memory array\n    public static void printMemory(String[] arr){\n        if(arr.length!=256){\n            System.out.println(&quot;Array is not a memory block&quot;);\n            return;\n        }\n        for(int i=0; i&lt;256; i+=16){\n            for(int j=0; j&lt;16; j++){\n                System.out.print(arr[j+i] + &quot; &quot;);\n            }\n            System.out.println(&quot;&quot;);\n        }\n    }\n\n    //Method to scan memory for a space that fits\n    public static int spaceInMem(String[] arr, int n){\n        for(int i = 0; i&lt;arr.length; i++){\n            if(arr[i].equals(&quot;---&quot;)){\n                for(int x = 1; x&lt;n; x++){\n                    if(!arr[i+x].equals(&quot;---&quot;)){\n                        i=i+x;\n                        break;\n                    }\n                    if(x==n-1 &amp;&amp; arr[i+x].equals(&quot;---&quot;)){\n                        return i;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n\n    public static void addToMem(String[] arr, int pid, int size, int index){\n        for(int i=index; i&lt;size; i++){\n            arr[i] = &quot;&quot; + pid;\n        }\n    }\n\n    public static void removeFromMem(String[] arr, int baseRegister, int size){\n        for(int i = baseRegister; i&lt;size; i++){\n            arr[i] = &quot;---&quot;;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        //variables to declare\n        int pid, prio, burst, arrival, time, startTime, completeTime,\n                numProcesses, size, totalWT, totalTT, totalRT, remainingTime;\n        String status;\n        Process p, runningProcess;\n        boolean processIsRunning = false;\n        String[] memory = new String[256];\n        Arrays.fill(memory, &quot;---&quot;);\n        //Import from File\n        File file = new File(&quot;data&quot;);\n        Scanner fscan = new Scanner(new FileReader(file));\n        Queue&lt;Process&gt; NEWQueue = new LinkedList&lt;&gt;();\n        Queue&lt;Process&gt; READYQueue = new LinkedList&lt;&gt;();\n\n        while(fscan.hasNext()){\n            pid = fscan.nextInt();\n            status=fscan.next();\n            prio= fscan.nextInt();\n            burst = fscan.nextInt();\n            arrival = fscan.nextInt();\n            size = fscan.nextInt();\n            NEWQueue.offer(new Process(pid, status, prio, burst, arrival, size));\n        }\n        fscan.close();\n        numProcesses = NEWQueue.size();\n        //System.out.println(&quot;PID   BURST ARRIVAL COMPLETION TURNAROUND WAITING RESPONSE&quot;);\n        time = 0;\n//        for(int i=0; i&lt;256; i++){\n//            memory[i] = &quot;&quot;+ (i+1);\n//        }\n//        printMemory(memory);\n        remainingTime = -1;\n        runningProcess = new Process(0, &quot;FALSE PROCESS&quot;,0,0,0,0);\n        while(!NEWQueue.isEmpty()){\n            System.out.println(&quot;Time: &quot; + time);\n            if(NEWQueue.peek().getArrival() == time){\n                int index = spaceInMem(memory,NEWQueue.peek().getSize());\n                if(index != -1){\n                    p = NEWQueue.remove();\n                    p.setBaseRegister(index);\n                    READYQueue.offer(p);\n                    p.setProcessStatus(&quot;READY&quot;);\n                    p.setReadyTime(time);\n                    System.out.println(&quot;Process &quot; + p.getPid() + &quot; added to READY QUEUE at time &quot; + time);\n                    addToMem(memory, p.getPid(), p.getSize(), p.getBaseRegister());\n                    printMemory(memory);\n                }\n            }\n            if(!processIsRunning){\n                if(!READYQueue.isEmpty()){\n                    runningProcess = READYQueue.remove();\n                    runningProcess.setProcessStatus(&quot;RUNNING&quot;);\n                    remainingTime = runningProcess.getBurst() -1;\n                    System.out.println(&quot;Process &quot; + runningProcess.getPid() + &quot; has begun running at time = &quot; + time);\n                    processIsRunning = true;\n                }\n            } else{\n                remainingTime--;\n                if(remainingTime==0){\n                    System.out.println(&quot;Process &quot; + runningProcess.getPid() + &quot; has finished running at time = &quot; + time);\n                    runningProcess.setProcessStatus(&quot;TERMINATED&quot;);\n                    removeFromMem(memory, runningProcess.getBaseRegister(), runningProcess.getSize());\n                    printMemory(memory);\n                    processIsRunning = false;\n                }\n\n            }\n            time++;\n//            totalWT += startTime - p.getArrival();\n//            totalTT += completeTime - p.getArrival();\n//            totalRT += startTime - p.getArrival();\n            //System.out.printf(&quot;%-7d%-6d%-8d%-11d%-11d%-8d%-8d%n&quot;, p.getPid(),p.getBurst(),p.getArrival(),completeTime, completeTime - p.getArrival(),startTime - p.getArrival(),startTime - p.getArrival());\n        }\n//        System.out.println(&quot;Average Turnaround Time: &quot; + totalTT/numProcesses);\n//        System.out.println(&quot;Average Waiting Time: &quot; + totalWT/numProcesses);\n//        System.out.println(&quot;Average Response Time: &quot; + totalRT/numProcesses);\n    }\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}