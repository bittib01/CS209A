{
  "question": {
    "tags": [
      "java",
      "concurrency",
      "semaphore",
      "java.util.concurrent",
      "java-threads"
    ],
    "owner": {
      "account_id": 14010051,
      "reputation": 260,
      "user_id": 10118965,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/61afd55894624ae8f6e4189b68db1f30?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "davidalayachew",
      "link": "https://stackoverflow.com/users/10118965/davidalayachew"
    },
    "is_answered": true,
    "view_count": 120,
    "closed_date": 1703984562,
    "accepted_answer_id": 77737897,
    "answer_count": 1,
    "score": -2,
    "last_activity_date": 1714785953,
    "creation_date": 1703974346,
    "last_edit_date": 1704497265,
    "question_id": 77737564,
    "link": "https://stackoverflow.com/questions/77737564/only-one-of-my-threads-executes-when-trying-to-use-a-semaphore",
    "closed_reason": "Not suitable for this site",
    "title": "Only one of my threads executes when trying to use a Semaphore",
    "body": "<p>To my understanding, <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/Semaphore.html\" rel=\"nofollow noreferrer\"><code>java.util.concurrent.Semaphore</code></a> allows me to specify how many threads can use a resource at once. A thread can use <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/Semaphore.html#acquireUninterruptibly()\" rel=\"nofollow noreferrer\"><code>Semaphore.acquireUninterruptibly()</code></a> to consume the limited number of &quot;slots&quot; in the Semaphore. Once the thread is done, a call should be made to <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/Semaphore.html#release()\" rel=\"nofollow noreferrer\"><code>Semaphore.release()</code></a> in order to give back the slot, so that another thread that is waiting (<code>acquireUninterruptibly()</code> makes the thread wait) can grab the new slot. I am aware of the fairness policy, and ordering of the threads is irrelevant for my purposes. What matters is that all of the threads execute.</p>\n<p>And that's my problem -- only one of the threads executes. Here is my code.</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.Semaphore;\n \npublic class Main\n{\n \n   private static final Path rootbarFolder = Path.of(&quot;C:&quot;, &quot;Users&quot;);\n \n   private boolean REATTEMPT_UPON_FAILURE = true;\n \n   public static void main(final String[] args) throws Exception\n   {\n  \n      new Main();\n  \n   }\n \n   private Main() throws Exception\n   {\n  \n      javax.swing.SwingUtilities\n         .invokeLater\n         (\n            () -&gt;\n            {\n           \n               javax.swing.JOptionPane.showMessageDialog(null, &quot;Close this popup window to make the program exit on failure&quot;);\n           \n               this.REATTEMPT_UPON_FAILURE = false;\n           \n            }\n         )\n         ;\n  \n      final List&lt;Path&gt; fooPathList = this.getListOfbarfooPaths();\n  \n      final List&lt;Thread&gt; fooPathThreads = new ArrayList&lt;&gt;();\n  \n      final Semaphore semaphore = new Semaphore(1, true);\n  \n      KICK_OFF_THREADS:\n      for (final Path fooPath : fooPathList)\n      {\n     \n         final Thread fooPathThread = this.createThread(semaphore, fooPath);\n     \n         fooPathThreads.add(fooPathThread);\n     \n         semaphore.acquireUninterruptibly();\n     \n         fooPathThread.start();\n        \n      }\n  \n      JOIN_THREADS:\n      for (final Thread fooPathThread : fooPathThreads)\n      {\n     \n         fooPathThread.join();\n        \n      }\n  \n   }\n \n   private Thread createThread(final Semaphore semaphore, final Path fooPath)\n   {\n  \n      return\n         Thread\n            .ofPlatform()\n            .unstarted\n            (\n               () -&gt;\n               {\n              \n                  try\n                  {\n                 \n                     int exitCode = -1;\n                 \n                     while (exitCode != 0 &amp;&amp; this.REATTEMPT_UPON_FAILURE)\n                     {\n                    \n                        System.out.println(&quot;\\n\\nAttempting &quot; + fooPath);\n\n                        final Process fooProcess = this.createzilklaquo(fooPath);\n                    \n                        exitCode =                             //Tells us the status of the run\n                           fooProcess.waitFor();           //Don't close down the JVM before this process finishes running!\n                    \n                        System.out.println(fooPath + &quot; -- fooProcess exitCode = &quot; + exitCode);\n                        Thread.sleep(10_000);\n                    \n                     }\n                 \n                  }\n                 \n                  catch (final Exception exception)\n                  {\n                 \n                     throw new RuntimeException(exception);\n                 \n                  }\n                 \n                  finally\n                  {\n                 \n                     semaphore.release();\n                 \n                  }\n              \n               }\n            )\n            ;\n  \n   }\n \n   private Process createzilklaquo(final Path fooPath)\n   {\n  \n      try\n      {\n     \n         final ProcessBuilder fooProcessBuilder =\n            new\n               ProcessBuilder\n               (\n                  &quot;cmd&quot;,\n                  &quot;/C&quot;,\n                  &quot;THIS_COMMAND_WILL_FAIL&quot;\n               )\n               .directory\n               (\n                  rootbarFolder              //\n                     .resolve(fooPath)      //\n                     .toFile()                  //\n               )\n               .inheritIO()\n               ;\n     \n         fooProcessBuilder\n            .environment()\n            .put(&quot;SUB_FOLDER&quot;, fooPath.getFileName().toString())\n            ;\n     \n         final Process fooProcess =\n            fooProcessBuilder\n               .start()                            //Kicks off the newly created Process\n               ;\n     \n         // final int exitCode =                   //Tells us the status of the run\n            // fooProcess.waitFor();           //Don't close down the JVM before this process finishes running!\n      //\n         // System.out.println(&quot;fooProcess exitCode = &quot; + exitCode);\n     \n         return fooProcess;\n     \n      }\n     \n      catch (final Exception e)\n      {\n     \n         throw new RuntimeException(e);\n     \n      }\n  \n   }\n \n   private List&lt;Path&gt; getListOfbarfooPaths() throws Exception\n   {\n  \n      final Process fooListProcess =\n         new\n            ProcessBuilder\n            (\n               &quot;cmd&quot;,                        //Since this is Windows, CMD is the easiest way to accomplish what we want\n               &quot;/C&quot;,                         //Starts an instance of CMD, does the below commands, outputs/pipes them, then immediately closes\n               &quot;dir&quot;,                        //Lists all contents in the folder\n               &quot;/A:D&quot;,                       //Filters the contents down to only directories\n               &quot;/B&quot;                          //Removes extra metadata -- just the names\n            )\n            .directory\n            (\n               rootbarFolder              //Perform the action in the root bar folder\n                  .toFile()                  //Wish I could give a Path instead of a File\n            )\n            //.inheritIO()                     //Forward all Input and Output to the same as Java's (commented out because it drowns out my logs)\n            .start()                         //Kicks off the newly created Process\n            ;\n  \n      final int exitCode =                   //Tells us the status of the run\n         fooListProcess.waitFor();       //Don't close down the JVM before this process finishes running!\n  \n      System.out.println(&quot;fooListProcess exitCode = &quot; + exitCode);\n  \n      final String fooListRawOutput =    //The raw output from the newly created process\n         new\n            String\n            (\n               fooListProcess            //Now that the process has finished, we can pull from it\n                  .getInputStream()          //The way that you quo the OUTPUT of the process is to call getINPUTStream -- very unintuitive\n                  .readAllBytes()            //Let's quo all of it\n            )\n            ;\n  \n      final List&lt;Path&gt; fooList =       //The list of foos that we will be working with\n         fooListRawOutput                //We will be extracting it from the raw output\n            .lines()                         //It's a new-line-separated list, so split by line\n            .map(rootbarFolder::resolve)  //Turn it into a Path that is the rootbarFolder resolved to the sub-folder -- root -&gt; root/subFolder\n            .toList()                        //Finally, put the contents into a list\n            ;\n  \n      fooList.forEach(System.out::println);\n  \n      return fooList;\n  \n   }\n \n}\n</code></pre>\n<p>Again, this is a fake example based off a real one that I cannot show because of company policy.</p>\n<p>I have a folder with many subfolders in it. For example's sake, I am pointing it at the Users folder in the Windows C:/ drive. If you are Linux or something else, feel free to change that <code>Path</code> variable at the top to point to a different directory on your machine. But have it be a directory with multiple items in that directory.</p>\n<p>So, on my machine, here are the folders in my C:/Users folder.</p>\n<pre><code>C:\\Users\\All Users\nC:\\Users\\david\nC:\\Users\\Default\nC:\\Users\\Default User\nC:\\Users\\Public\n</code></pre>\n<p>But when I run this program, it will only make a print statement for <code>C:\\Users\\All Users</code>, not for any of the other lines. That implies to me that this program is not attempting the other threads.</p>\n<p>This is what it prints.</p>\n<pre><code>$ java Main.java\nfooListProcess exitCode = 0\nC:\\Users\\All Users\nC:\\Users\\david\nC:\\Users\\Default\nC:\\Users\\Default User\nC:\\Users\\Public\nAttempting C:\\Users\\All Users\n'THIS_COMMAND_WILL_FAIL' is not recognized as an internal or external command,\noperable program or batch file.\nC:\\Users\\All Users -- fooProcess exitCode = 1\n</code></pre>\n<p>So, we can see that it attempted the All Users folder, but then it just stopped.</p>\n<p>I was expecting something more like this.</p>\n<pre><code>java Main.java\nfooListProcess exitCode = 0\nC:\\Users\\All Users\nC:\\Users\\david\nC:\\Users\\Default\nC:\\Users\\Default User\nC:\\Users\\Public\nAttempting C:\\Users\\All Users\n'THIS_COMMAND_WILL_FAIL' is not recognized as an internal or external command,\noperable program or batch file.\nC:\\Users\\All Users -- fooProcess exitCode = 1\nAttempting C:\\Users\\david\n'THIS_COMMAND_WILL_FAIL' is not recognized as an internal or external command,\noperable program or batch file.\nC:\\Users\\david -- fooProcess exitCode = 1\n\n...repeat for all other folders\n</code></pre>\n<p>But anyways, I want to do multithreading to do some work on these subfolders. The work I am doing fails often, so I have a while loop listening to the exitCode, and reattempting. However, for reasons that I cannot say, I need to have an escape hatch that says &quot;From this point in time forward, any future failures should end the threads execution&quot;. That is what the <code>JOptionPane</code> is for. I know it is a terrible example, but the point is that it switches a <code>boolean</code> flag, which is what I need it to do.</p>\n<p>Here's my problem though. When I switch the flag, the subsequent threads which should be waiting on the Semaphore to have a free slot don't get kicked off.</p>\n<p>As for what the above code is literally doing, it attempts a command which is guaranteed to fail, triggering the while loop mechanic I mentioned. Then, the thread sleeps for 10 seconds, and tries again.</p>\n<p>I have a popup that allows me to set the flag when I choose by pressing OK. When I do, the first thread completes, but the next thread never starts.</p>\n<p>Now, I know the JVM can take multithreading &quot;shortcuts&quot; (for lack of a better term), and that's most likely what is happening here. But I don't know if that is the cause.</p>\n<p>Why aren't the rest of my threads getting kicked off?</p>\n<p><strong>EDIT</strong> - I'm noticing some close votes, claiming that my question is not relevant for StackOverflow. Unfortunately, that is too broad for me to know how to improve my question.</p>\n<p>My entire question is this -- I am having trouble understanding why basic libraries from the Java Standard library aren't doing what I think they should. I am clearly communicating my understanding of them, I showed my attempt, and my example is simple, minimal, and reproducible (as far as my computer can tell, anyways). If there is something further I should do, or I failed to do something, please let me know specifically so that I can make the change.</p>\n<p><strong>EDIT 2</strong> - Oh, apparently, if you click on the close votes, and then click on the selection, they will go into more detail. Not very intuitive, but I understand now.</p>\n<p>I have added all the requested info. Embarrassingly enough, that also gave me a push in the right direction and I was able to solve it myself. I have posted and accepted my answer below -- the solution was embarrassingly simple.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}