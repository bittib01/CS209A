{
  "question": {
    "tags": [
      "java",
      "jdbc",
      "connection-pooling",
      "executorservice",
      "virtual-threads"
    ],
    "owner": {
      "account_id": 3426540,
      "reputation": 344,
      "user_id": 2872163,
      "user_type": "registered",
      "accept_rate": 100,
      "profile_image": "https://www.gravatar.com/avatar/6e342ea43e2abfee1dc2f943ad216ce3?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Shoaib",
      "link": "https://stackoverflow.com/users/2872163/shoaib"
    },
    "is_answered": true,
    "view_count": 5225,
    "accepted_answer_id": 78494927,
    "answer_count": 2,
    "score": 3,
    "last_activity_date": 1721807231,
    "creation_date": 1715783857,
    "last_edit_date": 1715841358,
    "question_id": 78484693,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78484693/managing-jdbc-connections-using-java-virtual-threads",
    "title": "Managing JDBC Connections using Java Virtual Threads",
    "body": "<p>We have a service in Java 17 which executes logic on our end sends request to a third party system. The response time from the third party system is around 800-1400ms.\nWe have a ThreadPoolExecutor for this with a size of 12 (cannot further increase it due to infrastructure limitations)</p>\n<p>Our request sending rate was 5-8 requests/S due to the response time of the 3rd party system. To increase throughput we are upgrading to Java 21 to use Virtual Threads. However, during development testing there seems to be another issue being faced.</p>\n<p>Our request sending rate has increased to around 50 requests/s. But we are facing Exceptions related to JDBC connection request failure. My db connection pool size must be around 100.</p>\n<p>When my service starts there are 10 connections belonging to my microservice.\nWhen sending requests using ThreadPoolExecutor: 13 additional connections so total 23.\nWhen using newVirtualThreadPerTaskExecutor: total of 94 connections</p>\n<p>I use the following query to monitor my PostGre Database V13.9</p>\n<pre><code>SELECT pid, datname, usename, application_name, client_addr, client_port, backend_start, query_start, state_change, query, state\nFROM pg_stat_activity where application_name ='PostgreSQL JDBC Driver';\n</code></pre>\n<p>Exceptions:</p>\n<pre><code>org.springframework.transaction.CannotCreateTransactionException: Could not open JPA EntityManager for transaction\n    at org.springframework.orm.jpa.JpaTransactionManager.doBegin(JpaTransactionManager.java:466) ~[spring-orm-6.1.2.jar:6.1.2]\n    at org.springframework.transaction.support.AbstractPlatformTransactionManager.startTransaction(AbstractPlatformTransactionManager.java:531) ~[spring-tx-6.1.2.jar:6.1.2]\n    at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:405) ~[spring-tx-6.1.2.jar:6.1.2]\n    at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:610) ~[spring-tx-6.1.2.jar:6.1.2]\n</code></pre>\n<pre><code>    at java.base/java.util.concurrent.ThreadPerTaskExecutor$TaskRunner.run(ThreadPerTaskExecutor.java:314) ~[na:na]\n    at java.base/java.lang.VirtualThread.run(VirtualThread.java:309) ~[na:na]\nCaused by: org.hibernate.exception.GenericJDBCException: Unable to acquire JDBC Connection [FATAL: remaining connection slots are reserved for non-replication superuser connections] [n/a]\n</code></pre>\n<pre><code>at java.base/java.util.concurrent.ThreadPerTaskExecutor$TaskRunner.run(ThreadPerTaskExecutor.java:314) ~[na:na]\n    at java.base/java.lang.VirtualThread.run(VirtualThread.java:309) ~[na:na]\nCaused by: org.hibernate.exception.GenericJDBCException: Unable to acquire JDBC Connection [FATAL: remaining connection slots are reserved for non-replication superuser connections] [n/a]\n    at org.hibernate.exception.internal.StandardSQLExceptionConverter.convert(StandardSQLExceptionConverter.java:63) ~[hibernate-core-6.4.1.Final.jar:6.4.1.Final]\n</code></pre>\n<p>What I understand is when using ThreadPoolExecutor of 12 threads, each thread makes an connection and uses that. When using Virtual Threads, as soon as any Virtual Thread gets busy in response waiting, or Thread.sleep, another Virtual Thread takes lead. As soon as I initiate a load test, I notice a burst of connections, some resulting in exceptions (For example 11 requests failed out of 1500 (due to JDBC error)), and then the process going forward moves smoothly utilising the max 94 connections currently that I have.</p>\n<p>Question is, how do I resolve this, and limit the number of processes initiated at a time. And more importantly, limit the number of connections/resuse connections created to the database. I have multiple other applications to the database, so will not be able to increase them much.</p>\n<p>I have tried using System property &quot;jdk.virtualThreadScheduler.maxPoolSize&quot; by passing the VM Arugment -Djdk.virtualThreadScheduler.maxPoolSize=5</p>\n<p>But the exception still occurs even if set -Djdk.virtualThreadScheduler.maxPoolSize=1</p>\n<p>What am I missing? Is it that Virtual Threads should be used for basic I/O tasks, CPU tasks, rather than communications with Third Party Systems?</p>\n<p>Some code of how my Virtual Threads are initiated:</p>\n<pre><code>this.executorService = Executors.newSingleThreadScheduledExecutor();\nthis.taskExecutorService = Executors.newVirtualThreadPerTaskExecutor();\n\nthis.executorService.scheduleAtFixedRate(this, 0L, this.pollingTime.toMillis(), TimeUnit.MILLISECONDS); //Called once when service starts\n\npublic void run() {\n    this.taskExecutorService.execute(//my runnable job);\n}\n</code></pre>\n<p>I also tried using counters/semaphores to restrict Virtual Threads. It reduces throughput but it still creates new connections more compared to the ThreadPoolExecutor. Is it designed this way? I suspect each virtual thread / process creates a new connection, whereas in ThreadPoolExecutor it utilises the connection allocated to its PID. Any  clarification or suggestions please?</p>\n<p><strong>Edit: (JDBC Connection Code)</strong>\nI see most delete queries in open connections, as that is what is executed when sending requests via virtual threads. Following is the code.</p>\n<pre><code>public Optional&lt;Job&gt; getNextJob(String queue) {\n    Optional&lt;Job&gt; job = Optional.empty();\n\n    try {\n        Connection connection = this.dataSource.getConnection();\n\n        try {\n            String sql = &quot;DELETE FROM scheduler_task WHERE id = (SELECT id FROM scheduler_task WHERE queue = ? and trigger_date &lt; now() LIMIT 1 FOR UPDATE SKIP LOCKED) RETURNING id, queue, reference_id, trigger_date&quot;;\n            PreparedStatement stmt = connection.prepareStatement(sql);\n\n            try {\n                ResultSet resultSet = stmt.executeQuery();\n\n                try {\n                    if (resultSet.next()) {\n                        job = Optional.of(this.mapToJob(resultSet));\n                    }\n                } catch (Throwable var14) {\n                    if (resultSet != null) {\n                        try {\n                            resultSet.close();\n                        } catch (Throwable var13) {\n                            var14.addSuppressed(var13);\n                        }\n                    }\n                    throw var14;\n                }\n\n                if (resultSet != null) {\n                    resultSet.close();\n                }\n            } catch (Throwable var15) {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (Throwable var12) {\n                        var15.addSuppressed(var12);\n                    }\n                }\n\n                throw var15;\n            }\n            if (stmt != null) {\n                stmt.close();\n            }\n        } catch (Throwable var16) {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (Throwable var11) {\n                    var16.addSuppressed(var11);\n                }\n            }\n\n            throw var16;\n        }\n        if (connection != null) {\n            connection.close();\n        }\n\n        return job;\n    } catch (SQLException var17) {\n        log.error(&quot;error&quot;, var17);\n        throw new Exception(var17);\n    }\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}