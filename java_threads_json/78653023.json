{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "spring-security"
    ],
    "owner": {
      "account_id": 29746327,
      "reputation": 1,
      "user_id": 22797287,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/c1386d541e9da90bb91cb9ebaef71477?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "the_student",
      "link": "https://stackoverflow.com/users/22797287/the-student"
    },
    "is_answered": false,
    "view_count": 283,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1719597742,
    "creation_date": 1718981333,
    "question_id": 78653023,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78653023/spring-boot-security-filter-chain-permitall-does-not-work-as-expected",
    "title": "Spring Boot security filter chain permitAll does not work as expected",
    "body": "<p>I have a project in the university and I just have the problem that permitAll is not working properly in the security filter chain.\nI have two filter chains, the first is for the UI with keycloak and the second is for public access for &quot;customer&quot; endpoints with apiKey and some should be accessible to everyone, such as for email verification.</p>\n<p>I've been sitting on this problem for a few days and can't really find a solution and I hope someone can help me.</p>\n<p>Spring Boot version: 3.0.5\nSpring Boot Security dependecies:</p>\n<pre><code>        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt;\n            &lt;version&gt;6.1.3&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-oauth2-resource-server&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>My endpoints, which are validated via apiKey, work as expected, but I don't know if it's the best solution.</p>\n<p>ApiFilter:</p>\n<pre><code>    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        logger.info(&quot;ApiKeyFilter invoked for request: &quot; + request.getRequestURI());\n        if (ApiContext.isApi()) {\n            String requestApiKey = request.getHeader(&quot;X-API-KEY&quot;);\n            String requestApiSecret = request.getHeader(&quot;X-SECRET-KEY&quot;);\n\n            if (requestApiKey == null || requestApiSecret == null) {\n                throw new BadCredentialsException(&quot;BadCredentials&quot;);\n            }\n\n            Optional&lt;ApiInformation&gt; apiInformationOptional = this.apiInformationRepository.findByApiKey(requestApiKey);\n\n            if (!apiInformationOptional.isPresent()) {\n                throw new BadCredentialsException(&quot;BadCredentials&quot;);\n            }\n\n            ApiInformation apiInformation = apiInformationOptional.get();\n\n            if (!apiInformation.getApiKey().equals(requestApiKey) || !apiInformation.getSecretKey().equals(requestApiSecret)) {\n                throw new BadCredentialsException(&quot;BadCredentials&quot;);\n            }\n\n            Optional&lt;TenantInformation&gt; tenantInformationOptional = this.tenantInformationRepository.findByOrganization(apiInformation.getOrganization());\n\n            if (!tenantInformationOptional.isPresent()) {\n                throw new BadCredentialsException(&quot;BadCredentials&quot;);\n            }\n\n            TenantInformation tenantInformation = tenantInformationOptional.get();\n\n            Authentication authentication = new UsernamePasswordAuthenticationToken(apiInformation.getApiKey(), null, new ArrayList&lt;&gt;());\n            SecurityContextHolder.getContext().setAuthentication(authentication);\n            TenantContext.setCurrentTenant(tenantInformation.getTenantId());\n        } else if (ApiContext.isActuator()) {\n            Authentication authentication = new UsernamePasswordAuthenticationToken(&quot;GenericUser&quot;, null, new ArrayList&lt;&gt;());\n            SecurityContextHolder.getContext().setAuthentication(authentication);\n        }\n\n        filterChain.doFilter(request, response);\n    }\n</code></pre>\n<p>FilterChains:</p>\n<pre><code>    @Bean\n    @Order(1)\n    @DependsOn(&quot;corsConfigurationSource&quot;)\n    public SecurityFilterChain apiServerFilterChain(\n            HttpSecurity http,\n            @Qualifier(&quot;corsConfigurationSource&quot;) CorsConfigurationSource corsConfigurationSource\n    ) throws Exception {\n        http.authorizeHttpRequests((authorize) -&gt;\n                        authorize.requestMatchers(\n                                        GenericAbstractControllerInterface.PUBLIC_API_DOC_BASE_URI + &quot;/**&quot;,\n                                        GenericAbstractControllerInterface.API_PUBLIC_URI + &quot;/**&quot;,\n                                ).permitAll()\n                                .anyRequest().authenticated()\n                )\n                .addFilterBefore(apiFilter, ChannelProcessingFilter.class)\n                .addFilterBefore(apiKeyFilter, UsernamePasswordAuthenticationFilter.class)\n                .sessionManagement(sessionManagement -&gt; sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n                .httpBasic(withDefaults())\n                .cors(cors -&gt; {\n                    cors.configurationSource(corsConfigurationSource);\n                })\n                .csrf(AbstractHttpConfigurer::disable);\n\n        return http.build();\n    }\n\n    @Bean\n    @Order(0)\n    public SecurityFilterChain resourceServerFilterChain(\n            HttpSecurity http,\n            @Qualifier(&quot;corsConfigurationSource&quot;) CorsConfigurationSource corsConfigurationSource\n    ) throws Exception {\n        List&lt;Subscription&gt; subscriptions = subscriptionRepository.findAll();\n        List&lt;String&gt; allRoles = subscriptions.stream()\n                .map(subscription -&gt; subscription.getRoles().split(&quot;,&quot;)) \n                .flatMap(Arrays::stream) \n                .collect(Collectors.toList());\n        allRoles.add(&quot;ORGANIZATION_ADMIN&quot;);\n        allRoles.add(&quot;ORGANIZATION_USER&quot;);\n\n        http.authorizeHttpRequests(\n                authorizeRequests -&gt; {\n                    try {\n                        authorizeRequests.requestMatchers(\n                                GenericAbstractControllerInterface.API_PUBLIC_URI + &quot;/**&quot;\n                        ).permitAll()\n                                .anyRequest().authenticated().and().oauth2ResourceServer().jwt().jwtAuthenticationConverter(jwtAuthConverter);\n                    } catch (Exception e) {\n                        throw new RuntimeException(e);\n                    }\n\n                }\n        );\n        http.csrf(csrf -&gt; csrf.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()).csrfTokenRequestHandler(new CsrfTokenRequestAttributeHandler()).disable());\n        http.sessionManagement(sessionManagement -&gt; sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS));\n        http.httpBasic(withDefaults());\n        http.cors(cors -&gt; cors.configurationSource(corsConfigurationSource));\n\n        return http.build();\n    }\n\n\n    @Bean\n    public CorsConfigurationSource corsConfigurationSource() {\n        CorsConfiguration configuration = new CorsConfiguration();\n        configuration.setAllowCredentials(true);\n        configuration.addAllowedOriginPattern(&quot;*&quot;);\n        configuration.setAllowedMethods(Arrays.asList(\n                HttpMethod.GET.name(),\n                HttpMethod.POST.name(),\n                HttpMethod.PUT.name(),\n                HttpMethod.DELETE.name(),\n                HttpMethod.OPTIONS.name()\n        ));\n        configuration.setAllowedHeaders(Arrays.asList(&quot;Content-Type&quot;, &quot;Authorization&quot;, &quot;Access-Control-Allow-Methods&quot;, &quot;X-TENANT-ID&quot;, &quot;X-API-KEY&quot;, &quot;X-ACTUATOR&quot;, &quot;X-GUI&quot;));\n\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(&quot;/**&quot;, configuration);\n        return source;\n    }\n</code></pre>\n<p>The ApiFilter just checks where the request comes from and sets a global variable to validate and check other processes.\nIt sets e.g. if the request goes to the public Api to PUBLIC_API, GUI or API</p>\n<p>My endpoints, which are validated via apiKey, work as expected, but I don't know if it's the best solution.</p>\n<p>ApiFilter:</p>\n<pre><code>    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        logger.info(&quot;ApiKeyFilter invoked for request: &quot; + request.getRequestURI());\n        if (ApiContext.isApi()) {\n            String requestApiKey = request.getHeader(&quot;X-API-KEY&quot;);\n            String requestApiSecret = request.getHeader(&quot;X-SECRET-KEY&quot;);\n\n            if (requestApiKey == null || requestApiSecret == null) {\n                throw new BadCredentialsException(&quot;BadCredentials&quot;);\n            }\n\n            Optional&lt;ApiInformation&gt; apiInformationOptional = this.apiInformationRepository.findByApiKey(requestApiKey);\n\n            if (!apiInformationOptional.isPresent()) {\n                throw new BadCredentialsException(&quot;BadCredentials&quot;);\n            }\n\n            ApiInformation apiInformation = apiInformationOptional.get();\n\n            if (!apiInformation.getApiKey().equals(requestApiKey) || !apiInformation.getSecretKey().equals(requestApiSecret)) {\n                throw new BadCredentialsException(&quot;BadCredentials&quot;);\n            }\n\n            Optional&lt;TenantInformation&gt; tenantInformationOptional = this.tenantInformationRepository.findByOrganization(apiInformation.getOrganization());\n\n            if (!tenantInformationOptional.isPresent()) {\n                throw new BadCredentialsException(&quot;BadCredentials&quot;);\n            }\n\n            TenantInformation tenantInformation = tenantInformationOptional.get();\n\n            Authentication authentication = new UsernamePasswordAuthenticationToken(apiInformation.getApiKey(), null, new ArrayList&lt;&gt;());\n            SecurityContextHolder.getContext().setAuthentication(authentication);\n            TenantContext.setCurrentTenant(tenantInformation.getTenantId());\n        } else if (ApiContext.isActuator()) {\n            Authentication authentication = new UsernamePasswordAuthenticationToken(&quot;GenericUser&quot;, null, new ArrayList&lt;&gt;());\n            SecurityContextHolder.getContext().setAuthentication(authentication);\n        }\n\n        filterChain.doFilter(request, response);\n    }\n</code></pre>\n<p>FilterChains:</p>\n<pre><code>    @Bean\n    @Order(1)\n    @DependsOn(&quot;corsConfigurationSource&quot;)\n    public SecurityFilterChain apiServerFilterChain(\n            HttpSecurity http,\n            @Qualifier(&quot;corsConfigurationSource&quot;) CorsConfigurationSource corsConfigurationSource\n    ) throws Exception {\n        http.authorizeHttpRequests((authorize) -&gt;\n                        authorize.requestMatchers(\n                                        GenericAbstractControllerInterface.PUBLIC_API_DOC_BASE_URI + &quot;/**&quot;,\n                                        GenericAbstractControllerInterface.API_PUBLIC_URI + &quot;/**&quot;,\n                                ).permitAll()\n                                .anyRequest().authenticated()\n                )\n                .addFilterBefore(apiFilter, ChannelProcessingFilter.class)\n                .addFilterBefore(apiKeyFilter, UsernamePasswordAuthenticationFilter.class)\n                .sessionManagement(sessionManagement -&gt; sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n                .httpBasic(withDefaults())\n                .cors(cors -&gt; {\n                    cors.configurationSource(corsConfigurationSource);\n                })\n                .csrf(AbstractHttpConfigurer::disable);\n\n        return http.build();\n    }\n\n    @Bean\n    @Order(0)\n    public SecurityFilterChain resourceServerFilterChain(\n            HttpSecurity http,\n            @Qualifier(&quot;corsConfigurationSource&quot;) CorsConfigurationSource corsConfigurationSource\n    ) throws Exception {\n        List&lt;Subscription&gt; subscriptions = subscriptionRepository.findAll();\n        List&lt;String&gt; allRoles = subscriptions.stream()\n                .map(subscription -&gt; subscription.getRoles().split(&quot;,&quot;)) \n                .flatMap(Arrays::stream) \n                .collect(Collectors.toList());\n        allRoles.add(&quot;ORGANIZATION_ADMIN&quot;);\n        allRoles.add(&quot;ORGANIZATION_USER&quot;);\n\n        http.authorizeHttpRequests(\n                authorizeRequests -&gt; {\n                    try {\n                        authorizeRequests.requestMatchers(\n                                GenericAbstractControllerInterface.API_PUBLIC_URI + &quot;/**&quot;\n                        ).permitAll()\n                                .anyRequest().authenticated().and().oauth2ResourceServer().jwt().jwtAuthenticationConverter(jwtAuthConverter);\n                    } catch (Exception e) {\n                        throw new RuntimeException(e);\n                    }\n\n                }\n        );\n        http.csrf(csrf -&gt; csrf.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()).csrfTokenRequestHandler(new CsrfTokenRequestAttributeHandler()).disable());\n        http.sessionManagement(sessionManagement -&gt; sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS));\n        http.httpBasic(withDefaults());\n        http.cors(cors -&gt; cors.configurationSource(corsConfigurationSource));\n\n        return http.build();\n    }\n\n\n    @Bean\n    public CorsConfigurationSource corsConfigurationSource() {\n        CorsConfiguration configuration = new CorsConfiguration();\n        configuration.setAllowCredentials(true);\n        configuration.addAllowedOriginPattern(&quot;*&quot;);\n        configuration.setAllowedMethods(Arrays.asList(\n                HttpMethod.GET.name(),\n                HttpMethod.POST.name(),\n                HttpMethod.PUT.name(),\n                HttpMethod.DELETE.name(),\n                HttpMethod.OPTIONS.name()\n        ));\n        configuration.setAllowedHeaders(Arrays.asList(&quot;Content-Type&quot;, &quot;Authorization&quot;, &quot;Access-Control-Allow-Methods&quot;, &quot;X-TENANT-ID&quot;, &quot;X-API-KEY&quot;, &quot;X-ACTUATOR&quot;, &quot;X-GUI&quot;));\n\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(&quot;/**&quot;, configuration);\n        return source;\n    }\n</code></pre>\n<p>The ApiFilter just checks where the request comes from and sets a global variable to validate and check other processes.\nIt sets e.g. if the request goes to the public Api to PUBLIC_API, GUI or API</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}