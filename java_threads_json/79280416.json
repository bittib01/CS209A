{
  "question": {
    "tags": [
      "java",
      "multithreading",
      "memory-management",
      "reactive-programming"
    ],
    "owner": {
      "account_id": 2211885,
      "reputation": 11718,
      "user_id": 1953504,
      "user_type": "registered",
      "accept_rate": 66,
      "profile_image": "https://i.sstatic.net/7nVZV.jpg?s=256",
      "display_name": "Sal-laS",
      "link": "https://stackoverflow.com/users/1953504/sal-las"
    },
    "is_answered": false,
    "view_count": 220,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1741210135,
    "creation_date": 1734170033,
    "last_edit_date": 1734604820,
    "question_id": 79280416,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79280416/is-reactive-programming-more-memory-efficient-in-managing-threads-for-asynchrono",
    "title": "Is reactive programming more memory-efficient in managing threads for asynchronous operations?",
    "body": "<p>I frequently use <code>Awaitility</code> in my tests to handle asynchronous operations. However, each <code>Awaitility</code> call spawns threads, which results in high memory consumption when running large tests. I'm searching for an alternative solution that provides similar functionality but is more memory-efficient.</p>\n<hr />\n<h3>Example Scenario:</h3>\n<p>Below is a simplified example where I need to find 500 random prime numbers between <code>0</code> and <code>10,000,000</code>.</p>\n<p><strong>Using Awaitility:</strong></p>\n<pre class=\"lang-java prettyprint-override\"><code>static void waitWithAwaitility() {\n    AtomicInteger primeCount = new AtomicInteger(0);\n    await()\n        .atMost(1, TimeUnit.HOURS)\n        .pollInterval(3, TimeUnit.SECONDS)\n        .until(() -&gt; {\n            int number = supplierMethod().get();\n            if (isPrime(number)) {\n                System.out.println(&quot;Found prime: &quot; + number);\n                primeCount.incrementAndGet();\n            }\n            return primeCount.get() &gt;= 500;\n        });\n}\n</code></pre>\n<p><strong>Helper Methods:</strong></p>\n<pre class=\"lang-java prettyprint-override\"><code>public static Supplier&lt;Integer&gt; supplierMethod() {\n    int number = new Random().nextInt(10_000_000) + 1;\n    System.out.println(&quot;Generated number: &quot; + number);\n    return () -&gt; number;\n}\n\npublic static boolean isPrime(int number) {\n    if (number &lt;= 1) return false;\n    for (int i = 2; i &lt;= Math.sqrt(number); i++) {\n        if (number % i == 0) return false;\n    }\n    return true;\n}\n</code></pre>\n<p>When I profile the memory usage with tools like <a href=\"https://visualvm.github.io/\" rel=\"nofollow noreferrer\">VisualVM</a>, I notice a significant memory footprint.\n<a href=\"https://i.sstatic.net/8s8zwJTK.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/8s8zwJTK.png\" alt=\"enter image description here\" /></a></p>\n<hr />\n<h3>Exploring Alternatives:</h3>\n<p>ChatGPT suggested using reactive programming (with Project Reactor) as an alternative. I tried implementing the solution below:</p>\n<p><strong>Reactive Programming Example:</strong></p>\n<pre class=\"lang-java prettyprint-override\"><code>public Mono&lt;Integer&gt; reactiveAwait(\n    Supplier&lt;Integer&gt; supplierMethod,\n    Predicate&lt;Integer&gt; condition,\n    Duration pollInterval,\n    Duration timeout\n) {\n    return Mono.defer(() -&gt; Mono.fromSupplier(supplierMethod))\n        .repeatWhen(repeat -&gt; repeat.delayElements(pollInterval))\n        .takeUntil(condition::test)\n        .last()\n        .timeout(timeout, Mono.error(new RuntimeException(&quot;Timeout exceeded&quot;)))\n        .onErrorResume(throwable -&gt; {\n            System.err.println(throwable.getMessage());\n            return Mono.empty();\n        })\n        .subscribeOn(Schedulers.boundedElastic());\n}\n\nstatic void waitWithJavaRx() {\n    AtomicInteger primeCount = new AtomicInteger(0);\n\n    Mono&lt;Integer&gt; result = new DifferentAwaitility().reactiveAwait(\n        () -&gt; supplierMethod().get(),\n        number -&gt; {\n            boolean primeStatus = isPrime(number);\n            System.out.println(&quot;Is prime? &quot; + primeStatus);\n            if (primeStatus) {\n                primeCount.incrementAndGet();\n            }\n            return primeCount.get() &gt;= 500;\n        },\n        Duration.ofSeconds(3),\n        Duration.ofHours(1)\n    );\n\n    Integer finalResult = result.block();\n    if (finalResult != null) {\n        System.out.println(&quot;Result: &quot; + finalResult);\n    } else {\n        System.err.println(&quot;Error: Timeout or other failure occurred&quot;);\n    }\n}\n</code></pre>\n<hr />\n<p><strong>Issue with the Reactive Approach:</strong><br />\nWhile this approach works, the memory consumption was three times higher than when using <code>Awaitility</code>. Below are VisualVM screenshots comparing the memory usage:</p>\n<p><a href=\"https://i.sstatic.net/o68gitA4.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/o68gitA4.png\" alt=\"enter image description here\" /></a></p>\n<ul>\n<li><a href=\"https://i.sstatic.net/85IqF2TK.png\" rel=\"nofollow noreferrer\">Awaitility Memory Usage</a></li>\n<li><a href=\"https://i.sstatic.net/vTKy8Cqo.png\" rel=\"nofollow noreferrer\">Reactive Programming Memory Usage</a></li>\n</ul>\n<hr />\n<p><strong>Question:</strong><br />\nIs there a better approach to achieving similar functionality as <code>Awaitility</code> but with lower memory consumption? I’ve explored reactive programming, but it didn’t help in reducing memory usage.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}