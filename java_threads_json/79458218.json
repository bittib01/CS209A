{
  "question": {
    "tags": [
      "java",
      "postgresql",
      "spring-boot",
      "jpa",
      "many-to-many"
    ],
    "owner": {
      "account_id": 23904148,
      "reputation": 3,
      "user_id": 17901934,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/2fa5176c77dbe12eba6f5100c8824995?s=256&d=identicon&r=PG",
      "display_name": "marioszap",
      "link": "https://stackoverflow.com/users/17901934/marioszap"
    },
    "is_answered": true,
    "view_count": 122,
    "accepted_answer_id": 79459503,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1740225633,
    "creation_date": 1740159424,
    "question_id": 79458218,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79458218/spring-boot-many-to-many-post-both-ways",
    "title": "Spring Boot Many to many POST both ways",
    "body": "<p>newbie to spring boot here.\nI've been following this tutorial: <a href=\"https://www.youtube.com/watch?v=jCYonZey5dY&amp;t=1145s\" rel=\"nofollow noreferrer\">https://www.youtube.com/watch?v=jCYonZey5dY&amp;t=1145s</a>\nMy implementation is about books and authors and I want the same functionality. An author can have multiple books and also a book can be co-written by more than one authors. I've come to a result where, POSTing an author works as intended, but POSTing a book does not update the join table, although both Users and Books tables are updated. My database is postgres.\nImplementation details:</p>\n<p>Users Class:</p>\n<pre><code>@Entity\n@Table\n@Getter\n@Setter\n@NoArgsConstructor\npublic class Users {\n\n    @Id\n    @SequenceGenerator(\n        name = &quot;user_sequence&quot;,\n        sequenceName = &quot;user_sequence&quot;,\n        allocationSize = 1\n    )\n    @GeneratedValue(\n        strategy = GenerationType.SEQUENCE,\n        generator = &quot;user_sequence&quot;\n    )\n    \n    private Long userId;\n    private String password;\n    private LocalDate dateOfBirth;\n    private String fullName;\n    private String email;\n\n    @Enumerated(EnumType.STRING)\n    private Roles role;\n\n    @ManyToMany(fetch=FetchType.LAZY, cascade = CascadeType.ALL)\n    @JoinTable(name = &quot;USERS_BOOKS&quot;, joinColumns = {\n        @JoinColumn (name = &quot;User_id&quot;, referencedColumnName = &quot;userId&quot;)\n    }, \n    inverseJoinColumns = {\n        @JoinColumn(name = &quot;BookId&quot;, referencedColumnName = &quot;bookId&quot;)\n    })\n    private Set&lt;Book&gt; books;\n\n\n    public Users(String password, LocalDate dateOfBirth, String fullName, String email, Roles role){\n        this.password = password;\n        this.dateOfBirth = dateOfBirth;\n        this.fullName = fullName;\n        this.email = email;\n        this.role = role; \n    }\n\n    public Users(String password, LocalDate dateOfBirth, String fullName, String email, Set&lt;Book&gt; books){\n        this.password = password;\n        this.dateOfBirth = dateOfBirth;\n        this.fullName = fullName;\n        this.email = email;\n        this.books = books;\n    }\n\n    public void addBooks(Set&lt;Book&gt; books){\n        if(this.role == Roles.AUTHOR){\n            for(Book book : books)\n                try{\n                    this.books.add(book);\n                    book.addAuthors(Set.of(this));\n                } catch(Exception e){\n                    System.out.println(&quot;Wrong type of object for a List of Book&quot;);\n                    continue;\n                }\n        } else {\n        throw new IllegalArgumentException(&quot;Non author users cannot hold books&quot;);\n        }\n    }\n\n\n    public void removeBooks(Set&lt;Book&gt; books){\n        for(Book book : books)\n            for(Book user : this.books){\n                if (user.equals(book)) {\n                    this.books.remove(user);\n                }\n                else{\n                    System.out.println(&quot;Book: &quot;+book.getTitle()+ &quot; is already not in set.&quot;);\n                }\n            }\n        }\n    \n}\n</code></pre>\n<p>Books class:</p>\n<pre><code>@Table(name = &quot;Books&quot;)\n@Entity\n@Setter\n@Getter\n@AllArgsConstructor\n@NoArgsConstructor\n\npublic class Book {\n    @Id\n    @SequenceGenerator(\n        name = &quot;book_sequence&quot;,\n        sequenceName = &quot;book_sequence&quot;,\n        allocationSize = 1\n    )\n    @GeneratedValue(\n        strategy = GenerationType.SEQUENCE,\n        generator = &quot;book_sequence&quot;\n    )\n    private Long bookId;\n    private String title;\n    private LocalDate releaseDate;\n    private String genresStr;\n    @Column(columnDefinition = &quot;text&quot;)\n    private String content;\n\n    @ManyToMany(mappedBy=&quot;books&quot;, fetch=FetchType.LAZY, cascade = CascadeType.ALL)\n    \n    private Set&lt;Users&gt; authors;\n\n\n    public Book(String title, LocalDate releaseDate, String content, String genresStr){\n        this.genresStr = genresStr;\n        this.title= title;\n        this.releaseDate = releaseDate;\n        this.content = content;\n    }\n\n    public Book(String title, LocalDate releaseDate, String content, String genresStr, Set&lt;Users&gt; authors){\n        this.genresStr = genresStr;\n        this.title= title;\n        this.releaseDate = releaseDate;\n        this.content = content;\n        this.authors = authors;\n    }\n\n    public void addAuthors(Set&lt;Users&gt; authors){\n        System.out.println(&quot;addAuthorsCalled&quot;);\n        for(Users author : authors)\n        try{\n            this.authors.add(author);\n            author.addBooks(Set.of(this));\n            author.setRole(Roles.AUTHOR);\n        } catch(Exception e){\n            System.out.println(&quot;Wrong type of object for a List of Users&quot;);\n        }\n    }\n\n    public void removeAuthors(Set&lt;Users&gt; authors){\n        if(authors.size() == 1){\n            System.out.println(&quot;Can't delete all authors for certain book&quot;);\n            return;\n        }\n        for(Users author : authors)\n            for(Users user : this.authors){\n                if (user.equals(author)) {\n                    this.authors.remove(user);\n                }\n                else{\n                    System.out.println(&quot;User: &quot;+author.getFullName()+ &quot; is already not in set.&quot;);\n                }\n            }\n    }\n}\n</code></pre>\n<p>Book controller:</p>\n<pre><code>@RestController\n@RequestMapping(path = &quot;api/books&quot;)\npublic class BookController {\n    \n    private final BookService bookService;\n    private UserService userService;\n\n\n    public BookController(@Autowired BookService bookService, UserService userService){\n        this.bookService = bookService;\n        this.userService = userService;\n    }\n\n\n    @GetMapping\n    public List&lt;Book&gt; getBooks(){\n        return bookService.getBooks();\n    }\n\n    @PostMapping\n    public void addBook(@RequestBody Book book){\n        if(!book.getAuthors().isEmpty()){\n            for(Users author :  book.getAuthors()){\n                author.setRole(Roles.AUTHOR);\n                userService.saveUser(author);\n            }\n        }\n        bookService.saveBook(book);\n    }\n\n    @DeleteMapping(path=&quot;{bookId}&quot;)\n    public void deleteBook(@PathVariable (&quot;bookId&quot;) Long bookId){\n        bookService.deleteBook(bookId);\n    }\n\n    @PutMapping(path=&quot;{bookId}&quot;)\n    public void updateBook(\n        @PathVariable(&quot;bookId&quot;) Long bookId,\n        @RequestParam(required = false) String title,\n        @RequestParam(required = false) LocalDate releaseDate, \n        @RequestParam(required = false) String content,\n        @RequestParam(required = false) Set&lt;Long&gt; userIds\n\n    ){\n        Set&lt;Users&gt; usersToAdd = null;\n        if(userIds!=null){\n            usersToAdd = userService.getUsersById(userIds);\n        }\n        bookService.updateBook(bookId, title, releaseDate, content, usersToAdd);\n    }\n\n    @PutMapping(path = &quot;/{bookId}/delAuthor&quot;)\n    public void putMethodName(\n        @PathVariable Long bookId,\n        @RequestParam(required = true) Set&lt;Long&gt; userIds\n    ){\n        Set&lt;Users&gt; usersToRemove = userService.getUsersById(userIds);\n        bookService.removeAuthors(bookId, usersToRemove);\n\n    }\n}\n</code></pre>\n<p>User controller:</p>\n<pre><code>@RestController\n@RequestMapping(path = &quot;api/users&quot;)\npublic class UserController {\n    \n    private final UserService userService;\n\n    public UserController(@Autowired UserService userService){\n        this.userService = userService;\n    }\n\n    @GetMapping\n    public List&lt;Users&gt; getAllUsers() {\n        return userService.getUsers();\n    }\n\n    @PostMapping\n    public void addNewUser(@RequestBody Users user) {\n        userService.saveUser(user);\n        \n    }\n\n    @DeleteMapping(path=&quot;{userId}&quot;)\n    void deleteUser(@PathVariable (&quot;userId&quot;) Long userId){\n        userService.deleteUser(userId);\n    }\n\n    @PutMapping(path=&quot;{userId}&quot;)\n    void updateUser(@PathVariable (&quot;userId&quot;) Long userId,\n        @RequestParam(required = false) String fullName,\n        @RequestParam(required = false) String password,\n        @RequestParam(required = false) LocalDate dateOfBirth,\n        @RequestParam(required = false) String email,\n        @RequestParam(required = false) Set&lt;Long&gt; bookIds\n    ){\n        userService.updateUser(userId, password, dateOfBirth, fullName, email, bookIds);\n    }\n}\n</code></pre>\n<p>User service</p>\n<pre><code>@Service\npublic class UserService {\n\n    private BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();\n\n    private final UserRepository userRepository;\n    private BookRepository bookRepository;\n\n    public UserService(@Autowired UserRepository userRepository, BookRepository bookRepository){\n        this.userRepository = userRepository;\n        this.bookRepository = bookRepository;\n    }\n\n    public Users getUser(Long id){\n        return this.userRepository.getReferenceById(id);\n    }\n\n    public List&lt;Users&gt; getUsers(){\n        return this.userRepository.findAll();\n    }\n\n    public Set&lt;Users&gt; getUsersById(Set&lt;Long&gt; userIds){\n        Set&lt;Users&gt; users = new HashSet&lt;&gt;();\n        for(Long userId : userIds)\n            if(userId != null){\n                users.add(this.getUser(userId));\n            }\n        return users;\n    }\n\n    public void saveUser(Users user){\n        Optional&lt;Users&gt; userEmailOptional = userRepository.findUserByEmail(user.getEmail());\n        if(userEmailOptional.isPresent()){\n            throw new IllegalStateException(&quot;This email already exists in database&quot;);\n        }\n\n        if(user.getRole() == Roles.AUTHOR){\n            Optional&lt;Users&gt; authorByFullName = userRepository.findUserByFullName(user.getFullName());\n            if(authorByFullName.isPresent()){\n                throw new IllegalStateException(&quot;Authors cannot have the same name&quot;);\n            }\n        }\n        if(user.getBooks() != null &amp;&amp; !user.getBooks().isEmpty())\n            user.setRole(Roles.AUTHOR);\n\n        user.setPassword(encoder.encode(user.getPassword()));\n        if(user.getBooks() != null &amp;&amp; !user.getBooks().isEmpty())\n            for(Book book : user.getBooks())\n                bookRepository.save(book);\n        userRepository.save(user);\n    }\n\n    public void deleteUser(Long userId){\n        boolean exists = userRepository.existsById(userId);\n        if(!exists){\n            throw new IllegalStateException(&quot;No user with Id: &quot; + userId+ &quot; in database&quot;);\n        }\n        userRepository.deleteById(userId);\n    }\n\n    @Transactional\n    public void updateUser(Long userId,\n                            String password,\n                            LocalDate dateOfBirth,\n                            String fullName,\n                            String email,\n                            Set&lt;Long&gt; bookIds){\n        Users user = userRepository.findById(userId).orElseThrow(() -&gt; \n                    new IllegalStateException(&quot;No user with id: &quot;+userId+&quot; in database&quot;));\n        if(password != null &amp;&amp; password.length() &gt; 0){\n            user.setPassword(password);\n        }\n        if(dateOfBirth!=null){\n            user.setDateOfBirth(dateOfBirth);\n        }\n        if(fullName!=null &amp;&amp; fullName.length() &gt; 0){\n            user.setFullName(fullName);\n        }\n        if(email!=null &amp;&amp; email.length() &gt; 0){\n            Optional&lt;Users&gt; userOptional = userRepository.findUserByEmail(email);\n            if(userOptional.isPresent()){\n                throw new IllegalStateException(&quot;Email &quot;+email+&quot; already exists in database&quot;);\n            }\n            user.setEmail(email);\n        }\n        if(bookIds != null){\n            Set&lt;Book&gt; booksToAdd = new HashSet&lt;Book&gt;();\n            for(Long bookId : bookIds){\n                booksToAdd.add(bookRepository.getReferenceById(bookId));\n            }\n            user.addBooks(booksToAdd);\n        }\n    }\n}\n</code></pre>\n<p>Book Service:</p>\n<pre><code>@Service\npublic class BookService {\n    \n    private final BookRepository bookRepository;\n\n    public BookService(@Autowired BookRepository bookRepository){\n        this.bookRepository = bookRepository;\n    }\n\n    public List&lt;Book&gt; getBooks(){\n        return bookRepository.findAll();\n        //List.of(new Book(&quot;kostas&quot;, LocalDate.of(2000, Month.APRIL, 12)));\n    }\n\n    public void saveBook(Book book){\n        \n        bookRepository.save(book);\n    }\n\n    public void deleteBook(Long bookId){\n        boolean exists = bookRepository.existsById(bookId);\n        if(!exists){\n            throw new IllegalStateException(&quot;Book with id: &quot; + bookId + &quot; does not exist&quot;);\n        }\n        bookRepository.deleteById(bookId);\n    }\n\n    @Transactional\n    public void removeAuthors(Long bookId, Set&lt;Users&gt; authors){\n        Book book = bookRepository.findById(bookId).\n            orElseThrow(() -&gt; new IllegalStateException(&quot;No books with the id requested&quot;));\n        if(!authors.isEmpty())\n            book.removeAuthors(authors);\n    }\n\n    @Transactional\n    public void updateBook(Long bookId, String title, LocalDate releasDate, String content, Set&lt;Users&gt; authors){\n        Book book = bookRepository.findById(bookId).\n            orElseThrow(() -&gt; new IllegalStateException(&quot;No books with the id requested&quot;));\n        \n        if(title != null &amp;&amp; title.length() &gt; 0){\n            book.setTitle(title);\n        }\n        if(releasDate != null){\n            book.setReleaseDate(releasDate);\n        }\n        if(content != null &amp;&amp; content.length() &gt; 0){\n            book.setContent(content);\n        }\n        if(authors != null)\n            book.addAuthors(authors); \n    }\n}\n</code></pre>\n<p>Roles is a simple enum:</p>\n<pre><code>public enum Roles {\n    AUTHOR, ADMIN, GUEST\n}\n</code></pre>\n<p>Example of postman requests:</p>\n<p>POST: localhost:8080/api/users<br />\n//Insert User with book\n//Works fine</p>\n<pre><code>body:\n{\n    &quot;password&quot;:&quot;itsDanBrown&quot;,\n    &quot;dateOfBirth&quot;:&quot;1964-07-22&quot;,\n    &quot;fullName&quot;:&quot;Dan Brown&quot;,\n    &quot;email&quot;:&quot;d.brown@mail.com&quot;,\n    &quot;books&quot;:[\n        {\n            &quot;title&quot;:&quot;The Da Vinci Code&quot;,\n            &quot;releaseDate&quot;:&quot;2003-03-18&quot;,\n            &quot;content&quot;:&quot;&quot;,\n            &quot;genres&quot;:[&quot;Mystery&quot;, &quot;detective fiction&quot;, &quot;conspiracy fiction&quot;, &quot;thriller&quot;]\n        },\n        {\n            &quot;title&quot;:&quot;Angels &amp; Demons&quot;,\n            &quot;releaseDate&quot;:&quot;2000-05-30&quot;,\n            &quot;content&quot;:&quot;&quot;,\n            &quot;genres&quot;:[&quot;Mystery&quot;, &quot;thriller&quot;]\n        }\n    ]\n}\n</code></pre>\n<p>POST: localhost:8080/api/users<br />\n//Insert Book with user\n//Inserts value in users table and books table but not in users_books table</p>\n<pre><code>{\n    &quot;title&quot;:&quot;The Da Vinci Code&quot;,\n    &quot;releaseDate&quot;:&quot;2003-03-18&quot;,\n    &quot;content&quot;:&quot;&quot;,\n    &quot;genres&quot;:[&quot;Mystery&quot;, &quot;detective fiction&quot;, &quot;conspiracy fiction&quot;, &quot;thriller&quot;],\n    &quot;authors&quot;:[\n        {\n        &quot;password&quot;:&quot;password&quot;,\n        &quot;dateOfBirth&quot;:&quot;2000-02-02&quot;,\n        &quot;fullName&quot;:&quot;Dan Brown&quot;,\n        &quot;email&quot;: &quot;d.brown@email.com&quot;\n        }\n    ]\n}\n</code></pre>\n<p>Thanks in advance!\n(Java version 18, Spring boot 3.4.2)</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}