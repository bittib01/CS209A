{
  "question": {
    "tags": [
      "java",
      "locking",
      "hazelcast"
    ],
    "owner": {
      "account_id": 294884,
      "reputation": 1623,
      "user_id": 599011,
      "user_type": "registered",
      "accept_rate": 74,
      "profile_image": "https://www.gravatar.com/avatar/7469261a40c94f0aa43c92c4f2bcec6e?s=256&d=identicon&r=PG",
      "display_name": "Xavier Dury",
      "link": "https://stackoverflow.com/users/599011/xavier-dury"
    },
    "is_answered": false,
    "view_count": 299,
    "answer_count": 3,
    "score": 0,
    "last_activity_date": 1754754026,
    "creation_date": 1709711330,
    "question_id": 78112610,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78112610/how-should-hazelcast-dynamically-allocated-fencedlocks-be-destroyed",
    "title": "How should Hazelcast dynamically allocated FencedLocks be destroyed",
    "body": "<p>Hazelcast <code>FencedLocks</code> should be destroyed to avoid memory leaks but how/when should that be done when those locks are not known beforehand and created/allocated on demand (potentially by multiple processes)? Or are those locks not meant to be used that way?</p>\n<p>example:</p>\n<pre class=\"lang-java prettyprint-override\"><code>// this method can be called by multiple concurrent processes\npublic void updateClient(ClientId id, ClientData data) {\n    var lock = this.hz.getCPSubsystem().getLock(id.toString());\n    lock.lock();\n    try {\n        // update the client\n    } finally {\n        lock.unlock();\n    }\n    // where should lock.destroy() be called?\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}