{
  "question": {
    "tags": [
      "java",
      "c",
      "java-ffm"
    ],
    "owner": {
      "account_id": 19558955,
      "reputation": 761,
      "user_id": 14312575,
      "user_type": "registered",
      "profile_image": "https://i.sstatic.net/ajBiC.png?s=256",
      "display_name": "test failed in 1.08s",
      "link": "https://stackoverflow.com/users/14312575/test-failed-in-1-08s"
    },
    "is_answered": true,
    "view_count": 753,
    "accepted_answer_id": 79700269,
    "answer_count": 1,
    "score": 15,
    "last_activity_date": 1752443728,
    "creation_date": 1752435233,
    "last_edit_date": 1752437400,
    "question_id": 79700202,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79700202/weird-behaviour-of-java-ffm-on-windows-platform-when-creating-upcalls-accepting",
    "title": "Weird behaviour of Java FFM on Windows platform when creating upcalls accepting both structure and pointer parameters",
    "body": "<p>On Windows platform, when creating upcall stubs with Java 22 FFM APIs, if the callback functions has <strong>both</strong> structure (larger than pointer size) <strong>and</strong> pointer parameters, the <code>MemorySegment</code>s accepting these pointer parameters will be linked with a confined memory session. This behavior is not consistent with Linux JVM.</p>\n<p>MWE here:</p>\n<hr />\n<p><code>ccb.c</code>:</p>\n<pre class=\"lang-c prettyprint-override\"><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\ntypedef struct {\n    char const *s1;\n    char const *s2;\n} S;\n\ntypedef void (*callback_fn)(S s, char const *data);\n\n#ifdef _MSC_VER\n#define EXPORT __declspec(dllexport)\n#else\n#define EXPORT __attribute__((visibility(&quot;default&quot;)))\n#endif\n\nEXPORT extern void ccb(callback_fn fn) {\n    char const *data = &quot;Let's be together, forever, we are never gonna be apart.&quot;;\n\n    fprintf(stderr, &quot;(C) address of data = %p\\n&quot;, (void*)data);\n\n    fn(\n        ((S) {\n            &quot;Shall I leave you be, Is it love if I can set you free?&quot;,\n            &quot;But even it's not reality,&quot;,\n        }),\n        data\n    );\n}\n</code></pre>\n<p>Here, the <code>data</code> provided to <code>fn</code> is a static string from C world. It's not allocated from Java world, of course.</p>\n<hr />\n<p>Build commands:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>gcc.exe ccb.c -shared -fPIC -o ccb.dll\n</code></pre>\n<p>or</p>\n<pre class=\"lang-none prettyprint-override\"><code>cl.exe /utf-8 /nologo /LD /MD /DWIN32 /Zi ccb.c /Fe:ccb.dll /link User32.lib\n</code></pre>\n<hr />\n<p><code>CCB.java</code>:</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.lang.foreign.*;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;\n\npublic final class CCB {\n    static final StructLayout LAYOUT$S = MemoryLayout.structLayout(\n            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE).withName(&quot;s1&quot;),\n            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE).withName(&quot;s2&quot;)\n    );\n\n    static final FunctionDescriptor DESCRIPTOR$ccb = FunctionDescriptor.ofVoid(ValueLayout.ADDRESS.withName(&quot;fn&quot;));\n\n    static final FunctionDescriptor DESCRIPTOR$callback = FunctionDescriptor.ofVoid(\n            LAYOUT$S.withName(&quot;s&quot;),\n            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_BYTE).withName(&quot;data&quot;)\n    );\n\n    static final MethodHandle hCCB;\n    static {\n        System.loadLibrary(&quot;ccb&quot;);\n\n        Linker linker = Linker.nativeLinker();\n        SymbolLookup stdlibLookup = linker.defaultLookup();\n        SymbolLookup loaderLookup = SymbolLookup.loaderLookup();\n\n        MemorySegment pfnCCB = loaderLookup.find(&quot;ccb&quot;)\n                .or(() -&gt; stdlibLookup.find(&quot;ccb&quot;))\n                .orElse(MemorySegment.NULL);\n        if (pfnCCB.equals(MemorySegment.NULL)) {\n            throw new RuntimeException(&quot;Failed to find ccb symbol&quot;);\n        }\n        hCCB = linker.downcallHandle(pfnCCB, DESCRIPTOR$ccb);\n    }\n\n    static final class Ref&lt;T&gt; {\n        T value;\n    }\n\n    @FunctionalInterface\n    interface MemorySegmentConsumer {\n        void accept(MemorySegment segment);\n    }\n\n    static void callback(\n            MemorySegmentConsumer consumer,\n            MemorySegment s,\n            MemorySegment data\n    ) {\n        for (int i = 0; i &lt; 2; i++) {\n            MemorySegment segment = s.getAtIndex(ValueLayout.ADDRESS, i).reinterpret(Long.MAX_VALUE);\n            System.err.println(&quot;(J) callback: s-&gt;s&quot; + (i + 1) + &quot; = &quot; + segment.getString(0));\n        }\n        data = data.reinterpret(Long.MAX_VALUE);\n        System.err.println(&quot;(J) callback: data = &quot; + data.getString(0));\n        System.err.println(&quot;(J) callback: address of data = &quot; + Long.toUnsignedString(data.address(), 16));\n\n        consumer.accept(data);\n    }\n\n    public static void main(String[] args) {\n        Ref&lt;MemorySegment&gt; ref = new Ref&lt;&gt;();\n        MemorySegmentConsumer consumer = segment -&gt; ref.value = segment;\n\n        try (Arena arena = Arena.ofConfined()) {\n            Linker linker = Linker.nativeLinker();\n            MethodHandle MH$callback = MethodHandles.lookup().findStatic(\n                    CCB.class,\n                    &quot;callback&quot;,\n                    DESCRIPTOR$callback.toMethodType().insertParameterTypes(0, MemorySegmentConsumer.class)\n            );\n            MemorySegment pfnCallback = linker.upcallStub(\n                    MH$callback.bindTo(consumer),\n                    DESCRIPTOR$callback,\n                    arena\n            );\n\n            hCCB.invokeExact(pfnCallback);\n\n            System.err.println(&quot;(J) main: data = &quot; + ref.value.getString(0)); // &lt;-- error occurs here\n        } catch (Throwable e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n</code></pre>\n<hr />\n<p>Program output:</p>\n<pre class=\"lang-none prettyprint-override\"><code>(J) callback: s-&gt;s1 = Shall I leave you be, Is it love if I can set you free?\n(J) callback: s-&gt;s2 = But even it's not reality,\n(J) callback: data = Let's be together, forever, we are never gonna be apart.\n(J) callback: address of data = 7fffa5009000\nException in thread &quot;main&quot; java.lang.RuntimeException: java.lang.IllegalStateException: Already closed\n    at CCB.main(CCB.java:81)\nCaused by: java.lang.IllegalStateException: Already closed\n    at java.base/jdk.internal.foreign.MemorySessionImpl.alreadyClosed(MemorySessionImpl.java:318)\n    at java.base/jdk.internal.misc.ScopedMemoryAccess$ScopedAccessError.newRuntimeException(ScopedMemoryAccess.java:114)\n    at java.base/jdk.internal.misc.ScopedMemoryAccess.getLongUnaligned(ScopedMemoryAccess.java:2574)\n    at java.base/jdk.internal.foreign.StringSupport.strlenByte(StringSupport.java:142)\n    at java.base/jdk.internal.foreign.StringSupport.readByte(StringSupport.java:71)\n    at java.base/jdk.internal.foreign.StringSupport.read(StringSupport.java:54)\n    at java.base/jdk.internal.foreign.AbstractMemorySegmentImpl.getString(AbstractMemorySegmentImpl.java:907)\n    at java.base/jdk.internal.foreign.AbstractMemorySegmentImpl.getString(AbstractMemorySegmentImpl.java:900)\n    at CCB.main(CCB.java:79)\n(C) address of data = 00007fffa5009000\n</code></pre>\n<hr />\n<p>And when observed from IDE:</p>\n<p><a href=\"https://i.sstatic.net/GVeoncQE.png\" rel=\"noreferrer\"><img src=\"https://i.sstatic.net/GVeoncQE.png\" alt=\"Observed ConfinedSession from IDE\" /></a></p>\n<hr />\n<p>Such behavior is not observed when there's only pointer parameters, and not observed when the structure is smaller (only 1 pointer size).</p>\n<p>Also, this behavior is not observed on Linux:</p>\n<p><a href=\"https://i.sstatic.net/GP0wa4FQ.png\" rel=\"noreferrer\"><img src=\"https://i.sstatic.net/GP0wa4FQ.png\" alt=\"Not observed on Linux\" /></a></p>\n<p>Is this some kind of deliberate design, technical limitation or bug?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}