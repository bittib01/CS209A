{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "tomcat",
      "websocket",
      "spring-websocket"
    ],
    "owner": {
      "account_id": 9942251,
      "reputation": 31,
      "user_id": 7358432,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/ad2c88ca32c0446a9ded83a3581bf766?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "DJ bravo",
      "link": "https://stackoverflow.com/users/7358432/dj-bravo"
    },
    "is_answered": true,
    "view_count": 838,
    "answer_count": 1,
    "score": 2,
    "last_activity_date": 1714118068,
    "creation_date": 1704429796,
    "last_edit_date": 1704432039,
    "question_id": 77762560,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/77762560/java-web-sockets-in-tomcat-causing-very-high-memory-usage-and-ooo",
    "title": "Java Web sockets in Tomcat causing very High memory usage and OOO",
    "body": "<p>I am coding for an application that forms around 4 thousand connection and send data. but somehow it is consuming memory in more than 700 GB range. what is the ideal way to optimize? any Garbage collector suggestion that can help? even forcing GC on every message send is no help.</p>\n<p>Goal is to test persistent long connection using web sockets on a large scale.</p>\n<pre><code>\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.websocket.Session;\n\nimport org.springframework.scheduling.annotation.Async;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.socket.CloseStatus;\nimport org.springframework.web.socket.TextMessage;\nimport org.springframework.web.socket.WebSocketSession;\nimport org.springframework.web.socket.adapter.NativeWebSocketSession;\nimport org.springframework.web.socket.handler.TextWebSocketHandler;\n\nimport n1wsperf.server.ServerTelemetry.ServerMetricType;\n\n@Component\npublic class TextSocketHandler extends TextWebSocketHandler {\n\n    private volatile static HashMap&lt;String, WebSocketSession&gt; activeSessions = new HashMap&lt;&gt;() ;\n\n    private static final int maxSizeInKB = 61440; // 60MB or 480Mb\n\n    private static final TextMessage _data = DataService.getData();\n\n    private static  String modeStr = &quot;Request-Response&quot;;\n\n    public static void Initialize() {\n        Timer timer = new Timer(&quot;ActiveSessionTimer&quot;);\n        TimerTask task = new TimerTask() {\n            @Override\n            public void run() {\n                ServerTelemetry.TrackMetric(ServerMetricType.ACTIVESESSION, activeSessions.size());\n                System.out.println(&quot;Active Connections : &quot; + activeSessions.size());\n            }\n        };\n        CompletableFuture.runAsync( () -&gt; { timer.schedule(task, 1000, 60000L); });\n    }\n\n    public TextSocketHandler() {\n        modeStr = ServerConfig.getServerRunConfig().DuplexMode ? &quot;Duplex&quot; : &quot;Request-Response&quot;;\n    }\n\n    @Async\n    @Override\n    public void afterConnectionEstablished(WebSocketSession session) throws Exception {\n        try {\n            session.setTextMessageSizeLimit(maxSizeInKB * 1024); // 60MB or 480Mb\n            String sessionId = session.getId();\n            if (session instanceof NativeWebSocketSession) {\n                final Session nativeSession = ((NativeWebSocketSession)session).getNativeSession(Session.class); \n                if (nativeSession != null ) {\n                    nativeSession.getUserProperties()\n                         .put(&quot;org.apache.tomcat.websocket.BLOCKING_SEND_TIMEOUT&quot;, 60_000L);\n                }\n            }\n            session.sendMessage(new TextMessage(sessionId));\n            activeSessions.putIfAbsent(session.getId(), session);\n            ServerTelemetry.TrackMetric(ServerMetricType.NEWSESSION);\n            TraceLogger.Info(&quot;SocketHandler&quot;, String.format(&quot;Session(new): %s: Mode: %s: New Connection established with client %s&quot;, session.getId(), modeStr,session.getRemoteAddress()), true);\n\n            Run run = ServerConfig.getServerRunConfig();\n            if (run.DuplexMode){\n                startDuplexCommunicationAsync(sessionId, run);          // non-blocking\n            }\n            TraceLogger.Info(&quot;SocketHandler&quot;, String.format(&quot;Session (Verbose: %s): %s: Mode: %s Communication is in progress with client %s&quot;, run.Verbose, session.getId(), modeStr,session.getRemoteAddress()), true);\n\n        } catch (Exception e) {\n            ServerTelemetry.TrackMetric(ServerMetricType.FAILEDSESSION);\n            ServerTelemetry.TrackException(e);\n            TraceLogger.Error(&quot;SocketHandler&quot;, String.format(&quot;Session: %s Mode: %s Exception: %s&quot;, session.getId(), modeStr,e.getMessage()));\n        } finally {\n            System.gc();\n        }\n    }\n    \n    @Async\n    @Override\n    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {\n        try{\n        var sessionId = session.getId();\n        var clientAdr = session.getRemoteAddress();\n\n        ServerTelemetry.TrackMetric(ServerMetricType.CLOSEDSESSION);\n        TraceLogger.Info(&quot;SocketHandler&quot;, String.format(&quot;Session: %s Mode: %s : Closed Connection with client %s&quot;, sessionId, modeStr,clientAdr), true);\n        if (activeSessions.keySet().contains(sessionId)){\n            activeSessions.remove(sessionId);\n            ServerTelemetry.TrackMetric(ServerMetricType.ACTIVESESSION, activeSessions.size());\n        }}\n        finally {\n            System.gc();\n        }\n    }\n\n    @Async\n    @Override\n    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {\n        try {\n            String sessionId = session.getId();\n            WebSocketSession wsSession = activeSessions.get(sessionId);\n\n            long start = System.nanoTime();\n            //ServerTelemetry.TrackMetric(ServerMetricType.REQUEST);\n            String payload = message.getPayload();\n            //ServerTelemetry.TrackMetric(ServerMetricType.REQUESTSIZE, payload.length());  // Bytes\n            TraceLogger.Info(&quot;SocketHandler&quot;, String.format(&quot;Session: %s: Mode: %s: Received %s bytes from client %s&quot;, sessionId, modeStr,payload.length(), wsSession.getRemoteAddress()));\n            \n            if (!ServerConfig.getServerRunConfig().DuplexMode) {\n                CompletableFuture.runAsync( () -&gt; {\n                    try {\n                        sendMessage(wsSession, start);\n                    } catch (IOException | InterruptedException e) {\n                        TraceLogger.Error(&quot;SocketHandler&quot;, String.format(&quot;Session: %s Mode: %s Exception: %s&quot;, sessionId, modeStr,e.getMessage()));\n                    } \n                }).get();\n            }\n\n            long end = System.nanoTime();\n            double reqDurationms = TimeUnit.NANOSECONDS.toMillis(end - start);\n\n           // ServerTelemetry.TrackMetric(ServerMetricType.ACTIVESESSION, activeSessions.size());\n           // ServerTelemetry.TrackMetric(ServerMetricType.DURATION, reqDurationms);\n\n            \n        } catch (Exception e) {\n            ServerTelemetry.TrackMetric(ServerMetricType.FAILEDREQUEST);\n            ServerTelemetry.TrackException(e);\n            TraceLogger.Error(&quot;SocketHandler&quot;, String.format(&quot;Session: %s Mode: %s Exception: %s&quot;, session.getId(), modeStr,e.getMessage()));\n        } finally {\n            System.gc();\n        }\n\n    }\n    \n    @Async\n    @Override\n    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {\n        try{\n        WebSocketSession wsSession = activeSessions.get(session.getId());\n\n        ServerTelemetry.TrackMetric(ServerMetricType.TRANSPORTERROR);\n        TraceLogger.Error(&quot;SocketHandler&quot;, String.format(&quot;Session: %s: Mode: %s Error: %s&quot;, wsSession.getId(), modeStr,exception.getMessage()));\n        if (activeSessions.keySet().contains(wsSession.getId())){\n            activeSessions.remove(wsSession.getId());\n            ServerTelemetry.TrackMetric(ServerMetricType.ACTIVESESSION, activeSessions.size());\n        }}\n        finally {\n            System.gc();\n        }\n    }\n\n    private void startDuplexCommunicationAsync(String sessionId, Run run) throws IOException, InterruptedException {\n        CompletableFuture.runAsync(() -&gt; {\n            long sessionStart = System.nanoTime();\n            WebSocketSession wsSession = null;\n            for (long current = System.nanoTime(); current &lt; sessionStart + TimeUnit.SECONDS.toNanos(run.KeepAlive_Sec);  ){\n                try {\n                    wsSession = activeSessions.get(sessionId);\n                    sendMessage(wsSession, System.nanoTime());\n                    current = System.nanoTime();\n                } catch (IOException | InterruptedException e) {\n                    TraceLogger.Error(&quot;SocketHandler&quot;, String.format(&quot;Session: %s Mode: %s Exception: %s&quot;, sessionId, modeStr,e.getMessage()));\n                }\n            }\n            if (wsSession != null &amp;&amp; wsSession.isOpen()){\n                try {\n                    wsSession.close(CloseStatus.NORMAL);\n                    TraceLogger.Info(&quot;SocketHandler&quot;, String.format(&quot;Session: %s Mode: %s: Closing session as the configured keepalive duration (%s seconds) has elapsed, sent session close to client %s&quot;, sessionId, modeStr,run.KeepAlive_Sec, wsSession.getRemoteAddress()), true);\n                } catch (IOException e) {\n                    TraceLogger.Error(&quot;SocketHandler&quot;, String.format(&quot;Session: %s Mode: %s Exception: %s&quot;, sessionId, modeStr,e.getMessage()));\n                }\n            }\n        });\n        \n    }\n\n    private void sendMessage(WebSocketSession session, long start) throws IOException, InterruptedException {\n        if (!session.isOpen()) {\n            throw new IOException(&quot;Session is not in open state&quot;);\n        }\n\n        var runCfg = ServerConfig.getServerRunConfig();\n\n        try {\n            session.sendMessage(_data);\n            \n            //ServerTelemetry.TrackMetric(ServerMetricType.RESPONSESIZE, _data.getPayloadLength());  // Bytes\n            TraceLogger.Info(&quot;SocketHandler&quot;, String.format(&quot;Session: %s: Mode: %s: %s bytes sent to client %s&quot;, session.getId(), modeStr, _data.getPayloadLength(), session.getRemoteAddress()));\n\n            long end = System.nanoTime();\n            long remainMillis = runCfg.RequestInterval_ms - TimeUnit.NANOSECONDS.toMillis(end - start);\n            if (remainMillis &gt; 0) {\n                Thread.sleep(remainMillis);\n            }\n\n        } catch (IOException e) {\n            TraceLogger.Error(&quot;SocketHandler&quot;, String.format(&quot;Session: %s: Mode: %s: Exception: %s&quot;, session.getId(), modeStr,e.getMessage()));\n        } finally {\n            System.gc();\n        }\n\n    }\n\n}\n\n\n</code></pre>\n<ol>\n<li>Various kinds of GC, parallel with 50% GC time, still on execution, available memory went to zero</li>\n<li>Removing logging</li>\n</ol>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}