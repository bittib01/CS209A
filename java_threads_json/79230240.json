{
  "question": {
    "tags": [
      "java",
      "java-2d"
    ],
    "owner": {
      "account_id": 37755581,
      "reputation": 11,
      "user_id": 28410919,
      "user_type": "registered",
      "profile_image": "https://i.sstatic.net/jyycTvAF.png?s=256",
      "display_name": "Pulsi_",
      "link": "https://stackoverflow.com/users/28410919/pulsi"
    },
    "is_answered": false,
    "view_count": 64,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1753071628,
    "creation_date": 1732710138,
    "last_edit_date": 1753071628,
    "question_id": 79230240,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79230240/java-graphics-drawing-multiple-images-next-to-each-other-creates-empty-lines",
    "title": "Java Graphics - Drawing multiple images next to each other creates empty lines",
    "body": "<p>I am trying to draw the map of my game, it has tiles object with x &amp; y location. The image of the tiles are hold by 1 class, and I resize them once I finished zooming.</p>\n<p>I want to draw the images with double precision, in fact I am using the <strong>AffineTransform</strong> to translate them, and also scaling with double precision.</p>\n<p>In the <strong>Camera</strong> class I have the zoom variable as double.\nWhen the <strong>zoom</strong> is 0, it seems that everything is okay, but when I move the mouse this bug stil happends. (Because the camera moves based on the distance of the mouse from the center)</p>\n<p>I am drawing everything on a panel called <strong>GameScreen</strong>, I have multiple <strong>ScreenPainter</strong> classes where I draw different stuff, and then draw everything on that panel.</p>\n<p>GameScreen class:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class GameScreen extends JPanel {\n\n    private static GameScreen INSTANCE;\n    private static Graphics2D graphics2D;\n\n    private List&lt;ScreenPainter&gt; painters = new ArrayList&lt;&gt;();\n\n    public GameScreen() {\n        INSTANCE = this;\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        graphics2D = (Graphics2D) g;\n        graphics2D.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);\n\n        for (ScreenPainter painter : painters) painter.paint();\n        for (BAText text : new ArrayList&lt;&gt;(TextRegistry.getTexts().values())) {\n            if (text != null) text.drawText(graphics2D);\n        }\n\n        //if (BlueArchangels.STATE == GameState.PAUSE) MenuRegistry.getExitMenu().paint(graphics);\n\n        graphics2D.dispose();\n    }\n\n    public void updatePainters() {\n        painters = new ArrayList&lt;&gt;(ScreenPainterManager.getPainters());\n    }\n\n    public static GameScreen INSTANCE() {\n        return INSTANCE;\n    }\n\n    public static Graphics2D getGraphics2D() {\n        return graphics2D;\n    }\n}\n</code></pre>\n<p>Method in the <strong>MapPainter</strong> class</p>\n<pre class=\"lang-java prettyprint-override\"><code>    @Override\n    public void paint() {\n        if (grids == null) {\n            assignValue();\n            return;\n        }\n\n        double cellWidth = getCellWidth(), cellHeight = getCellHeight();\n        boolean zooming = Camera.zooming();\n\n        for (Map.TileGrid tileGrid : grids) {\n            int offsetX = tileGrid.getOffsetX(), offsetY = tileGrid.getOffsetY();\n\n            for (Map.Tile tile : tileGrid.getAllTiles()) {\n                BufferedImage image = tile.getTileImage();\n                if (image == null) continue;\n\n                double width = cellWidth, height = cellHeight;\n                double x = width * (tile.x + offsetX), y = height * (-tile.y - offsetY);\n\n                AffineTransform transform = new AffineTransform();\n\n                // Ground tiles are already at the same size as the cell.\n                if (!tile.isGround()) {\n                    double w = image.getWidth(), h = image.getHeight();\n                    // Check how many times the cell stays inside the image, to scale it later.\n                    double timesX = w / width, timesY = h / height;\n\n                    // Calculate the target size of the tile.\n                    width = width * timesX;\n                    height = height * timesY;\n\n                    // Scale the size to the target size.\n                    transform.scale(width / w, height / h);\n\n                    // Now with the target size, we calculate the exact location to place it in its cell at (x; y).\n                    // Otherwise, when scaled it will be placed on another cell and not its original.\n\n                    // Now we correct the position by placing the x coordinate and\n                    // the bottom part of the tile in the middle of the cell.\n                    x += -(width / 2D) + (cellWidth / 2D);\n                    y += -height + (cellHeight / 2D);\n                }\n\n                if (Camera.isOutCamera(x, y, width, height)) continue;\n\n                if (zooming) {\n                    // If zooming and the tile is ground, scale it to the correct size while waiting for resizing.\n                    if (tile.isGround()) {\n                        //transform.scale(width / image.getWidth(), height / image.getHeight());\n                        x += -(width / 2) + (cellWidth / 2);\n                        y += -(height / 2) + (cellHeight / 2);\n                    }\n                    wasZooming = true;\n                } else {\n                    // Once the game is no more zooming, update the ground tile sizes and draw them without scaling.\n                    if (wasZooming) resizeMapTiles();\n                    wasZooming = false;\n                }\n                transform.translate(Camera.toX(x), Camera.toY(y));\n\n                if (zooming) {\n                    // If zooming and the tile is ground, scale it to the correct size while waiting for resizing.\n                    if (tile.isGround()) transform.scale(width / image.getWidth(), height / image.getHeight());\n\n                }\n\n                int degrees = tile.getRotation();\n                if (degrees != 0) transform.rotate(Math.toRadians(degrees), width / 2D, height / 2D);\n\n                ScreenPainter.drawImage(image, transform);\n            }\n        }\n    }\n\n</code></pre>\n<p>Any idea of why this is happening? <a href=\"https://i.giphy.com/media/v1.Y2lkPTc5MGI3NjExMnllcWxjbzBreDJoaGd2ZDkwcGR3OW83dzZ6c3hlbnNmMWVsMGhlciZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/RsWE9cmcgBRDB2y9Ml/giphy-downsized-large.gif\" rel=\"nofollow noreferrer\">Video of the problem</a></p>\n<h1>Edit 1</h1>\n<p>I found the main problem of these lines. (From what I tested)</p>\n<p><strong>The problem is drawing at double precision</strong>, I edited the zoom variable to be an integer, and the problem was dramatically reduced, now the problem happen when I try to move, because the location is also at double precision, when I draw with integer position, the problem doesn't show up.</p>\n<p>Now the other question is, how do I fix the double precision problem? Is is a rendering problem? Rounding problem?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}