{
  "question": {
    "tags": [
      "java",
      "multithreading",
      "synchronized"
    ],
    "owner": {
      "account_id": 5041901,
      "reputation": 384,
      "user_id": 15148265,
      "user_type": "registered",
      "profile_image": "https://i.sstatic.net/tDkxTYyf.png?s=256",
      "display_name": "BurgeoningApe",
      "link": "https://stackoverflow.com/users/15148265/burgeoningape"
    },
    "is_answered": true,
    "view_count": 174,
    "accepted_answer_id": 78148348,
    "answer_count": 3,
    "score": 2,
    "last_activity_date": 1738340841,
    "creation_date": 1710250994,
    "last_edit_date": 1710251394,
    "question_id": 78147629,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78147629/why-would-i-ever-create-a-separate-mutex-lock-object",
    "title": "Why would I ever create a separate mutex/lock object?",
    "body": "<p>I am modifying some concurrent code at work and recently read through Java's docs on <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html\" rel=\"nofollow noreferrer\">Intrinsic Locks and Synchronization</a>.</p>\n<p>Given that every object has an intrinsic lock, why would I ever create a separate object for the purposes of controlling access to a particular item?</p>\n<p>I recognize that there may be a use case where the item of interest is not a <code>malloc</code>'d <code>Object</code>, (<code>int</code> vs <code>Integer</code>) and therefore doesn't have an intrinsic lock but... assuming that we are concerned about synchronizing some <code>static Object</code>, is there anything to lose?</p>\n<p>e.g.:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class main {\n    public static void main (String[] args){\n        Integer foo = 10;\n        \n        synchronized(foo){\n            foo ++;\n        }\n    }\n}\n</code></pre>\n<p>If I wanted to update <code>foo</code> from multiple threads, synchronously, why wouldn't I just use the object that I want to modify? Is this less performant? I see lots of <code>synchronized(this)</code>, and separate instances where we may make a lock object for the purposes of synchronization:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class main {\n    public static void main (String[] args){\n        Integer foo = 10; \n        Object fooLock = new Object();\n        \n        synchronized(fooLock){\n            foo ++;\n        }\n    }\n}\n</code></pre>\n<p>Why would I ever create <code>fooLock</code>, when I could instead use the object of actual interest? Is this actually discouraged (not idiomatic), or is there a practical reason not to do this?</p>\n<p>I am thinking of doing the first approach (<code>synchronized(foo)</code>) for a <code>static</code> socket connection object, but it concerns me that I have not seen discussion of this. Am I missing something?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}