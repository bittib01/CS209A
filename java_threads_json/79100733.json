{
  "question": {
    "tags": [
      "java",
      "function",
      "java-stream",
      "composition"
    ],
    "owner": {
      "account_id": 24292433,
      "reputation": 21,
      "user_id": 18237196,
      "user_type": "registered",
      "profile_image": "https://lh3.googleusercontent.com/a/AATXAJxPZyEJlox8r6QUQAGqwLGgbxMG6NfoZd_Jqc_t=k-s256",
      "display_name": "Jean-Luc Delarbre",
      "link": "https://stackoverflow.com/users/18237196/jean-luc-delarbre"
    },
    "is_answered": true,
    "view_count": 100,
    "answer_count": 2,
    "score": 1,
    "last_activity_date": 1729952356,
    "creation_date": 1729231960,
    "last_edit_date": 1729265299,
    "question_id": 79100733,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79100733/peek-data-at-different-stages-of-a-java-stream-or-compose-functions",
    "title": "Peek data at different stages of a Java stream (or compose functions)",
    "body": "<p>Let say, I have the following elements:</p>\n<pre><code>class A {\n    String s;\n\n    String getS() {return s;}\n\n    static boolean aFilter(String in) {return true or false}\n\n    static A aTransformation(A a) {return another A}\n}\n</code></pre>\n<p>I would like to do the following with Java stream:</p>\n<pre><code>List&lt;A&gt; myAs = provideTheList();\n\nmyAs.stream()\n    .map(A::getS)\n    .filter(A::aFilter)\n    .map(&quot;back to stream of A&quot;)\n    .map(A::aTransformation)\n    .toList();\n</code></pre>\n<p>I know I can do it this way:</p>\n<pre><code>myAs.stream()\n    .filter(a -&gt; A.aFilter(a.getS()))\n    .map(A::aTransformation)\n    .toList();\n</code></pre>\n<p>But it breaks, the expression of code as a series of transformations. I want to avoid the &quot;a -&gt; ...&quot;. I could write a function to do the &quot;A.aFilter(a.getS())&quot;, but the above pattern is quite common and it's cumbersome to write additional function just for this. Something like:</p>\n<pre><code>myAs.stream()\n    .filter(A::aFilter Â° A::getS) // function composition\n    ...\n</code></pre>\n<p>would be perfect, but I don't know if we can express function composition in Java.</p>\n<p>In Java we have predicates which are composable with and, or.</p>\n<p>I do not found a way to compose functions in stream.</p>\n<p>Another way would be to do the &quot;back to stream of A&quot;, I do not believe it is possible to retrieve data at &quot;another point of the stream&quot;.</p>\n<p>Have you an elegant way to do the operation described above ?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}