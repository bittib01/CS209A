{
  "question": {
    "tags": [
      "java",
      "android",
      "c++",
      "java-native-interface"
    ],
    "owner": {
      "account_id": 27817647,
      "reputation": 267,
      "user_id": 21238708,
      "user_type": "registered",
      "profile_image": "https://lh3.googleusercontent.com/a/AEdFTp6tLgZNZxatzk0EmmkS4WoGYRUh1TBeb8XKKcchKw=k-s256",
      "display_name": "Jatin guglani",
      "link": "https://stackoverflow.com/users/21238708/jatin-guglani"
    },
    "is_answered": true,
    "view_count": 105,
    "accepted_answer_id": 79217464,
    "answer_count": 1,
    "score": 1,
    "last_activity_date": 1732379168,
    "creation_date": 1732275658,
    "question_id": 79214855,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79214855/why-jni-env-jni-interface-pointer-is-thread-specific",
    "title": "Why JNI env (JNI interface pointer) is thread specific?",
    "body": "<p>Two doubts from JNI Design Overview docs:</p>\n<blockquote>\n<p>The JNI interface pointer is only valid in the current thread. A native method, therefore, must not pass the interface pointer from one thread to another. A VM implementing the JNI may allocate and store thread-local data in the area pointed to by the JNI interface pointer.</p>\n</blockquote>\n<p>The JNI env(JNI interface pointer) is just a pointer to a pointer that makes JNI functions available through it.</p>\n<p>Then why each thread requires its own JNIEnv? I just want the JNIEnv to access the JNI Functions, which I believe will remain the same across every thread. why should I care to fetch JNIEnv for each thread specifically?</p>\n<p>also one vague question, what does these lines mean here:</p>\n<blockquote>\n<p>the VM may support two JNI function tables:</p>\n<p>one performs thorough illegal argument checks, and is suitable for\ndebugging;</p>\n<p>the other performs the minimal amount of checking required by the JNI\nspecification, and is therefore more efficient.</p>\n</blockquote>\n<p>Does it mean that Java VM can provide two versions of JNIEnv(pointing to two different function tables) to the consumer, with one performing thorough argument checks or does it mean internally it uses two function tables, I guess it means the later but as a consumer can take any advantage of thorough illegal arguments checks functionality.</p>\n<p>Link: <a href=\"https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/design.html#wp16696\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/design.html#wp16696</a></p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}