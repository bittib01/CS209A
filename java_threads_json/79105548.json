{
  "question": {
    "tags": [
      "java",
      "algorithm"
    ],
    "owner": {
      "account_id": 35419707,
      "reputation": 33,
      "user_id": 27192370,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/a3c25f875b1befc17ef33347df7b7677?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Mostafa Abdelhamid",
      "link": "https://stackoverflow.com/users/27192370/mostafa-abdelhamid"
    },
    "is_answered": true,
    "view_count": 123,
    "accepted_answer_id": 79105563,
    "answer_count": 3,
    "score": 2,
    "last_activity_date": 1730393570,
    "creation_date": 1729359327,
    "question_id": 79105548,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79105548/how-can-we-optimize-this-algorithm-from-on-2-to-better-complexity-in-order",
    "title": "How can we optimize this algorithm from O(N ** 2) to better complexity in order to pass performance test?",
    "body": "<p>The solution aims to calculate the number of pairs of zeros and ones without redundancy</p>\n<p>Let's say that index <code>0</code> is with value <code>0</code> and index <code>1</code> is with value <code>1</code> which means that input looks like so: <code>[0, 1]</code></p>\n<p>And this simply means that we now have <code>1</code> pair and result should be <code>1</code></p>\n<p>Another example: With the input <code>[0, 1]</code> in theory we should have 2 pairs <code>[0, 1]</code> and <code>[1, 0]</code> which are considered redundant and it should pick up only one of them so the result here should be <code>1</code></p>\n<p>Another example: With input of <code>[1, 0]</code>, the pairs should only start with indices of <code>zeros</code> not <code>ones</code> which means that <code>[0, 1]</code> is a successful pair but <code>[1, 0]</code> is not, and result in this case should be <code>0</code></p>\n<p>And if the result exceeds <code>1000000000</code>, then it should return <code>-1</code></p>\n<p>Currently I have a solution which achieves 100% correctness but in terms of performance it actually fails</p>\n<p>The complexity of this solution is <code>O(N ** 2)</code></p>\n<p>The solution is as follows:</p>\n<pre><code>        int result = 0;\n        int len = a.length;\n\n        for (int i = 0; i &lt; len; i++) {\n            int current = a[i];\n\n            if (current != 0) {\n                continue;\n            }\n\n            for (int inner = i; inner &lt; len; inner++) {\n                if (current != a[inner]) {\n                    result++;\n                }\n            }\n        }\n\n        return (result &gt; 1000000000) ? -1 : result;\n</code></pre>\n<p>What I want to achieve is to introduce a lower complexity solution in order to pass the performance tests. Can we do something better?</p>\n<p>Here are some test cases:</p>\n<p><code>[0, 1, 0, 1, 1]</code> expected result is <code>5</code> which are <code>[0, 1], [0, 3], [0, 4], [2, 3], [2, 4]</code></p>\n<p><code>[0, 1, 1, 1, 1]</code> expected result is <code>4</code> which are <code>[0, 1], [0, 2], [0, 3], [0, 4]</code></p>\n<p><code>[0, 1, 0, 0, 1, 0, 1]</code> expected result is <code>8</code> which are <code>[0, 1], [0, 4], [0, 6], [2, 4], [2, 6], [3, 4], [3, 6], [5, 6]</code></p>\n<p>Input samples must be a single array of <code>0</code>s or <code>1</code>s</p>\n<p>But when input exceeds 10,000 records, then it fails the performance test to execute during a specific period of time <code>ex: 0.6 sec</code>.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}