{
  "question": {
    "tags": [
      "java",
      "ssl",
      "certificate",
      "tls1.3",
      "sslengine"
    ],
    "owner": {
      "account_id": 28065965,
      "reputation": 11,
      "user_id": 21439358,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/ac0d5918fbfd71ab77623cd892ad05c0?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "Frederic",
      "link": "https://stackoverflow.com/users/21439358/frederic"
    },
    "is_answered": false,
    "view_count": 219,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1738839520,
    "creation_date": 1736859506,
    "last_edit_date": 1736875445,
    "question_id": 79355070,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79355070/why-is-tls-handshake-failing-in-a-java-application",
    "title": "why is TLS handshake failing in a java application?",
    "body": "<p>I'm making a client-server application. I'm trying to establish a TLS communication, but the TLS handshake is failing. The server and the client are both on the same computer, same virtual machine. I've already checked that the certificate I generated is not using DSA, but sha256WithRSAEncryption. It's based on a key I generated that's 3072 bits long. I generated both of them using certtool command. I generated a keystore for the server and a truststore for the client based on this certificate and the private key using the keytool command.\nThis is the error I get</p>\n<pre><code>java -jar target/testNio-1.0-SNAPSHOT.jar \n\nServer launched on port 8443\nBoss capture thread launches\nServer handler launches\nWorker thread launches\nThread sending messages launches\nAttempted connection detected\nTCP connection established with /127.0.0.1:44448\nAttempted tls connection detected\nNEED_UNWRAP\nflag 1\nNEED_TASK\nNEED_WRAP\nflag 2\n\njavax.net.ssl.SSLHandshakeException: No available authentication scheme\n    at java.base/sun.security.ssl.Alert.createSSLException(Alert.java:130)\n    at java.base/sun.security.ssl.Alert.createSSLException(Alert.java:117)\n    at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:365)\n    at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:321)\n    at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:312)\n    at java.base/sun.security.ssl.CertificateMessage$T13CertificateProducer.onProduceCertificate(CertificateMessage.java:975)\n    at java.base/sun.security.ssl.CertificateMessage$T13CertificateProducer.produce(CertificateMessage.java:964)\n    at java.base/sun.security.ssl.SSLHandshake.produce(SSLHandshake.java:437)\n    at java.base/sun.security.ssl.ClientHello$T13ClientHelloConsumer.goServerHello(ClientHello.java:1245)\n    at java.base/sun.security.ssl.ClientHello$T13ClientHelloConsumer.consume(ClientHello.java:1181)\n    at java.base/sun.security.ssl.ClientHello$ClientHelloConsumer.onClientHello(ClientHello.java:839)\n    at java.base/sun.security.ssl.ClientHello$ClientHelloConsumer.consume(ClientHello.java:800)\n    at java.base/sun.security.ssl.SSLHandshake.consume(SSLHandshake.java:393)\n    at java.base/sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:476)\n    at java.base/sun.security.ssl.SSLEngineImpl$DelegatedTask$DelegatedAction.run(SSLEngineImpl.java:1274)\n    at java.base/sun.security.ssl.SSLEngineImpl$DelegatedTask$DelegatedAction.run(SSLEngineImpl.java:1260)\n    at java.base/java.security.AccessController.doPrivileged(AccessController.java:714)\n    at java.base/sun.security.ssl.SSLEngineImpl$DelegatedTask.run(SSLEngineImpl.java:1205)\n    at io.test2.Boss.handleTLSConnection2(Boss.java:169)\n    at io.test2.Boss.run(Boss.java:218)\n</code></pre>\n<p>This is the code of the class responsible for the establishment of tls connections.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package io.test2;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\n//import java.net.InetSocketAddress;\n//import java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport javax.net.ssl.*;\n\npublic class Boss extends Thread {\n    public Selector acceptor;\n    public Selector com;\n    public ServerSocketChannel serverChannel;\n    public boolean running;\n    public ArrayList&lt;Session&gt; sessions;\n    public ArrayList&lt;Session&gt; sessionsTemp;\n    public SSLContext sslContext;\n\n    public Boss (Selector acceptor, Selector com, ServerSocketChannel ssc, \n    ArrayList&lt;Session&gt; sessions, SSLContext sslc) throws Exception{\n        this.acceptor = acceptor;\n        this.com = com;\n        this.serverChannel = ssc;\n        this.sessions = sessions;\n        running = true;\n        this.sslContext = sslc;\n        sessionsTemp = new ArrayList&lt;Session&gt;();\n    }\n\n    public void shutdown() {\n        running = false;\n        acceptor.wakeup();\n    }\n\n    public void clientClose(TLSConnectionInformation info, SocketChannel client) throws IOException{\n        for (int i = 0; i &lt; sessionsTemp.size(); i++) {\n            if (sessions.get(i).id.equals(info.id)) {\n                sessions.remove(i);\n                break;\n            }\n        }\n        try {\n            ByteBuffer dummy = ByteBuffer.allocate(0);\n            ByteBuffer outBuffer = ByteBuffer.allocate(info.engine.getSession().getPacketBufferSize());\n            info.engine.wrap(dummy, outBuffer);\n            info.engine.closeOutbound();\n            info.engine.closeInbound();\n        } catch(SSLException e) {\n            e.printStackTrace();}\n        client.close();\n    }\n\n    public void handleTCPConnection(ServerSocketChannel ssc, Selector slct) throws IOException {\n        \n        SocketChannel clientChannel = serverChannel.accept();\n        System.out.println(&quot;TCP connection established with &quot; + clientChannel.getRemoteAddress());\n        if (clientChannel != null) {\n            SSLEngine engine = sslContext.createSSLEngine();\n            //System.out.println(Arrays.toString(engine.getEnabledCipherSuites()));\n            engine.setUseClientMode(false); // Mode serveur\n            clientChannel.configureBlocking(false);\n            Session s = new Session(clientChannel, engine);\n            sessionsTemp.add(s);\n            clientChannel.register(acceptor, SelectionKey.OP_READ, new TLSConnectionInformation(engine, s.id));\n            engine.beginHandshake();\n        }\n    }\n\n    public void handleTLSConnection(SelectionKey key) throws IOException {\n        SocketChannel client = (SocketChannel) key.channel();\n        TLSConnectionInformation info = (TLSConnectionInformation) key.attachment();\n        SSLEngine engine = info.engine;\n        ByteBuffer appBuffer = ByteBuffer.allocate(engine.getSession().getApplicationBufferSize());\n        ByteBuffer netBuffer = ByteBuffer.allocate(engine.getSession().getPacketBufferSize());\n        int bytesRead = client.read(netBuffer);\n        if (bytesRead == -1) {\n            clientClose(info, client);\n            return;\n        }\n        netBuffer.flip();\n\n        SSLEngineResult res = engine.unwrap(netBuffer, appBuffer);\n        //appBuffer.compact();\n        if (!isTLSHandShake(netBuffer)) {\n            System.out.println(&quot;Non-TLS attempted connection. Closing connection&quot;);\n            clientClose(info, client);\n            return;\n        }\n        /*\n         * If some tasks are required to end the establishment of the TLS connection\n         */\n        if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n            Runnable task;\n            while ((task = engine.getDelegatedTask()) != null)\n                task.run();\n        }\n        if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {\n            for (int i = 0; i &lt; sessionsTemp.size(); i++) {\n                if (sessionsTemp.get(i).sc.equals(client)) {\n                    System.out.println(&quot;Connection accepted from &quot; + sessionsTemp.get(i).id.toString());\n                    sessions.add(sessionsTemp.get(i));\n                    sessionsTemp.remove(i);\n                    synchronized (com) {\n                        com.wakeup();\n                        client.register(com, SelectionKey.OP_READ, info);\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    public boolean isTLSHandShake(ByteBuffer buffer) {\n        \n        if (buffer.remaining() &lt; 5)\n            return false;\n        if (buffer.get(0) == 22 &amp;&amp; buffer.get(1) == 3)\n            return true;\n        return false;\n    }\n\n    public void handleTLSConnection2(SelectionKey key) throws IOException {\n        System.out.println(&quot;Attempted tls connection detected&quot;);\n        SocketChannel client = (SocketChannel) key.channel();\n        TLSConnectionInformation info = (TLSConnectionInformation) key.attachment();\n        SSLEngine engine = info.engine;\n        ByteBuffer appBuffer = ByteBuffer.allocate(engine.getSession().getApplicationBufferSize());\n        ByteBuffer netBuffer = ByteBuffer.allocate(engine.getSession().getPacketBufferSize());\n        while (true) {\n            SSLEngineResult.HandshakeStatus handshakeStatus = engine.getHandshakeStatus();\n            switch (handshakeStatus) {\n                case NEED_WRAP:\n                    System.out.println(&quot;NEED_WRAP&quot;);\n                    netBuffer.clear();\n                    System.out.println(&quot;flag 2&quot;);\n                    ByteBuffer buf = ByteBuffer.allocate(10);\n                    SSLEngineResult wrapResult = engine.wrap(buf, netBuffer);        //HERE2\n                    System.out.println(&quot;flag 3&quot;);\n                    if (wrapResult.getStatus() == SSLEngineResult.Status.CLOSED) {\n                        throw new IOException(&quot;Handshake failed: Engine closed during wrap&quot;);\n                    }\n                    System.out.println(&quot;flag 4&quot;);\n                    netBuffer.flip();\n                    if (netBuffer.hasRemaining()) {\n                        client.write(netBuffer);\n                    }\n                    System.out.println(&quot;flag 5&quot;);\n                    break;\n                case NEED_UNWRAP:\n                System.out.println(&quot;NEED_UNWRAP&quot;);\n                    if (client.read(netBuffer) &lt;= 0) {\n                        throw new IOException(&quot;Handshake failed: No data available during unwrap&quot;);\n                    }\n                    netBuffer.flip();\n                    SSLEngineResult unwrapResult = engine.unwrap(netBuffer, appBuffer);\n                    netBuffer.compact();\n                    if (unwrapResult.getStatus() == SSLEngineResult.Status.CLOSED) {\n                        throw new IOException(&quot;Handshake failed: Engine closed during unwrap&quot;);\n                    }\n                    System.out.println(&quot;flag 1&quot;);\n                    break;\n                case NEED_TASK:\n                System.out.println(&quot;NEED_TASK&quot;);\n                    Runnable task;\n                    while ((task = engine.getDelegatedTask()) != null) {\n                        task.run();        //HERE\n                    }\n                    break;\n                case FINISHED:\n                    System.out.println(&quot;Handshake finished&quot;);\n                    for (int i = 0; i &lt; sessionsTemp.size(); i++) {\n                        if (sessionsTemp.get(i).sc.equals(client)) {\n                            System.out.println(&quot;Connection accepted from &quot; + sessionsTemp.get(i).id.toString());\n                            sessions.add(sessionsTemp.get(i));\n                            sessionsTemp.remove(i);\n                            synchronized (com) {\n                                com.wakeup();\n                                client.register(com, SelectionKey.OP_READ, info);\n                            }\n                            break;\n                        }\n                    }\n                    return;\n                case NOT_HANDSHAKING:\n                    return;\n                default:\n                    throw new IllegalStateException(&quot;Unexpected handshake status: &quot; + handshakeStatus);     \n            }\n            if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP) \n                client.register(acceptor, SelectionKey.OP_WRITE, info);\n            else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP)\n                client.register(acceptor, SelectionKey.OP_READ, info);\n        }\n    }\n\n    public void run() {\n        System.out.println(&quot;Boss capture thread launches&quot;);\n        while (running) {\n            try {\n                acceptor.select();\n                Iterator&lt;SelectionKey&gt; keys = acceptor.selectedKeys().iterator();\n\n                while (keys.hasNext()) {\n                    SelectionKey key = keys.next();\n                    keys.remove();\n\n                    if (key.isAcceptable()) {\n                        System.out.println(&quot;Attempted connection detected&quot;);\n                        handleTCPConnection(serverChannel, acceptor);\n                    }\n                    else\n                        handleTLSConnection2(key);\n                }\n            } catch (IOException | RuntimeException e) \n                { e.printStackTrace(); }\n        }\n        sessionsTemp.clear();\n        System.out.println(&quot;Boss capture thread shutting down&quot;);\n    }\n}\n</code></pre>\n<p>So the error states that I might have a certificate problem, but the problem is also coming from the line <code>//HERE</code> in the <code>handleTLSConnection2</code> method.\nBut if I looked at the stdout, the program doesn't go past flag 2 which is <code>//HERE2</code>.\nSo my error might be from the <code>engine.wrap()</code> call; the runnable tasks launched; something wrong with the certificate, or something outside of my knowledge.\nEntry in the key ;</p>\n<pre><code>keytool -list -v -keystore keystoreServer.jks \n\nEnter keystore password:  \n\nKeystore type: PKCS12\n\nKeystore provider: SUN\n\n\n\nYour keystore contains 1 entry\n\n\n\nAlias name: server\n\nCreation date: 14 janv. 2025\n\nEntry type: trustedCertEntry\n\n\n\nOwner: C=France, UID=1.0, CN=server\n\nIssuer: C=France, UID=1.0, CN=server\n\nSerial number: 3\n\nValid from: Mon Jan 13 22:39:56 CET 2025 until: Mon Jan 20 22:40:02 CET 2025\n\nCertificate fingerprints:\n\n     SHA1: 4C:D8:8C:C6:3F:93:AE:F9:BC:A0:E9:B4:D5:1B:14:39:8D:87:B4:A9\n\n     SHA256: DD:F2:77:4C:F6:E5:61:3B:D1:6B:22:00:1C:5D:10:EC:F3:A9:9A:5C:FE:6F:FC:B2:8F:0C:0A:47:26:70:9E:DC\n\nSignature algorithm name: SHA256withRSA\n\nSubject Public Key Algorithm: 3072-bit RSA key\n\nVersion: 3\n\n\n\nExtensions: \n\n\n\n#1: ObjectId: 2.5.29.19 Criticality=true\n\nBasicConstraints:[\n\n  CA:false\n\n  PathLen: undefined\n\n]\n\n\n\n#2: ObjectId: 2.5.29.37 Criticality=false\n\nExtendedKeyUsages [\n\n  serverAuth\n\n  codeSigning\n\n  timeStamping\n\n]\n\n\n\n#3: ObjectId: 2.5.29.15 Criticality=true\n\nKeyUsage [\n\n  DigitalSignature\n\n  Key_Encipherment\n\n  Data_Encipherment\n\n]\n\n\n\n#4: ObjectId: 2.5.29.17 Criticality=false\n\nSubjectAlternativeName [\n\n  DNSName: nio\n\n]\n\n\n\n#5: ObjectId: 2.5.29.14 Criticality=false\n\nSubjectKeyIdentifier [\n\nKeyIdentifier [\n\n0000: 87 43 6A 3D 37 5B 8B 88   F1 26 78 5F EF 79 4B 51  .Cj=7[...&amp;x_.yKQ\n\n0010: 91 6A AA CC                                        .j..\n\n]\n\n]\n\n\n\n\n\n\n\n*******************************************\n\n*******************************************\n</code></pre>\n<p>Here is the main class ;</p>\n<pre><code>package io.test2;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.*;\nimport java.util.ArrayList;\nimport java.util.UUID;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport sun.misc.Signal;\nimport sun.misc.SignalHandler;\nimport javax.net.ssl.*;\nimport java.io.FileInputStream;\nimport java.security.KeyStore;\nimport java.security.SecureRandom;\n\npublic class Server {\n    public static boolean running;\n\n    public static void main(String[] args) throws IOException, InterruptedException, Exception {\n\n        int port = 8443;\n        running = true;\n        \n        KeyStore keyStore = KeyStore.getInstance(&quot;JKS&quot;);\n        FileInputStream fis = new FileInputStream(&quot;ressources/keystoreServer.jks&quot;);\n        keyStore.load(fis, &quot;motdepasse&quot;.toCharArray());\n        \n        //SSLContext\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n        keyManagerFactory.init(keyStore, &quot;motdepasse&quot;.toCharArray());\n        SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1.3&quot;);\n        sslContext.init(keyManagerFactory.getKeyManagers(), null, new SecureRandom());\n\n\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.bind(new InetSocketAddress(port));\n        serverSocketChannel.configureBlocking(false); \n\n        System.out.println(&quot;Server launched on port &quot;+ port);\n\n        Selector accept = Selector.open();\n        serverSocketChannel.register(accept, SelectionKey.OP_ACCEPT);\n\n        Selector com = Selector.open();\n\n        ArrayList&lt;Session&gt; sessions = new ArrayList&lt;Session&gt;();\n        LinkedBlockingQueue&lt;UUID&gt; listOperationDone = new LinkedBlockingQueue&lt;UUID&gt;();\n        LinkedBlockingQueue&lt;Operation&gt; operationsDone = new LinkedBlockingQueue&lt;Operation&gt;();\n        LinkedBlockingQueue&lt;Operation&gt; operationsToDo = new LinkedBlockingQueue&lt;Operation&gt;();\n\n        Boss boss = new Boss(accept, com, serverSocketChannel, sessions, sslContext);\n        Worker worker = new Worker(listOperationDone, operationsToDo, operationsDone);\n        Receiver reciever = new Receiver(serverSocketChannel, operationsToDo, \n        sessions, listOperationDone, operationsDone, com);\n        Sender sender = new Sender(sessions, listOperationDone, operationsDone);\n\n        boss.start();\n        reciever.start();\n        worker.start();\n        sender.start();\n        \n        \n        Signal.handle(new Signal(&quot;INT&quot;), new SignalHandler() {\n            @Override\n            public void handle(Signal signal) {\n                running = false;\n            }\n        });\n        \n        while (running) {\n            Thread.sleep(1000);\n        }\n        System.out.println(&quot;Shutting down server&quot;);\n        boss.shutdown();\n        worker.shutdown();\n        reciever.shutdown();\n        sender.shutdown();\n        Thread.sleep(2000);\n        accept.close();\n        com.close();\n        sessions.clear();\n        listOperationDone.clear();\n        operationsDone.clear();\n        operationsToDo.clear();\n        System.out.println(&quot;Server shut down&quot;);\n        return;\n    }\n}\n</code></pre>\n<p>the architecture of my project ;</p>\n<pre><code>tree -L 6 testNio/\n\ntestNio/\n\n├── pom.xml\n\n├── ressources\n\n│   ├── ca-cert.pem\n\n│   ├── ca-key.pem\n\n│   ├── certificateServer.pem\n\n│   ├── key2.pem\n\n│   ├── keystore.p12\n\n│   ├── keystoreServer.jks\n\n│   └── serveur-cert.crt\n\n├── src\n\n│   ├── main\n\n│   │   └── java\n\n│   │       └── io\n\n│   │           ├── App.java\n\n│   │           ├── test1\n\n│   │           │   ├── Boss.java\n\n│   │           │   ├── Operation.java\n\n│   │           │   ├── Sender.java\n\n│   │           │   ├── ServerHandler.java\n\n│   │           │   ├── Server.java\n\n│   │           │   ├── Session.java\n\n│   │           │   └── Worker.java\n\n│   │           └── test2\n\n│   │               ├── Boss.java\n\n│   │               ├── Operation.java\n\n│   │               ├── Receiver.java\n\n│   │               ├── Sender.java\n\n│   │               ├── Server.java\n\n│   │               ├── Session.java\n\n│   │               ├── TLSConnectionInformation.java\n\n│   │               └── Worker.java\n\n│   └── test\n\n│       └── java\n\n│           └── io\n\n│               └── AppTest.java\n\n└── target\n\n    ├── classes\n\n    │   └── io\n\n    │       ├── App.class\n\n    │       ├── test1\n\n    │       │   ├── Boss.class\n\n    │       │   ├── Operation.class\n\n    │       │   ├── Sender.class\n\n    │       │   ├── Server$1.class\n\n    │       │   ├── Server.class\n\n    │       │   ├── ServerHandler.class\n\n    │       │   ├── Session.class\n\n    │       │   └── Worker.class\n\n    │       └── test2\n\n    │           ├── Boss.class\n\n    │           ├── Operation.class\n\n    │           ├── Receiver.class\n\n    │           ├── Sender.class\n\n    │           ├── Server$1.class\n\n    │           ├── Server.class\n\n    │           ├── Session.class\n\n    │           ├── TLSConnectionInformation.class\n\n    │           └── Worker.class\n\n    ├── generated-sources\n\n    │   └── annotations\n\n    ├── generated-test-sources\n\n    │   └── test-annotations\n\n    ├── maven-archiver\n\n    │   └── pom.properties\n\n    ├── maven-status\n\n    │   └── maven-compiler-plugin\n\n    │       ├── compile\n\n    │       │   └── default-compile\n\n    │       │       ├── createdFiles.lst\n\n    │       │       └── inputFiles.lst\n\n    │       └── testCompile\n\n    │           └── default-testCompile\n\n    │               ├── createdFiles.lst\n\n    │               └── inputFiles.lst\n\n    ├── original-testNio-1.0-SNAPSHOT.jar\n\n    ├── surefire-reports\n\n    │   ├── io.AppTest.txt\n\n    │   └── TEST-io.AppTest.xml\n\n    ├── test-classes\n\n    │   └── io\n\n    │       └── AppTest.class\n\n    └── testNio-1.0-SNAPSHOT.jar\n\n</code></pre>\n<p>I'm using the last key and certificate i generated ; key2.pem, certificateServer.pem, keystoreServer.jks. Don't mind the other ressources.\nAny help appreciated.\nThanks for your time.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}