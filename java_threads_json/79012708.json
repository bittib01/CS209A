{
  "question": {
    "tags": [
      "java",
      "spring",
      "spring-batch"
    ],
    "owner": {
      "account_id": 35811919,
      "reputation": 3,
      "user_id": 27413645,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/d6c7f6deb4982245bb5877ec05935020?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "ogra",
      "link": "https://stackoverflow.com/users/27413645/ogra"
    },
    "is_answered": true,
    "view_count": 114,
    "accepted_answer_id": 79012784,
    "answer_count": 1,
    "score": 0,
    "last_activity_date": 1727051852,
    "creation_date": 1727044044,
    "last_edit_date": 1727048576,
    "question_id": 79012708,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79012708/how-do-i-get-my-customreaders-method-to-transfer-chunks-over-to-my-customerwrit",
    "title": "How do I get my customReader&#39;s method to transfer chunks over to my customerWriters write(Chunk&lt;&gt; chunk) method in a Spring Batch step?",
    "body": "<p>I am trying to to create a batch program in Spring that calls my database, through the reader using JdbcCursorItemReader. After the item reader is created, I assume the step takes care of iterating through it. next is dealing with the writer, I want to call the write(Chunk&lt;&gt; chunks) method that I override from ItemWriter&lt;&gt;, but it never calls it. and when I do (Assume I put customReader.read() in the reader() in step builder) I can't do the same with write(Chunk&lt;&gt; chunks) since it takes in a parameter.</p>\n<p>I have gotten an implementation to work, where I create two functions in my Configuration file reader() and writer(), where reader calls the read() in customReader returning an item reader. Then I iterate through it, adding each entry into a Chunk(List) I created outside the methods. Then I would return the reader when it became null. Then when writer was called in the writer part of the step builder, I called the method in my config again, but this time the writer one. It would take that Chunk(List) I made outside the methods, and use it as a parameter to the write() in my customWriter class. then I would just return my customWriter object I injected. This was inspired by what I saw in the documentation.</p>\n<p><a href=\"https://docs.spring.io/spring-batch/reference/step/chunk-oriented-processing.html\" rel=\"nofollow noreferrer\">https://docs.spring.io/spring-batch/reference/step/chunk-oriented-processing.html</a></p>\n<p>But this, from what I have heard is not how it should be done, since that's springs job to do, and I could confuse it when the job gets bigger or something like that. Something about the .chunk(chunkSize,transactionManager) step, still not sure.</p>\n<p>I was hoping for some guidance in this problem I have. If you would like more information, do not hesitate to ask.</p>\n<p>Edit:\nProviding Code of working case that might not be best practice</p>\n<p>Reader:</p>\n<pre><code>public JdbcCursorItemReader&lt;MyEntity&gt; itemReader() throws Exception {\n    System.out.println(&quot;We are in the database reader&quot;);\n\n\n    PreparedStatementSetter preparedStatementSetter=new PreparedStatementSetter() {\n        @Override\n        public void setValues(PreparedStatement ps) throws SQLException {\n            //code...\n        }\n    };\n\n    Chunk&lt;MyEntity&gt; items=new Chunk();\n\n    JdbcCursorItemReader itemReader = new JdbcCursorItemReader();\n    itemReader.setDataSource(dataSource);\n    itemReader.setPreparedStatementSetter(preparedStatementSetter);\n    itemReader.setName(&quot;name&quot;);\n    itemReader.setSql(&quot;SQL&quot;); //assume there is code in there and it works\n    itemReader.setRowMapper(new CustomRowMapper());\n\n    return itemReader;\n}\n</code></pre>\n<p>Writer:</p>\n<pre><code>@Override\npublic void write(Chunk&lt;? extends MyEntity&gt; chunk) throws Exception {\n    NamedParameterJdbcOperations namedParameterJdbcTemplate=new NamedParameterJdbcTemplate(dataSource);\n    System.out.println(&quot;Hello!&quot;);\n\n\n    chunk.forEach(myEntity -&gt;\n\n        namedParameterJdbcTemplate.getJdbcOperations().batchUpdate(&quot;SQL&quot;, new BatchPreparedStatementSetter() {\n            @Override\n            public void setValues(PreparedStatement ps, int i) throws SQLException {\n                // set values on sql\n            }\n\n            @Override\n            public int getBatchSize() {\n                return chunk.size(); // or any other value you want\n            }\n        })\n\n    );\n    chunk.forEach(myEntity -&gt;\n            namedParameterJdbcTemplate.getJdbcOperations().batchUpdate(&quot;SQL&quot; +\n                    &quot;VALUES (?,?,?,?,true)&quot;, new BatchPreparedStatementSetter() {\n                @Override\n                public void setValues(PreparedStatement ps, int i) throws SQLException {\n                    // set values on sql\n                }\n\n                @Override\n                public int getBatchSize() {\n                    return chunk.size(); // or any other value you want\n                }\n            })\n    );\n}\n</code></pre>\n<p>Batch Config:</p>\n<pre><code>@Configuration\n@EnableAutoConfiguration\n@ComponentScan\n@EnableBatchProcessing\npublic class Config {\n\n    private CustomReader customReader;\n\n    private CustomWriter customWriter;\n\n    private DataSource dataSource;\n\n    @Autowired\n    public Config(DataSource dataSource,CustomReader customReader,CustomWriter customWriter){\n        this.customReader=customReader;\n        this.customWriter=customWriter;\n        this.dataSource=dataSource;\n    }\n\n\n    @Bean\n    public PlatformTransactionManager transactionManager(DataSource dataSource){\n        return new DataSourceTransactionManager(dataSource);\n    }\n\n\n\n\n    Chunk&lt;myEntity&gt; chunks;\n    public ItemReader&lt;myEntity&gt; reader() throws Exception {\n        chunks=new Chunk&lt;&gt;();\n        JdbcCursorItemReader itemReader=customReader.itemReader();\n        ExecutionContext executionContext = new ExecutionContext();\n        itemReader.open(executionContext);\n        Object myEntity = new Object();\n        while(myEntity != null){\n            myEntity = itemReader.read();\n            if(myEntity==null) break;\n            chunks.add(myEntity);\n            System.out.println(myEntity);\n        }\n        return itemReader;\n    }\n    \n    public ItemWriter&lt;myEntity&gt; writer() throws Exception {\n        consoleItemWriter.write(chunks);\n        return consoleItemWriter;\n    }\n    @Bean\n    public Job myEntityJob(JobRepository jobRepository, Step myEntityStep){\n        return new JobBuilder(&quot;myEntityJob&quot;, jobRepository)\n                .incrementer(new RunIdIncrementer())\n                .start(myEntityStep)\n                .build();\n    }\n\n\n\n    @Bean\n    public Step myEntityStep(JobRepository jobRepository, PlatformTransactionManager transactionManager) throws Exception {\n        return new StepBuilder(&quot;myEntityStep&quot;, jobRepository)\n                .&lt;MyEntity,MyEntity&gt;chunk(10,transactionManager)\n                .reader(reader(databaseReader))\n                .writer(writer(consoleItemWriter))\n                .build();\n    }\n\n\n\n\n    public static void main(String[] args) throws Exception {\n        // System.exit is common for Batch applications since the exit code can be used to\n        // drive a workflow\n        System.exit(SpringApplication.exit(SpringApplication.run(\n                Config.class, args)));\n    }\n}\n</code></pre>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}