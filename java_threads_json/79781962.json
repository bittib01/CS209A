{
  "question": {
    "tags": [
      "java",
      "spring-boot",
      "generics",
      "jwt",
      "jwe"
    ],
    "owner": {
      "account_id": 41950885,
      "reputation": 33,
      "user_id": 30525100,
      "user_type": "registered",
      "profile_image": "https://www.gravatar.com/avatar/c5f0b09a8c76e317d2bcc6ee0dd19cee?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "LaggyLogic",
      "link": "https://stackoverflow.com/users/30525100/laggylogic"
    },
    "is_answered": true,
    "view_count": 108,
    "accepted_answer_id": 79782020,
    "answer_count": 2,
    "score": 3,
    "last_activity_date": 1759593739,
    "creation_date": 1759507755,
    "last_edit_date": 1759593739,
    "question_id": 79781962,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/79781962/any-way-to-check-a-cast-to-a-generic",
    "title": "Any way to check a cast to a generic?",
    "body": "<p>I am working on a Spring Boot application and there I use JWE - tokens. When generating these tokens I serialize a given DTO. As an example, the generation of an AccessToken looks like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public Jwe generateAccessToken(AccessTokenDto dto) throws Exception {\n    return generateToken(\n            dto.getId().toString(),\n            Map.of(\n                    &quot;dto&quot;, dto,\n                    &quot;dtoClassName&quot;, dto.getClass().getName()\n            ),\n            config.getAccessTokenExpiration()\n    );\n}\n\nprivate Jwe generateToken(String subject, Map&lt;String, Object&gt; claims, long expiration) throws Exception {\n    var claimSetBuilder = new JWTClaimsSet.Builder()\n        .subject(subject)\n        .issuer(config.getIssuer())\n        .issueTime(new Date())\n        .expirationTime(new Date(System.currentTimeMillis() + 1000 * expiration));\n    for (Map.Entry&lt;String, Object&gt; claimEntry : claims.entrySet()) {\n        if (claimEntry.getValue() instanceof String value) {\n            claimSetBuilder.claim(claimEntry.getKey(), value);\n        } else {\n            claimSetBuilder.claim(claimEntry.getKey(), serialise(claimEntry.getValue()));\n        }\n    }\n    return new Jwe(\n            claimSetBuilder.build(),\n            config.signingKey(),\n            config.encryptionKey()\n    );\n}\n\nprivate String serialise(Object dto) throws IOException {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(dto);\n    oos.close();\n    return Base64.getEncoder().encodeToString(baos.toByteArray());\n}\n</code></pre>\n<p>while the AccessTokenDto itself looks like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Data\npublic class AccessTokenDto implements Serializable {\n    @ValidUserId\n    private UUID id;\n    @ValidUserRole\n    private Role role;\n}\n</code></pre>\n<p>When I later want to get from a already, successfully parsed Jwe, I use these three methods:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public &lt;T&gt; T toDto() throws IOException {\n    Class&lt;T&gt; type = (Class&lt;T&gt;) getDtoClass();\n    Object deserializedDto = deserialize();\n    if (!type.isInstance(deserializedDto)) {\n        return null;\n    }\n    return type.cast(deserializedDto);\n}\n\nprivate Class&lt;?&gt; getDtoClass() throws IOException {\n    String className = (String) claims.getClaim(&quot;dtoClassName&quot;);\n    Class&lt;?&gt; type = null;\n    try {\n        type = Class.forName(className);\n    } catch (ClassNotFoundException e) {\n        throw new IOException(&quot;When deserialzing Token - No Class with Name: &quot; + className);\n    }\n    return type;\n}\n\nprivate Object deserialize() {\n    Object serializedDto = claims.getClaim(&quot;dto&quot;);\n    if (!(serializedDto instanceof String)) {\n        return null;\n    }\n    byte[] data = Base64.getDecoder().decode(serializedDto.toString());\n    try {\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data));\n        Object obj = ois.readObject();\n        ois.close();\n        return obj;\n    } catch (Exception e) {\n        System.out.println(&quot;Error while deserializing token&quot;);\n    }\n    return null;\n}\n</code></pre>\n<p>I know this code works and I also know that there shouldn't be a problem since the &quot;dtoClassName&quot; claim is allays set correctly when generating a token. (As long as I code the method to generate the tokens right.) But IntelliJ gives a warning about an unchecked cast, which I would like to get rid of.</p>\n<p>How do I safely cast to the generic in the first line of this method?</p>\n<pre class=\"lang-java prettyprint-override\"><code>public &lt;T&gt; T toDto() throws IOException {\n    Class&lt;T&gt; type = (Class&lt;T&gt;) getDtoClass();\n    Object deserializedDto = deserialize();\n    if (!type.isInstance(deserializedDto)) {\n        return null;\n    }\n    return type.cast(deserializedDto);\n}\n</code></pre>\n<p>My attempts for a solution/workaround:</p>\n<p>I experimented a bit with Optionals</p>\n<pre class=\"lang-java prettyprint-override\"><code>public Optional&lt;?&gt; toDto() {\n\n    Class&lt;?&gt; targetType = getDtoClass();\n    Object deserializedDto = deserialize();\n    if (!targetType.isInstance(deserializedDto)) {\n        return Optional.empty();\n    }\n    return Optional.of(targetType.cast(deserializedDto));\n}\n</code></pre>\n<p>to work around the problem, but that did not go well since I wanted to be able to access the methods of the DTO, and that was not possible.</p>\n<p>Then I searched for ways to check the cast and found the <code>isAssignableFrom(Class&lt;T&gt; class)</code> method, but I could not get it to work. I also tried ways of using <code>isInstance</code>, but that led to nothing.</p>\n<p>I read somewhere that such a scenario can not be checked because it is a compile time issue, not a runtime issue, but I am not sure.</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}