{
  "question": {
    "tags": [
      "java",
      "spring",
      "spring-boot",
      "spring-security",
      "spring-webflux"
    ],
    "owner": {
      "account_id": 6761181,
      "reputation": 1344,
      "user_id": 5207900,
      "user_type": "registered",
      "profile_image": "https://i.sstatic.net/nzO0q.png?s=256",
      "display_name": "Marteng",
      "link": "https://stackoverflow.com/users/5207900/marteng"
    },
    "is_answered": true,
    "view_count": 227,
    "accepted_answer_id": 78705595,
    "answer_count": 2,
    "score": -1,
    "last_activity_date": 1720077692,
    "creation_date": 1718987683,
    "last_edit_date": 1719043035,
    "question_id": 78653550,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78653550/handling-internal-server-error-when-oauth-issuer-is-not-available-in-webfluxsecu",
    "title": "Handling Internal Server Error When OAuth Issuer Is Not Available in WebFluxSecurity",
    "body": "<p>I cannot customize the default &quot;500 internal server error&quot; response body in case the issuer (Keycloak) for my reactive Spring resource server is unavailable. I want to add a custom JSON response, but, for example, the usual <code>@ExceptionHandler</code> does not work because the authentication won't pass.</p>\n<p><code>pom.xml</code> (Spring security v6.2.0, Spring boot v3.2.0):</p>\n<pre class=\"lang-xml prettyprint-override\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-oauth2-resource-server&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-security-oauth2-jose&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p><code>application.yaml</code> (<strong>The issuer-uri is wrong on purpose: I want to simulate that my authentication server, Keycloak, is not available</strong>):</p>\n<pre class=\"lang-yaml prettyprint-override\"><code>spring:\n  security:\n    oauth2:\n      resourceserver:\n        jwt:\n          issuer-uri: ${JWT_ISSUER_URI:http://notavailable.io/realms/my-realm}\n</code></pre>\n<p><code>SecurityConfig.java</code>:</p>\n<pre class=\"lang-java prettyprint-override\"><code>import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.server.reactive.ServerHttpResponse;\nimport org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;\nimport org.springframework.security.config.web.server.ServerHttpSecurity;\nimport org.springframework.security.web.server.SecurityWebFilterChain;\nimport org.springframework.web.server.ServerWebExchange;\nimport reactor.core.publisher.Mono;\n\nimport java.nio.charset.StandardCharsets;\n\nimport static org.springframework.http.MediaType.APPLICATION_JSON;\nimport static org.springframework.security.config.Customizer.withDefaults;\n\n@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfiguration {\n\n\n    @Bean\n    SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n        return http.authorizeExchange(exchanges -&gt; exchanges.pathMatchers(&quot;/actuator/**&quot;)\n                        .permitAll()\n                        .anyExchange()\n                        .hasAuthority(&quot;SCOPE_foobar&quot;))\n                .oauth2ResourceServer(oAuth2ResourceServerSpec -&gt; oAuth2ResourceServerSpec.jwt(withDefaults())\n                        .authenticationEntryPoint((webExchance, exception) -&gt; handleAuthError(webExchance))\n                        .accessDeniedHandler((webExchance, exception) -&gt; handleAuthError(webExchance)))\n                .csrf(ServerHttpSecurity.CsrfSpec::disable)\n                .build();\n    }\n\n    /**\n     * @SO: This handle is called if the authentication fails with 401 or 403. But it's not called if an 500 internal\n     *      server error is thrown.\n     */\n    private Mono&lt;Void&gt; handleAuthError(ServerWebExchange webExchance) {\n        final ServerHttpResponse response = webExchance.getResponse();\n        response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);\n        response.getHeaders().setContentType(APPLICATION_JSON);\n\n        final var msg = &quot;{\\&quot;foo\\&quot;:\\&quot;bar\\&quot;}&quot;.getBytes(StandardCharsets.UTF_8);\n        return response.writeWith(Mono.just(response.bufferFactory().wrap(msg)));\n    }\n}\n\n</code></pre>\n<p>If I send a request to my server (there is a <code>/foobar</code> controller) while the <code>issuer-uri</code> is not available, the server logs the following stacktrace:</p>\n<pre><code>Error has been observed at the following site(s):\n    *__checkpoint ⇢ AuthenticationWebFilter [DefaultWebFilterChain]\n    *__checkpoint ⇢ ReactorContextWebFilter [DefaultWebFilterChain]\n    *__checkpoint ⇢ HttpHeaderWriterWebFilter [DefaultWebFilterChain]\n    *__checkpoint ⇢ ServerWebExchangeReactorContextWebFilter [DefaultWebFilterChain]\n    *__checkpoint ⇢ org.springframework.security.web.server.WebFilterChainProxy [DefaultWebFilterChain]\n    *__checkpoint ⇢ HTTP GET &quot;/foobar&quot; [ExceptionHandlingWebHandler]\nOriginal Stack Trace:\n        at org.springframework.security.oauth2.server.resource.authentication.JwtReactiveAuthenticationManager.onError(JwtReactiveAuthenticationManager.java:81)\n        at reactor.core.publisher.Mono.lambda$onErrorMap$27(Mono.java:3785)\n        at reactor.core.publisher.Mono.lambda$onErrorResume$29(Mono.java:3875)\n        at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:94)\n[...]\nCaused by: org.springframework.security.oauth2.jwt.JwtException: An error occurred while attempting to decode the Jwt: \n    at org.springframework.security.oauth2.jwt.NimbusReactiveJwtDecoder.lambda$decode$2(NimbusReactiveJwtDecoder.java:171)\n    at reactor.core.publisher.Mono.lambda$onErrorMap$27(Mono.java:3785)\n    at reactor.core.publisher.Mono.lambda$onErrorResume$29(Mono.java:3875)\n    at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:94)\n[...]\nCaused by: java.lang.IllegalArgumentException: Unable to resolve the Configuration with the provided Issuer of &quot;http://notavailable.io/realms/foobar/realms/my-realm&quot;\n    at org.springframework.security.oauth2.jwt.ReactiveJwtDecoderProviderConfigurationUtils.lambda$getConfiguration$8(ReactiveJwtDecoderProviderConfigurationUtils.java:139)\n    at reactor.core.publisher.Flux.lambda$onErrorMap$28(Flux.java:7239)\n    at reactor.core.publisher.Flux.lambda$onErrorResume$29(Flux.java:7292)\n[...]\nCaused by: org.springframework.web.reactive.function.client.WebClientRequestException: Failed to resolve 'notavailable.io' [A(1)] after 4 queries \n    at org.springframework.web.reactive.function.client.ExchangeFunctions$DefaultExchangeFunction.lambda$wrapException$9(ExchangeFunctions.java:136)\n</code></pre>\n<p>The <code>IllegalArgumentException</code> is thrown in the <code>org.springframework.security.oauth2.jwt.ReactiveJwtDecoderProviderConfigurationUtils#getConfiguration</code> (in the <code>onErrorMap</code> line) whose impl looks like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>    private static Mono&lt;Map&lt;String, Object&gt;&gt; getConfiguration(String issuer, WebClient web, URI... uris) {\n        String errorMessage = &quot;Unable to resolve the Configuration with the provided Issuer of &quot; + &quot;\\&quot;&quot; + issuer + &quot;\\&quot;&quot;;\n        return Flux.just(uris)\n            .concatMap((uri) -&gt; web.get().uri(uri).retrieve().bodyToMono(STRING_OBJECT_MAP))\n            .flatMap((configuration) -&gt; {\n                if (configuration.get(&quot;jwks_uri&quot;) == null) {\n                    return Mono.error(() -&gt; new IllegalArgumentException(&quot;The public JWK set URI must not be null&quot;));\n                }\n                return Mono.just(configuration);\n            })\n            .onErrorContinue((ex) -&gt; ex instanceof WebClientResponseException\n                    &amp;&amp; ((WebClientResponseException) ex).getStatusCode().is4xxClientError(), (ex, object) -&gt; {\n                    })\n            .onErrorMap(RuntimeException.class,\n                    (ex) -&gt; (ex instanceof IllegalArgumentException) ? ex\n                            : new IllegalArgumentException(errorMessage, ex))\n            .next()\n            .switchIfEmpty(Mono.error(() -&gt; new IllegalArgumentException(errorMessage)));\n    }\n</code></pre>\n<p><strong>Actual Behavior</strong></p>\n<p>If the issuer is not available, the client gets a <code>500 internal server error</code> response with the body:</p>\n<pre class=\"lang-json prettyprint-override\"><code>{\n    &quot;timestamp&quot;: &quot;2024-06-21T16:18:13.190+00:00&quot;,\n    &quot;path&quot;: &quot;/foobar&quot;,\n    &quot;status&quot;: 500,\n    &quot;error&quot;: &quot;Internal Server Error&quot;,\n    &quot;requestId&quot;: &quot;2eeaa482-2&quot;\n}\n</code></pre>\n<p><strong>Desired Behavior</strong></p>\n<p>If the issuer is not available, the client gets a <code>500 internal server error</code> response with the body:</p>\n<pre class=\"lang-json prettyprint-override\"><code>{\n    &quot;foo&quot;: &quot;bar&quot;\n}\n</code></pre>\n<hr />\n<p>I tried using <code>@ExceptionHandler</code> (is not called) and creating my own <code>JwtDecoder</code> (I don't find a method I could override to catch the exception and send a response).</p>\n<p>Does anyone know how to modify the response when the <code>issuer-URI</code> is unavailable?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}