{
  "question": {
    "tags": [
      "java",
      "hibernate",
      "jpa"
    ],
    "owner": {
      "account_id": 4321939,
      "reputation": 986,
      "user_id": 3529850,
      "user_type": "registered",
      "accept_rate": 67,
      "profile_image": "https://www.gravatar.com/avatar/d557f3a5cdb654ef04d42c06a0e5869a?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name": "user3529850",
      "link": "https://stackoverflow.com/users/3529850/user3529850"
    },
    "is_answered": true,
    "view_count": 266,
    "accepted_answer_id": 78682216,
    "answer_count": 2,
    "score": 3,
    "last_activity_date": 1719574436,
    "creation_date": 1718819144,
    "question_id": 78643966,
    "content_license": "CC BY-SA 4.0",
    "link": "https://stackoverflow.com/questions/78643966/problem-with-proper-usage-of-orphan-removal",
    "title": "Problem with proper usage of orphan removal",
    "body": "<ul>\n<li>I use spring boot <code>2.7.18</code> with java <code>17</code> and maven.</li>\n<li>Please treat it purely for educational purposes (don't shout at me\nthat that's not how filtering and updating should work, I know it).</li>\n<li>I've created that simple example after reading <a href=\"https://vladmihalcea.com/hibernate-multiplebagfetchexception/\" rel=\"nofollow noreferrer\">the article</a> about\n'best way to handle hibernate MultipleBagFetchException' and stumbled\nupon the problem with proper orphan removal, hence the question.</li>\n</ul>\n<p>I have following entities:</p>\n<pre><code>@Entity\n@Getter\n@Setter\n@Table(name = &quot;post&quot;)\n@SequenceGenerator(name = &quot;post_seq&quot;, sequenceName = &quot;post_id_seq&quot;, allocationSize = 1)\npublic class Post {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;post_seq&quot;)\n    Long id;\n\n    @ToString.Exclude\n    @EqualsAndHashCode.Exclude\n    @OneToMany(mappedBy = &quot;post&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    List&lt;Comment&gt; comments;\n\n    @ToString.Exclude\n    @EqualsAndHashCode.Exclude\n    @OneToMany(fetch = FetchType.EAGER, mappedBy = &quot;post&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    List&lt;Metadata&gt; metadata;\n\n    @Enumerated(EnumType.STRING)\n    PostStatus status;\n}\n</code></pre>\n<p>and</p>\n<pre><code>@Entity\n@Getter\n@Setter\n@Table(name = &quot;metadata&quot;)\n@SequenceGenerator(name = &quot;post_metadata_seq&quot;, sequenceName = &quot;post_metadata_id_seq&quot;, allocationSize = 1)\npublic class Metadata {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;post_metadata_seq&quot;)\n    Long id;\n\n    @ManyToOne\n    @JoinColumn(name = &quot;post_id&quot;)\n    Post post;\n\n    @Column(name = &quot;\\&quot;key\\&quot;&quot;)\n    String key;\n\n    @Column(name = &quot;\\&quot;value\\&quot;&quot;)\n    String value;\n}\n</code></pre>\n<p>and</p>\n<pre><code>@Entity\n@Getter\n@Setter\n@Table(name = &quot;comment&quot;)\n@SequenceGenerator(name = &quot;post_comment_seq&quot;, sequenceName = &quot;post_comment_id_seq&quot;, allocationSize = 1)\npublic class Comment {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;post_comment_seq&quot;)\n    Long id;\n\n    @ManyToOne\n    @JoinColumn(name = &quot;post_id&quot;)\n    Post post;\n\n    String text;\n}\n</code></pre>\n<p>and corresponding DTOs:</p>\n<pre><code>@Builder(toBuilder = true)\n@Getter\n@Jacksonized\npublic class PostDTO {\n    Long id;\n    MetadataDTO metadata;\n    List&lt;CommentDTO&gt; comments;\n    PostStatus status;\n}\n</code></pre>\n<p>and</p>\n<pre><code>@ToString\n@Value(staticConstructor = &quot;of&quot;)\npublic class MetadataDTO {\n\n    Map&lt;String, String&gt; metadata;\n\n    @JsonCreator\n    @Builder(toBuilder = true)\n    public MetadataDTO(@JsonProperty(&quot;metadata&quot;) final Map&lt;String, String&gt; metadata) {\n        this.metadata = Optional.ofNullable(metadata)\n                .map(HashMap::new)\n                .map(Collections::unmodifiableMap)\n                .orElse(Map.of());\n    }\n}\n</code></pre>\n<p>service:</p>\n<pre><code>@Service\n@RequiredArgsConstructor\npublic class PostService {\n\n    public final PersistablePostMapper persistablePostMapper;\n    public final PostRepository postRepository;\n    public final EntityManager entityManager;\n\n    @Transactional\n    public PostDTO saveAll(final PostDTO postDTO) throws BadRequestException {\n        String referenceId = postDTO.getMetadata().getMetadata().get(&quot;reference_id&quot;);\n        List&lt;Long&gt; alreadyClosedPostIds = findAllByReferenceId(Long.valueOf(referenceId)).stream()\n                .filter(p -&gt; PostStatus.CLOSED.equals(p.getStatus()))\n                .map(PostDTO::getId)\n                .toList();\n        if (alreadyClosedPostIds.contains(postDTO.getId())) {\n            throw new BadRequestException();\n        }\n\n        return save(postDTO);\n    }\n\n    public List&lt;PostDTO&gt; findAllByReferenceId(final Long referenceId) {\n        List&lt;Post&gt; posts = entityManager.createQuery(&quot;&quot;&quot;\n                        select distinct p\n                        from Post p\n                        left join fetch p.metadata m\n                        where m.key=:key and m.value=:value&quot;&quot;&quot;, Post.class)\n                .setParameter(&quot;key&quot;, &quot;reference_id&quot;)\n                .setParameter(&quot;value&quot;, String.valueOf(referenceId))\n                .setHint(QueryHints.PASS_DISTINCT_THROUGH, false)\n                .getResultList();\n\n        posts = entityManager.createQuery(&quot;&quot;&quot;\n                                select distinct p\n                                from Post p\n                                left join fetch p.comments l\n                                where p in :posts&quot;&quot;&quot;\n                        , Post.class)\n                .setParameter(&quot;posts&quot;, posts)\n                .setHint(QueryHints.PASS_DISTINCT_THROUGH, false)\n                .getResultList();\n        return posts.stream().map(persistablePostMapper::mapToPost).collect(Collectors.toList());\n    }\n\n    public PostDTO save(final PostDTO postDTO) {\n        Post persistablePost = persistablePostMapper.mapToPersistablePost(postDTO);\n        Post savedPersistablePost = postRepository.save(persistablePost);\n\n        return persistablePostMapper.mapToPost(savedPersistablePost);\n    }\n}\n</code></pre>\n<p>controller:</p>\n<pre><code>@RequiredArgsConstructor\n@RestController\n@RequestMapping(&quot;/api/posts&quot;)\npublic class PostController {\n\n    private final PostService postService;\n\n    @PostMapping\n    PostDTO createOrUpdatePosts(@RequestBody final PostDTO postDTO) throws BadRequestException {\n        return postService.saveAll(postDTO);\n    }\n}\n</code></pre>\n<p>and the test:</p>\n<pre><code>@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@ActiveProfiles(profiles = {&quot;test&quot;})\n@AutoConfigureMockMvc\nclass PostControllerTest {\n\n    @Autowired\n    protected MockMvc mockMvc;\n\n    @Autowired\n    protected ObjectMapper objectMapper;\n\n    @Autowired\n    protected PostService postService;\n\n    private static final TypeReference&lt;PostDTO&gt; POST_TYPE_REFERENCE = new TypeReference&lt;&gt;() {\n    };\n\n    @Test\n    void shouldUpdatePostComments() throws Exception {\n        //given\n        CommentDTO comment1 = CommentDTO.builder()\n                .text(&quot;test1&quot;)\n                .build();\n        CommentDTO comment2 = CommentDTO.builder()\n                .text(&quot;test2&quot;)\n                .build();\n        List&lt;CommentDTO&gt; commentsBeforeUpdate = List.of(comment1);\n        List&lt;CommentDTO&gt; commentsAfterUpdate = List.of(comment1, comment2);\n        PostDTO postWithOneComment = PostDTO.builder()\n                .status(PostStatus.OPEN)\n                .metadata(MetadataDTO.builder()\n                        .metadata(Map.of(\n                                &quot;reference_id&quot;, &quot;100&quot;,\n                                &quot;origin&quot;, &quot;test&quot;))\n                        .build())\n                .comments(commentsBeforeUpdate)\n                .build();\n        PostDTO savedPost = postService.save(postWithOneComment);\n\n        List&lt;PostDTO&gt; postBeforeUpdate = postService.findAllByReferenceId(100L);\n\n        //when\n        MockHttpServletResponse response = mockMvc.perform(post(&quot;/api/posts&quot;)\n                        .contentType(MediaType.APPLICATION_JSON)\n                        .content(objectMapper.writeValueAsString(savedPost.toBuilder()\n                                .comments(commentsAfterUpdate)\n                                .build())))\n                .andReturn().getResponse();\n\n        //then\n        assertThat(response.getStatus()).isEqualTo(HttpStatus.OK.value());\n        PostDTO returnedPost = objectMapper.readValue(response.getContentAsString(), POST_TYPE_REFERENCE);\n        PostDTO postAfterUpdate = postService.findAllByReferenceId(100L).get(0);\n\n        assertThat(returnedPost).isEqualTo(postAfterUpdate);\n        assertThat(postBeforeUpdate.size()).isEqualTo(1);\n        assertThat(postBeforeUpdate.get(0).getComments()).isEqualTo(commentsBeforeUpdate);\n        assertThat(postAfterUpdate.getComments()).isEqualTo(commentsAfterUpdate);\n    }\n}\n</code></pre>\n<hr />\n<ul>\n<li>The problem is that the test is not passing becuase of: <code>java.lang.IllegalStateException: Duplicate key origin (attempted merging values test and test)</code></li>\n<li>The SQLs that are generated shows that only one line and only one metadata is deleted (the one with &quot;reference_id&quot; and not the one with &quot;origin&quot;)</li>\n<li>That happens, probably because <code>metadata</code> in <code>Post</code> has <code>orphanRemoval = true</code> and for some reason, only &quot;reference_id&quot; is deleted and 'put' again (because of <code>cascade.ALL</code>).</li>\n<li>This means that during &quot;update&quot; request in the above test, we have three metadata in the Post: 2x with key &quot;origin&quot; (the old one and the new one as orphanremoval did't delete it) and 1x with key &quot;reference_id&quot; (old one replaced with new one).</li>\n<li>That causes the issue in: <code>posts.stream().map(persistablePostMapper::mapToPost).collect(Collectors.toList());</code> where it maps metadata:</li>\n</ul>\n<p>stacktrace in <code>Duplicate key exception</code> points here (to the <code>toMap</code>):</p>\n<pre><code>default MetadataDTO mapToMetadataDTO(final List&lt;Metadata&gt; persistableMetadata) {\n    Map&lt;String, String&gt; metadata = persistableMetadata\n            .stream()\n            .filter(content -&gt; content.getKey() != null &amp;&amp; content.getValue() != null)\n            .collect(Collectors.toMap(Metadata::getKey, Metadata::getValue));\n    return MetadataDTO.builder()\n            .metadata(metadata)\n            .build();\n}\n</code></pre>\n<p>Could someone explain me why orphan removal is not recreating/removing the whole metadata collection but only &quot;reference_id&quot; ? Why metadata with key &quot;origin&quot; is not recreated as well ?</p>\n"
  },
  "answers": [],
  "question_comments": [],
  "answer_comments": {}
}